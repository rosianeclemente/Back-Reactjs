{"ast":null,"code":"const {\n  pushQuery,\n  pushAdditional,\n  unshiftQuery\n} = require('./internal/helpers'); // The \"SchemaCompiler\" takes all of the query statements which have been\n// gathered in the \"SchemaBuilder\" and turns them into an array of\n// properly formatted / bound query strings.\n\n\nclass SchemaCompiler {\n  constructor(client, builder) {\n    this.builder = builder;\n    this._commonBuilder = this.builder;\n    this.client = client;\n    this.schema = builder._schema;\n    this.bindings = [];\n    this.bindingsHolder = this;\n    this.formatter = client.formatter(builder);\n    this.formatter.bindings = this.bindings;\n    this.sequence = [];\n  }\n\n  createSchema() {\n    throwOnlyPGError('createSchema');\n  }\n\n  createSchemaIfNotExists() {\n    throwOnlyPGError('createSchemaIfNotExists');\n  }\n\n  dropSchema() {\n    throwOnlyPGError('dropSchema');\n  }\n\n  dropSchemaIfExists() {\n    throwOnlyPGError('dropSchemaIfExists');\n  }\n\n  dropTable(tableName) {\n    this.pushQuery(this.dropTablePrefix + this.formatter.wrap(prefixedTableName(this.schema, tableName)));\n  }\n\n  dropTableIfExists(tableName) {\n    this.pushQuery(this.dropTablePrefix + 'if exists ' + this.formatter.wrap(prefixedTableName(this.schema, tableName)));\n  }\n\n  raw(sql, bindings) {\n    this.sequence.push(this.client.raw(sql, bindings).toSQL());\n  }\n\n  toSQL() {\n    const sequence = this.builder._sequence;\n\n    for (let i = 0, l = sequence.length; i < l; i++) {\n      const query = sequence[i];\n      this[query.method].apply(this, query.args);\n    }\n\n    return this.sequence;\n  }\n\n  async generateDdlCommands() {\n    const generatedCommands = this.toSQL();\n    return {\n      pre: [],\n      sql: Array.isArray(generatedCommands) ? generatedCommands : [generatedCommands],\n      post: []\n    };\n  }\n\n}\n\nSchemaCompiler.prototype.dropTablePrefix = 'drop table ';\nSchemaCompiler.prototype.alterTable = buildTable('alter');\nSchemaCompiler.prototype.createTable = buildTable('create');\nSchemaCompiler.prototype.createTableIfNotExists = buildTable('createIfNot');\nSchemaCompiler.prototype.pushQuery = pushQuery;\nSchemaCompiler.prototype.pushAdditional = pushAdditional;\nSchemaCompiler.prototype.unshiftQuery = unshiftQuery;\n\nfunction buildTable(type) {\n  return function (tableName, fn) {\n    const builder = this.client.tableBuilder(type, tableName, fn); // pass queryContext down to tableBuilder but do not overwrite it if already set\n\n    const queryContext = this.builder.queryContext();\n\n    if (queryContext !== undefined && builder.queryContext() === undefined) {\n      builder.queryContext(queryContext);\n    }\n\n    builder.setSchema(this.schema);\n    const sql = builder.toSQL();\n\n    for (let i = 0, l = sql.length; i < l; i++) {\n      this.sequence.push(sql[i]);\n    }\n  };\n}\n\nfunction prefixedTableName(prefix, table) {\n  return prefix ? `${prefix}.${table}` : table;\n}\n\nfunction throwOnlyPGError(operationName) {\n  throw new Error(`${operationName} is not supported for this dialect (only PostgreSQL supports it currently).`);\n}\n\nmodule.exports = SchemaCompiler;","map":{"version":3,"sources":["/home/rosiane/Projeto-completo/back/node_modules/knex/lib/schema/compiler.js"],"names":["pushQuery","pushAdditional","unshiftQuery","require","SchemaCompiler","constructor","client","builder","_commonBuilder","schema","_schema","bindings","bindingsHolder","formatter","sequence","createSchema","throwOnlyPGError","createSchemaIfNotExists","dropSchema","dropSchemaIfExists","dropTable","tableName","dropTablePrefix","wrap","prefixedTableName","dropTableIfExists","raw","sql","push","toSQL","_sequence","i","l","length","query","method","apply","args","generateDdlCommands","generatedCommands","pre","Array","isArray","post","prototype","alterTable","buildTable","createTable","createTableIfNotExists","type","fn","tableBuilder","queryContext","undefined","setSchema","prefix","table","operationName","Error","module","exports"],"mappings":"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","sourcesContent":["const {\n  pushQuery,\n  pushAdditional,\n  unshiftQuery,\n} = require('./internal/helpers');\n\n// The \"SchemaCompiler\" takes all of the query statements which have been\n// gathered in the \"SchemaBuilder\" and turns them into an array of\n// properly formatted / bound query strings.\nclass SchemaCompiler {\n  constructor(client, builder) {\n    this.builder = builder;\n    this._commonBuilder = this.builder;\n    this.client = client;\n    this.schema = builder._schema;\n\n    this.bindings = [];\n    this.bindingsHolder = this;\n    this.formatter = client.formatter(builder);\n    this.formatter.bindings = this.bindings;\n    this.sequence = [];\n  }\n\n  createSchema() {\n    throwOnlyPGError('createSchema');\n  }\n\n  createSchemaIfNotExists() {\n    throwOnlyPGError('createSchemaIfNotExists');\n  }\n\n  dropSchema() {\n    throwOnlyPGError('dropSchema');\n  }\n\n  dropSchemaIfExists() {\n    throwOnlyPGError('dropSchemaIfExists');\n  }\n\n  dropTable(tableName) {\n    this.pushQuery(\n      this.dropTablePrefix +\n        this.formatter.wrap(prefixedTableName(this.schema, tableName))\n    );\n  }\n\n  dropTableIfExists(tableName) {\n    this.pushQuery(\n      this.dropTablePrefix +\n        'if exists ' +\n        this.formatter.wrap(prefixedTableName(this.schema, tableName))\n    );\n  }\n\n  raw(sql, bindings) {\n    this.sequence.push(this.client.raw(sql, bindings).toSQL());\n  }\n\n  toSQL() {\n    const sequence = this.builder._sequence;\n    for (let i = 0, l = sequence.length; i < l; i++) {\n      const query = sequence[i];\n      this[query.method].apply(this, query.args);\n    }\n    return this.sequence;\n  }\n\n  async generateDdlCommands() {\n    const generatedCommands = this.toSQL();\n    return {\n      pre: [],\n      sql: Array.isArray(generatedCommands)\n        ? generatedCommands\n        : [generatedCommands],\n      post: [],\n    };\n  }\n}\n\nSchemaCompiler.prototype.dropTablePrefix = 'drop table ';\n\nSchemaCompiler.prototype.alterTable = buildTable('alter');\nSchemaCompiler.prototype.createTable = buildTable('create');\nSchemaCompiler.prototype.createTableIfNotExists = buildTable('createIfNot');\n\nSchemaCompiler.prototype.pushQuery = pushQuery;\nSchemaCompiler.prototype.pushAdditional = pushAdditional;\nSchemaCompiler.prototype.unshiftQuery = unshiftQuery;\n\nfunction buildTable(type) {\n  return function (tableName, fn) {\n    const builder = this.client.tableBuilder(type, tableName, fn);\n\n    // pass queryContext down to tableBuilder but do not overwrite it if already set\n    const queryContext = this.builder.queryContext();\n    if (queryContext !== undefined && builder.queryContext() === undefined) {\n      builder.queryContext(queryContext);\n    }\n\n    builder.setSchema(this.schema);\n    const sql = builder.toSQL();\n\n    for (let i = 0, l = sql.length; i < l; i++) {\n      this.sequence.push(sql[i]);\n    }\n  };\n}\n\nfunction prefixedTableName(prefix, table) {\n  return prefix ? `${prefix}.${table}` : table;\n}\n\nfunction throwOnlyPGError(operationName) {\n  throw new Error(\n    `${operationName} is not supported for this dialect (only PostgreSQL supports it currently).`\n  );\n}\n\nmodule.exports = SchemaCompiler;\n"]},"metadata":{},"sourceType":"script"}