{"ast":null,"code":"// MySQL Query Compiler\n// ------\nconst identity = require('lodash/identity');\n\nconst QueryCompiler = require('../../../query/querycompiler');\n\nconst {\n  wrapAsIdentifier\n} = require('../../../formatter/formatterUtils');\n\nclass QueryCompiler_MySQL extends QueryCompiler {\n  constructor(client, builder, formatter) {\n    super(client, builder, formatter);\n    const {\n      returning\n    } = this.single;\n\n    if (returning) {\n      this.client.logger.warn('.returning() is not supported by mysql and will not have any effect.');\n    }\n\n    this._emptyInsertValue = '() values ()';\n  } // Compiles an `insert` query, allowing for multiple\n  // inserts using a single query statement.\n\n\n  insert() {\n    let sql = super.insert();\n    if (sql === '') return sql;\n    const {\n      ignore,\n      merge,\n      insert\n    } = this.single;\n    if (ignore) sql = sql.replace('insert into', 'insert ignore into');\n\n    if (merge) {\n      sql += this._merge(merge.updates, insert);\n      const wheres = this.where();\n\n      if (wheres) {\n        throw new Error('.onConflict().merge().where() is not supported for mysql');\n      }\n    }\n\n    return sql;\n  } // Compiles merge for onConflict, allowing for different merge strategies\n\n\n  _merge(updates, insert) {\n    const sql = ' on duplicate key update ';\n\n    if (updates && Array.isArray(updates)) {\n      // update subset of columns\n      return sql + updates.map(column => wrapAsIdentifier(column, this.formatter.builder, this.client)).map(column => `${column} = values(${column})`).join(', ');\n    } else if (updates && typeof updates === 'object') {\n      const updateData = this._prepUpdate(updates);\n\n      return sql + updateData.join(',');\n    } else {\n      const insertData = this._prepInsert(insert);\n\n      if (typeof insertData === 'string') {\n        throw new Error('If using merge with a raw insert query, then updates must be provided');\n      }\n\n      return sql + insertData.columns.map(column => wrapAsIdentifier(column, this.builder, this.client)).map(column => `${column} = values(${column})`).join(', ');\n    }\n  } // Update method, including joins, wheres, order & limits.\n\n\n  update() {\n    const join = this.join();\n\n    const updates = this._prepUpdate(this.single.update);\n\n    const where = this.where();\n    const order = this.order();\n    const limit = this.limit();\n    return `update ${this.tableName}` + (join ? ` ${join}` : '') + ' set ' + updates.join(', ') + (where ? ` ${where}` : '') + (order ? ` ${order}` : '') + (limit ? ` ${limit}` : '');\n  }\n\n  forUpdate() {\n    return 'for update';\n  }\n\n  forShare() {\n    return 'lock in share mode';\n  } // Only supported on MySQL 8.0+\n\n\n  skipLocked() {\n    return 'skip locked';\n  } // Supported on MySQL 8.0+ and MariaDB 10.3.0+\n\n\n  noWait() {\n    return 'nowait';\n  } // Compiles a `columnInfo` query.\n\n\n  columnInfo() {\n    const column = this.single.columnInfo; // The user may have specified a custom wrapIdentifier function in the config. We\n    // need to run the identifiers through that function, but not format them as\n    // identifiers otherwise.\n\n    const table = this.client.customWrapIdentifier(this.single.table, identity);\n    return {\n      sql: 'select * from information_schema.columns where table_name = ? and table_schema = ?',\n      bindings: [table, this.client.database()],\n\n      output(resp) {\n        const out = resp.reduce(function (columns, val) {\n          columns[val.COLUMN_NAME] = {\n            defaultValue: val.COLUMN_DEFAULT,\n            type: val.DATA_TYPE,\n            maxLength: val.CHARACTER_MAXIMUM_LENGTH,\n            nullable: val.IS_NULLABLE === 'YES'\n          };\n          return columns;\n        }, {});\n        return column && out[column] || out;\n      }\n\n    };\n  }\n\n  limit() {\n    const noLimit = !this.single.limit && this.single.limit !== 0;\n    if (noLimit && !this.single.offset) return ''; // Workaround for offset only.\n    // see: http://stackoverflow.com/questions/255517/mysql-offset-infinite-rows\n\n    const limit = this.single.offset && noLimit ? '18446744073709551615' : this.client.parameter(this.single.limit, this.builder, this.bindingsHolder);\n    return `limit ${limit}`;\n  }\n\n} // Set the QueryBuilder & QueryCompiler on the client object,\n// in case anyone wants to modify things to suit their own purposes.\n\n\nmodule.exports = QueryCompiler_MySQL;","map":{"version":3,"sources":["/home/rosiane/back/node_modules/knex/lib/dialects/mysql/query/mysql-querycompiler.js"],"names":["identity","require","QueryCompiler","wrapAsIdentifier","QueryCompiler_MySQL","constructor","client","builder","formatter","returning","single","logger","warn","_emptyInsertValue","insert","sql","ignore","merge","replace","_merge","updates","wheres","where","Error","Array","isArray","map","column","join","updateData","_prepUpdate","insertData","_prepInsert","columns","update","order","limit","tableName","forUpdate","forShare","skipLocked","noWait","columnInfo","table","customWrapIdentifier","bindings","database","output","resp","out","reduce","val","COLUMN_NAME","defaultValue","COLUMN_DEFAULT","type","DATA_TYPE","maxLength","CHARACTER_MAXIMUM_LENGTH","nullable","IS_NULLABLE","noLimit","offset","parameter","bindingsHolder","module","exports"],"mappings":"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","sourcesContent":["// MySQL Query Compiler\n// ------\nconst identity = require('lodash/identity');\nconst QueryCompiler = require('../../../query/querycompiler');\nconst { wrapAsIdentifier } = require('../../../formatter/formatterUtils');\n\nclass QueryCompiler_MySQL extends QueryCompiler {\n  constructor(client, builder, formatter) {\n    super(client, builder, formatter);\n\n    const { returning } = this.single;\n    if (returning) {\n      this.client.logger.warn(\n        '.returning() is not supported by mysql and will not have any effect.'\n      );\n    }\n\n    this._emptyInsertValue = '() values ()';\n  }\n\n  // Compiles an `insert` query, allowing for multiple\n  // inserts using a single query statement.\n  insert() {\n    let sql = super.insert();\n    if (sql === '') return sql;\n\n    const { ignore, merge, insert } = this.single;\n    if (ignore) sql = sql.replace('insert into', 'insert ignore into');\n    if (merge) {\n      sql += this._merge(merge.updates, insert);\n      const wheres = this.where();\n      if (wheres) {\n        throw new Error(\n          '.onConflict().merge().where() is not supported for mysql'\n        );\n      }\n    }\n\n    return sql;\n  }\n\n  // Compiles merge for onConflict, allowing for different merge strategies\n  _merge(updates, insert) {\n    const sql = ' on duplicate key update ';\n    if (updates && Array.isArray(updates)) {\n      // update subset of columns\n      return (\n        sql +\n        updates\n          .map((column) =>\n            wrapAsIdentifier(column, this.formatter.builder, this.client)\n          )\n          .map((column) => `${column} = values(${column})`)\n          .join(', ')\n      );\n    } else if (updates && typeof updates === 'object') {\n      const updateData = this._prepUpdate(updates);\n      return sql + updateData.join(',');\n    } else {\n      const insertData = this._prepInsert(insert);\n      if (typeof insertData === 'string') {\n        throw new Error(\n          'If using merge with a raw insert query, then updates must be provided'\n        );\n      }\n\n      return (\n        sql +\n        insertData.columns\n          .map((column) => wrapAsIdentifier(column, this.builder, this.client))\n          .map((column) => `${column} = values(${column})`)\n          .join(', ')\n      );\n    }\n  }\n\n  // Update method, including joins, wheres, order & limits.\n  update() {\n    const join = this.join();\n    const updates = this._prepUpdate(this.single.update);\n    const where = this.where();\n    const order = this.order();\n    const limit = this.limit();\n    return (\n      `update ${this.tableName}` +\n      (join ? ` ${join}` : '') +\n      ' set ' +\n      updates.join(', ') +\n      (where ? ` ${where}` : '') +\n      (order ? ` ${order}` : '') +\n      (limit ? ` ${limit}` : '')\n    );\n  }\n\n  forUpdate() {\n    return 'for update';\n  }\n\n  forShare() {\n    return 'lock in share mode';\n  }\n\n  // Only supported on MySQL 8.0+\n  skipLocked() {\n    return 'skip locked';\n  }\n\n  // Supported on MySQL 8.0+ and MariaDB 10.3.0+\n  noWait() {\n    return 'nowait';\n  }\n\n  // Compiles a `columnInfo` query.\n  columnInfo() {\n    const column = this.single.columnInfo;\n\n    // The user may have specified a custom wrapIdentifier function in the config. We\n    // need to run the identifiers through that function, but not format them as\n    // identifiers otherwise.\n    const table = this.client.customWrapIdentifier(this.single.table, identity);\n\n    return {\n      sql:\n        'select * from information_schema.columns where table_name = ? and table_schema = ?',\n      bindings: [table, this.client.database()],\n      output(resp) {\n        const out = resp.reduce(function (columns, val) {\n          columns[val.COLUMN_NAME] = {\n            defaultValue: val.COLUMN_DEFAULT,\n            type: val.DATA_TYPE,\n            maxLength: val.CHARACTER_MAXIMUM_LENGTH,\n            nullable: val.IS_NULLABLE === 'YES',\n          };\n          return columns;\n        }, {});\n        return (column && out[column]) || out;\n      },\n    };\n  }\n\n  limit() {\n    const noLimit = !this.single.limit && this.single.limit !== 0;\n    if (noLimit && !this.single.offset) return '';\n\n    // Workaround for offset only.\n    // see: http://stackoverflow.com/questions/255517/mysql-offset-infinite-rows\n    const limit =\n      this.single.offset && noLimit\n        ? '18446744073709551615'\n        : this.client.parameter(\n            this.single.limit,\n            this.builder,\n            this.bindingsHolder\n          );\n    return `limit ${limit}`;\n  }\n}\n\n// Set the QueryBuilder & QueryCompiler on the client object,\n// in case anyone wants to modify things to suit their own purposes.\nmodule.exports = QueryCompiler_MySQL;\n"]},"metadata":{},"sourceType":"script"}