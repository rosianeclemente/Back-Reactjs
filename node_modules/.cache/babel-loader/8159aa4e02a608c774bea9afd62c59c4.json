{"ast":null,"code":"const transform = require('lodash/transform');\n\nconst QueryBuilder = require('../query/querybuilder');\n\nconst {\n  compileCallback,\n  wrapAsIdentifier\n} = require('./formatterUtils'); // Valid values for the `order by` clause generation.\n\n\nconst orderBys = ['asc', 'desc']; // Turn this into a lookup map\n\nconst operators = transform(['=', '<', '>', '<=', '>=', '<>', '!=', 'like', 'not like', 'between', 'not between', 'ilike', 'not ilike', 'exists', 'not exist', 'rlike', 'not rlike', 'regexp', 'not regexp', 'match', '&', '|', '^', '<<', '>>', '~', '~=', '~*', '!~', '!~*', '#', '&&', '@>', '<@', '||', '&<', '&>', '-|-', '@@', '!!', ['?', '\\\\?'], ['?|', '\\\\?|'], ['?&', '\\\\?&']], (result, key) => {\n  if (Array.isArray(key)) {\n    result[key[0]] = key[1];\n  } else {\n    result[key] = key;\n  }\n}, {}); // Accepts a string or array of columns to wrap as appropriate. Column can be raw\n\nfunction columnize(target, builder, client, bindingHolder) {\n  const columns = Array.isArray(target) ? target : [target];\n  let str = '',\n      i = -1;\n\n  while (++i < columns.length) {\n    if (i > 0) str += ', ';\n    str += wrap(columns[i], undefined, builder, client, bindingHolder);\n  }\n\n  return str;\n} // Puts the appropriate wrapper around a value depending on the database\n// engine, unless it's a knex.raw value, in which case it's left alone.\n\n\nfunction wrap(value, isParameter, builder, client, bindingHolder) {\n  const raw = unwrapRaw(value, isParameter, builder, client, bindingHolder);\n  if (raw) return raw;\n\n  switch (typeof value) {\n    case 'function':\n      return outputQuery(compileCallback(value, undefined, client, bindingHolder), true, builder, client);\n\n    case 'object':\n      return parseObject(value, builder, client, bindingHolder);\n\n    case 'number':\n      return value;\n\n    default:\n      return wrapString(value + '', builder, client);\n  }\n}\n\nfunction unwrapRaw(value, isParameter, builder, client, bindingsHolder) {\n  let query;\n\n  if (value instanceof QueryBuilder) {\n    query = client.queryCompiler(value).toSQL();\n\n    if (query.bindings) {\n      bindingsHolder.bindings.push(...query.bindings);\n    }\n\n    return outputQuery(query, isParameter, builder, client);\n  }\n\n  if (value && value.isRawInstance) {\n    value.client = client;\n\n    if (builder._queryContext) {\n      value.queryContext = () => {\n        return builder._queryContext;\n      };\n    }\n\n    query = value.toSQL();\n\n    if (query.bindings) {\n      bindingsHolder.bindings.push(...query.bindings);\n    }\n\n    return query.sql;\n  }\n\n  if (isParameter) {\n    bindingsHolder.bindings.push(value);\n  }\n}\n\nfunction operator(value, builder, client, bindingsHolder) {\n  const raw = unwrapRaw(value, undefined, builder, client, bindingsHolder);\n  if (raw) return raw;\n  const operator = operators[(value || '').toLowerCase()];\n\n  if (!operator) {\n    throw new TypeError(`The operator \"${value}\" is not permitted`);\n  }\n\n  return operator;\n} // Coerce to string to prevent strange errors when it's not a string.\n\n\nfunction wrapString(value, builder, client) {\n  const asIndex = value.toLowerCase().indexOf(' as ');\n\n  if (asIndex !== -1) {\n    const first = value.slice(0, asIndex);\n    const second = value.slice(asIndex + 4);\n    return client.alias(wrapString(first, builder, client), wrapAsIdentifier(second, builder, client));\n  }\n\n  const wrapped = [];\n  let i = -1;\n  const segments = value.split('.');\n\n  while (++i < segments.length) {\n    value = segments[i];\n\n    if (i === 0 && segments.length > 1) {\n      wrapped.push(wrapString((value || '').trim(), builder, client));\n    } else {\n      wrapped.push(wrapAsIdentifier(value, builder, client));\n    }\n  }\n\n  return wrapped.join('.');\n} // Key-value notation for alias\n\n\nfunction parseObject(obj, builder, client, formatter) {\n  const ret = [];\n\n  for (const alias in obj) {\n    const queryOrIdentifier = obj[alias]; // Avoids double aliasing for subqueries\n\n    if (typeof queryOrIdentifier === 'function') {\n      const compiled = compileCallback(queryOrIdentifier, undefined, client, formatter);\n      compiled.as = alias; // enforces the object's alias\n\n      ret.push(outputQuery(compiled, true, builder, client));\n    } else if (queryOrIdentifier instanceof QueryBuilder) {\n      ret.push(client.alias(`(${wrap(queryOrIdentifier, undefined, builder, client, formatter)})`, wrapAsIdentifier(alias, builder, client)));\n    } else {\n      ret.push(client.alias(wrap(queryOrIdentifier, undefined, builder, client, formatter), wrapAsIdentifier(alias, builder, client)));\n    }\n  }\n\n  return ret.join(', ');\n} // Ensures the query is aliased if necessary.\n\n\nfunction outputQuery(compiled, isParameter, builder, client) {\n  let sql = compiled.sql || '';\n\n  if (sql) {\n    if ((compiled.method === 'select' || compiled.method === 'first') && (isParameter || compiled.as)) {\n      sql = `(${sql})`;\n      if (compiled.as) return client.alias(sql, wrapString(compiled.as, builder, client));\n    }\n  }\n\n  return sql;\n}\n/**\n * Creates SQL for a parameter, which might be passed to where() or .with() or\n * pretty much anywhere in API.\n *\n * @param value\n * @param method Optional at least 'select' or 'update' are valid\n * @param builder\n * @param client\n * @param bindingHolder\n */\n\n\nfunction rawOrFn(value, method, builder, client, bindingHolder) {\n  if (typeof value === 'function') {\n    return outputQuery(compileCallback(value, method, client, bindingHolder), undefined, builder, client, bindingHolder);\n  }\n\n  return unwrapRaw(value, undefined, builder, client, bindingHolder) || '';\n} // Specify the direction of the ordering.\n\n\nfunction direction(value, builder, client, bindingsHolder) {\n  const raw = unwrapRaw(value, undefined, builder, client, bindingsHolder);\n  if (raw) return raw;\n  return orderBys.indexOf((value || '').toLowerCase()) !== -1 ? value : 'asc';\n}\n\nmodule.exports = {\n  columnize,\n  direction,\n  operator,\n  outputQuery,\n  rawOrFn,\n  unwrapRaw,\n  wrap,\n  wrapString\n};","map":{"version":3,"sources":["/home/rosiane/back/node_modules/knex/lib/formatter/wrappingFormatter.js"],"names":["transform","require","QueryBuilder","compileCallback","wrapAsIdentifier","orderBys","operators","result","key","Array","isArray","columnize","target","builder","client","bindingHolder","columns","str","i","length","wrap","undefined","value","isParameter","raw","unwrapRaw","outputQuery","parseObject","wrapString","bindingsHolder","query","queryCompiler","toSQL","bindings","push","isRawInstance","_queryContext","queryContext","sql","operator","toLowerCase","TypeError","asIndex","indexOf","first","slice","second","alias","wrapped","segments","split","trim","join","obj","formatter","ret","queryOrIdentifier","compiled","as","method","rawOrFn","direction","module","exports"],"mappings":"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","sourcesContent":["const transform = require('lodash/transform');\nconst QueryBuilder = require('../query/querybuilder');\nconst { compileCallback, wrapAsIdentifier } = require('./formatterUtils');\n\n// Valid values for the `order by` clause generation.\nconst orderBys = ['asc', 'desc'];\n\n// Turn this into a lookup map\nconst operators = transform(\n  [\n    '=',\n    '<',\n    '>',\n    '<=',\n    '>=',\n    '<>',\n    '!=',\n    'like',\n    'not like',\n    'between',\n    'not between',\n    'ilike',\n    'not ilike',\n    'exists',\n    'not exist',\n    'rlike',\n    'not rlike',\n    'regexp',\n    'not regexp',\n    'match',\n    '&',\n    '|',\n    '^',\n    '<<',\n    '>>',\n    '~',\n    '~=',\n    '~*',\n    '!~',\n    '!~*',\n    '#',\n    '&&',\n    '@>',\n    '<@',\n    '||',\n    '&<',\n    '&>',\n    '-|-',\n    '@@',\n    '!!',\n    ['?', '\\\\?'],\n    ['?|', '\\\\?|'],\n    ['?&', '\\\\?&'],\n  ],\n  (result, key) => {\n    if (Array.isArray(key)) {\n      result[key[0]] = key[1];\n    } else {\n      result[key] = key;\n    }\n  },\n  {}\n);\n\n// Accepts a string or array of columns to wrap as appropriate. Column can be raw\nfunction columnize(target, builder, client, bindingHolder) {\n  const columns = Array.isArray(target) ? target : [target];\n  let str = '',\n    i = -1;\n  while (++i < columns.length) {\n    if (i > 0) str += ', ';\n    str += wrap(columns[i], undefined, builder, client, bindingHolder);\n  }\n  return str;\n}\n\n// Puts the appropriate wrapper around a value depending on the database\n// engine, unless it's a knex.raw value, in which case it's left alone.\nfunction wrap(value, isParameter, builder, client, bindingHolder) {\n  const raw = unwrapRaw(value, isParameter, builder, client, bindingHolder);\n  if (raw) return raw;\n  switch (typeof value) {\n    case 'function':\n      return outputQuery(\n        compileCallback(value, undefined, client, bindingHolder),\n        true,\n        builder,\n        client\n      );\n    case 'object':\n      return parseObject(value, builder, client, bindingHolder);\n    case 'number':\n      return value;\n    default:\n      return wrapString(value + '', builder, client);\n  }\n}\n\nfunction unwrapRaw(value, isParameter, builder, client, bindingsHolder) {\n  let query;\n  if (value instanceof QueryBuilder) {\n    query = client.queryCompiler(value).toSQL();\n    if (query.bindings) {\n      bindingsHolder.bindings.push(...query.bindings);\n    }\n    return outputQuery(query, isParameter, builder, client);\n  }\n  if (value && value.isRawInstance) {\n    value.client = client;\n    if (builder._queryContext) {\n      value.queryContext = () => {\n        return builder._queryContext;\n      };\n    }\n\n    query = value.toSQL();\n    if (query.bindings) {\n      bindingsHolder.bindings.push(...query.bindings);\n    }\n    return query.sql;\n  }\n  if (isParameter) {\n    bindingsHolder.bindings.push(value);\n  }\n}\n\nfunction operator(value, builder, client, bindingsHolder) {\n  const raw = unwrapRaw(value, undefined, builder, client, bindingsHolder);\n  if (raw) return raw;\n  const operator = operators[(value || '').toLowerCase()];\n  if (!operator) {\n    throw new TypeError(`The operator \"${value}\" is not permitted`);\n  }\n  return operator;\n}\n\n// Coerce to string to prevent strange errors when it's not a string.\nfunction wrapString(value, builder, client) {\n  const asIndex = value.toLowerCase().indexOf(' as ');\n  if (asIndex !== -1) {\n    const first = value.slice(0, asIndex);\n    const second = value.slice(asIndex + 4);\n    return client.alias(\n      wrapString(first, builder, client),\n      wrapAsIdentifier(second, builder, client)\n    );\n  }\n  const wrapped = [];\n  let i = -1;\n  const segments = value.split('.');\n  while (++i < segments.length) {\n    value = segments[i];\n    if (i === 0 && segments.length > 1) {\n      wrapped.push(wrapString((value || '').trim(), builder, client));\n    } else {\n      wrapped.push(wrapAsIdentifier(value, builder, client));\n    }\n  }\n  return wrapped.join('.');\n}\n\n// Key-value notation for alias\nfunction parseObject(obj, builder, client, formatter) {\n  const ret = [];\n  for (const alias in obj) {\n    const queryOrIdentifier = obj[alias];\n    // Avoids double aliasing for subqueries\n    if (typeof queryOrIdentifier === 'function') {\n      const compiled = compileCallback(\n        queryOrIdentifier,\n        undefined,\n        client,\n        formatter\n      );\n      compiled.as = alias; // enforces the object's alias\n      ret.push(outputQuery(compiled, true, builder, client));\n    } else if (queryOrIdentifier instanceof QueryBuilder) {\n      ret.push(\n        client.alias(\n          `(${wrap(queryOrIdentifier, undefined, builder, client, formatter)})`,\n          wrapAsIdentifier(alias, builder, client)\n        )\n      );\n    } else {\n      ret.push(\n        client.alias(\n          wrap(queryOrIdentifier, undefined, builder, client, formatter),\n          wrapAsIdentifier(alias, builder, client)\n        )\n      );\n    }\n  }\n  return ret.join(', ');\n}\n\n// Ensures the query is aliased if necessary.\nfunction outputQuery(compiled, isParameter, builder, client) {\n  let sql = compiled.sql || '';\n  if (sql) {\n    if (\n      (compiled.method === 'select' || compiled.method === 'first') &&\n      (isParameter || compiled.as)\n    ) {\n      sql = `(${sql})`;\n      if (compiled.as)\n        return client.alias(sql, wrapString(compiled.as, builder, client));\n    }\n  }\n  return sql;\n}\n\n/**\n * Creates SQL for a parameter, which might be passed to where() or .with() or\n * pretty much anywhere in API.\n *\n * @param value\n * @param method Optional at least 'select' or 'update' are valid\n * @param builder\n * @param client\n * @param bindingHolder\n */\nfunction rawOrFn(value, method, builder, client, bindingHolder) {\n  if (typeof value === 'function') {\n    return outputQuery(\n      compileCallback(value, method, client, bindingHolder),\n      undefined,\n      builder,\n      client,\n      bindingHolder\n    );\n  }\n  return unwrapRaw(value, undefined, builder, client, bindingHolder) || '';\n}\n\n// Specify the direction of the ordering.\nfunction direction(value, builder, client, bindingsHolder) {\n  const raw = unwrapRaw(value, undefined, builder, client, bindingsHolder);\n  if (raw) return raw;\n  return orderBys.indexOf((value || '').toLowerCase()) !== -1 ? value : 'asc';\n}\n\nmodule.exports = {\n  columnize,\n  direction,\n  operator,\n  outputQuery,\n  rawOrFn,\n  unwrapRaw,\n  wrap,\n  wrapString,\n};\n"]},"metadata":{},"sourceType":"script"}