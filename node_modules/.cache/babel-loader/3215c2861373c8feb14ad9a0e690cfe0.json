{"ast":null,"code":"/* eslint max-len: 0 */\n// PostgreSQL Table Builder & Compiler\n// -------\nconst has = require('lodash/has');\n\nconst TableCompiler = require('../../../schema/tablecompiler');\n\nclass TableCompiler_PG extends TableCompiler {\n  constructor(client, tableBuilder) {\n    super(client, tableBuilder);\n  } // Compile a rename column command.\n\n\n  renameColumn(from, to) {\n    return this.pushQuery({\n      sql: `alter table ${this.tableName()} rename ${this.formatter.wrap(from)} to ${this.formatter.wrap(to)}`\n    });\n  }\n\n  compileAdd(builder) {\n    const table = this.formatter.wrap(builder);\n    const columns = this.prefixArray('add column', this.getColumns(builder));\n    return this.pushQuery({\n      sql: `alter table ${table} ${columns.join(', ')}`\n    });\n  } // Adds the \"create\" query to the query sequence.\n\n\n  createQuery(columns, ifNot) {\n    const createStatement = ifNot ? 'create table if not exists ' : 'create table ';\n    let sql = createStatement + this.tableName() + ' (' + columns.sql.join(', ') + ')';\n    if (this.single.inherits) sql += ` inherits (${this.formatter.wrap(this.single.inherits)})`;\n    this.pushQuery({\n      sql,\n      bindings: columns.bindings\n    });\n    const hasComment = has(this.single, 'comment');\n    if (hasComment) this.comment(this.single.comment);\n  }\n\n  addColumns(columns, prefix, colCompilers) {\n    if (prefix === this.alterColumnsPrefix) {\n      // alter columns\n      for (const col of colCompilers) {\n        const quotedTableName = this.tableName();\n        const type = col.getColumnType(); // We'd prefer to call this.formatter.wrapAsIdentifier here instead, however the context passed to\n        // `this` instance is not that of the column, but of the table. Thus, we unfortunately have to call\n        // `wrapIdentifier` here as well (it is already called once on the initial column operation) to give\n        // our `alter` operation the correct `queryContext`. Refer to issue #2606 and PR #2612.\n\n        const colName = this.client.wrapIdentifier(col.getColumnName(), col.columnBuilder.queryContext()); // To alter enum columns they must be cast to text first\n\n        const isEnum = col.type === 'enu';\n        this.pushQuery({\n          sql: `alter table ${quotedTableName} alter column ${colName} drop default`,\n          bindings: []\n        });\n        this.pushQuery({\n          sql: `alter table ${quotedTableName} alter column ${colName} drop not null`,\n          bindings: []\n        });\n        this.pushQuery({\n          sql: `alter table ${quotedTableName} alter column ${colName} type ${type} using (${colName}${isEnum ? '::text::' : '::'}${type})`,\n          bindings: []\n        });\n        const defaultTo = col.modified['defaultTo'];\n\n        if (defaultTo) {\n          const modifier = col.defaultTo.apply(col, defaultTo);\n          this.pushQuery({\n            sql: `alter table ${quotedTableName} alter column ${colName} set ${modifier}`,\n            bindings: []\n          });\n        }\n\n        const nullable = col.modified['nullable'];\n\n        if (nullable && nullable[0] === false) {\n          this.pushQuery({\n            sql: `alter table ${quotedTableName} alter column ${colName} set not null`,\n            bindings: []\n          });\n        }\n      }\n    } else {\n      // base class implementation for normal add\n      super.addColumns(columns, prefix);\n    }\n  } // Compiles the comment on the table.\n\n\n  comment(comment) {\n    this.pushQuery(`comment on table ${this.tableName()} is '${this.single.comment}'`);\n  } // Indexes:\n  // -------\n\n\n  primary(columns, constraintName) {\n    constraintName = constraintName ? this.formatter.wrap(constraintName) : this.formatter.wrap(`${this.tableNameRaw}_pkey`);\n    this.pushQuery(`alter table ${this.tableName()} add constraint ${constraintName} primary key (${this.formatter.columnize(columns)})`);\n  }\n\n  unique(columns, indexName) {\n    indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('unique', this.tableNameRaw, columns);\n    this.pushQuery(`alter table ${this.tableName()} add constraint ${indexName}` + ' unique (' + this.formatter.columnize(columns) + ')');\n  }\n\n  index(columns, indexName, indexType) {\n    indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('index', this.tableNameRaw, columns);\n    this.pushQuery(`create index ${indexName} on ${this.tableName()}${indexType && ` using ${indexType}` || ''}` + ' (' + this.formatter.columnize(columns) + ')');\n  }\n\n  dropPrimary(constraintName) {\n    constraintName = constraintName ? this.formatter.wrap(constraintName) : this.formatter.wrap(this.tableNameRaw + '_pkey');\n    this.pushQuery(`alter table ${this.tableName()} drop constraint ${constraintName}`);\n  }\n\n  dropIndex(columns, indexName) {\n    indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('index', this.tableNameRaw, columns);\n    indexName = this.schemaNameRaw ? `${this.formatter.wrap(this.schemaNameRaw)}.${indexName}` : indexName;\n    this.pushQuery(`drop index ${indexName}`);\n  }\n\n  dropUnique(columns, indexName) {\n    indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('unique', this.tableNameRaw, columns);\n    this.pushQuery(`alter table ${this.tableName()} drop constraint ${indexName}`);\n  }\n\n  dropForeign(columns, indexName) {\n    indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('foreign', this.tableNameRaw, columns);\n    this.pushQuery(`alter table ${this.tableName()} drop constraint ${indexName}`);\n  }\n\n}\n\nmodule.exports = TableCompiler_PG;","map":{"version":3,"sources":["/home/rosiane/back/node_modules/knex/lib/dialects/postgres/schema/pg-tablecompiler.js"],"names":["has","require","TableCompiler","TableCompiler_PG","constructor","client","tableBuilder","renameColumn","from","to","pushQuery","sql","tableName","formatter","wrap","compileAdd","builder","table","columns","prefixArray","getColumns","join","createQuery","ifNot","createStatement","single","inherits","bindings","hasComment","comment","addColumns","prefix","colCompilers","alterColumnsPrefix","col","quotedTableName","type","getColumnType","colName","wrapIdentifier","getColumnName","columnBuilder","queryContext","isEnum","defaultTo","modified","modifier","apply","nullable","primary","constraintName","tableNameRaw","columnize","unique","indexName","_indexCommand","index","indexType","dropPrimary","dropIndex","schemaNameRaw","dropUnique","dropForeign","module","exports"],"mappings":"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","sourcesContent":["/* eslint max-len: 0 */\n\n// PostgreSQL Table Builder & Compiler\n// -------\n\nconst has = require('lodash/has');\nconst TableCompiler = require('../../../schema/tablecompiler');\n\nclass TableCompiler_PG extends TableCompiler {\n  constructor(client, tableBuilder) {\n    super(client, tableBuilder);\n  }\n\n  // Compile a rename column command.\n  renameColumn(from, to) {\n    return this.pushQuery({\n      sql: `alter table ${this.tableName()} rename ${this.formatter.wrap(\n        from\n      )} to ${this.formatter.wrap(to)}`,\n    });\n  }\n\n  compileAdd(builder) {\n    const table = this.formatter.wrap(builder);\n    const columns = this.prefixArray('add column', this.getColumns(builder));\n    return this.pushQuery({\n      sql: `alter table ${table} ${columns.join(', ')}`,\n    });\n  }\n\n  // Adds the \"create\" query to the query sequence.\n  createQuery(columns, ifNot) {\n    const createStatement = ifNot\n      ? 'create table if not exists '\n      : 'create table ';\n    let sql =\n      createStatement + this.tableName() + ' (' + columns.sql.join(', ') + ')';\n    if (this.single.inherits)\n      sql += ` inherits (${this.formatter.wrap(this.single.inherits)})`;\n    this.pushQuery({\n      sql,\n      bindings: columns.bindings,\n    });\n    const hasComment = has(this.single, 'comment');\n    if (hasComment) this.comment(this.single.comment);\n  }\n\n  addColumns(columns, prefix, colCompilers) {\n    if (prefix === this.alterColumnsPrefix) {\n      // alter columns\n      for (const col of colCompilers) {\n        const quotedTableName = this.tableName();\n        const type = col.getColumnType();\n        // We'd prefer to call this.formatter.wrapAsIdentifier here instead, however the context passed to\n        // `this` instance is not that of the column, but of the table. Thus, we unfortunately have to call\n        // `wrapIdentifier` here as well (it is already called once on the initial column operation) to give\n        // our `alter` operation the correct `queryContext`. Refer to issue #2606 and PR #2612.\n        const colName = this.client.wrapIdentifier(\n          col.getColumnName(),\n          col.columnBuilder.queryContext()\n        );\n\n        // To alter enum columns they must be cast to text first\n        const isEnum = col.type === 'enu';\n\n        this.pushQuery({\n          sql: `alter table ${quotedTableName} alter column ${colName} drop default`,\n          bindings: [],\n        });\n        this.pushQuery({\n          sql: `alter table ${quotedTableName} alter column ${colName} drop not null`,\n          bindings: [],\n        });\n        this.pushQuery({\n          sql: `alter table ${quotedTableName} alter column ${colName} type ${type} using (${colName}${\n            isEnum ? '::text::' : '::'\n          }${type})`,\n          bindings: [],\n        });\n\n        const defaultTo = col.modified['defaultTo'];\n        if (defaultTo) {\n          const modifier = col.defaultTo.apply(col, defaultTo);\n          this.pushQuery({\n            sql: `alter table ${quotedTableName} alter column ${colName} set ${modifier}`,\n            bindings: [],\n          });\n        }\n\n        const nullable = col.modified['nullable'];\n        if (nullable && nullable[0] === false) {\n          this.pushQuery({\n            sql: `alter table ${quotedTableName} alter column ${colName} set not null`,\n            bindings: [],\n          });\n        }\n      }\n    } else {\n      // base class implementation for normal add\n      super.addColumns(columns, prefix);\n    }\n  }\n\n  // Compiles the comment on the table.\n  comment(comment) {\n    this.pushQuery(\n      `comment on table ${this.tableName()} is '${this.single.comment}'`\n    );\n  }\n\n  // Indexes:\n  // -------\n\n  primary(columns, constraintName) {\n    constraintName = constraintName\n      ? this.formatter.wrap(constraintName)\n      : this.formatter.wrap(`${this.tableNameRaw}_pkey`);\n    this.pushQuery(\n      `alter table ${this.tableName()} add constraint ${constraintName} primary key (${this.formatter.columnize(\n        columns\n      )})`\n    );\n  }\n\n  unique(columns, indexName) {\n    indexName = indexName\n      ? this.formatter.wrap(indexName)\n      : this._indexCommand('unique', this.tableNameRaw, columns);\n    this.pushQuery(\n      `alter table ${this.tableName()} add constraint ${indexName}` +\n        ' unique (' +\n        this.formatter.columnize(columns) +\n        ')'\n    );\n  }\n\n  index(columns, indexName, indexType) {\n    indexName = indexName\n      ? this.formatter.wrap(indexName)\n      : this._indexCommand('index', this.tableNameRaw, columns);\n    this.pushQuery(\n      `create index ${indexName} on ${this.tableName()}${\n        (indexType && ` using ${indexType}`) || ''\n      }` +\n        ' (' +\n        this.formatter.columnize(columns) +\n        ')'\n    );\n  }\n\n  dropPrimary(constraintName) {\n    constraintName = constraintName\n      ? this.formatter.wrap(constraintName)\n      : this.formatter.wrap(this.tableNameRaw + '_pkey');\n    this.pushQuery(\n      `alter table ${this.tableName()} drop constraint ${constraintName}`\n    );\n  }\n\n  dropIndex(columns, indexName) {\n    indexName = indexName\n      ? this.formatter.wrap(indexName)\n      : this._indexCommand('index', this.tableNameRaw, columns);\n    indexName = this.schemaNameRaw\n      ? `${this.formatter.wrap(this.schemaNameRaw)}.${indexName}`\n      : indexName;\n    this.pushQuery(`drop index ${indexName}`);\n  }\n\n  dropUnique(columns, indexName) {\n    indexName = indexName\n      ? this.formatter.wrap(indexName)\n      : this._indexCommand('unique', this.tableNameRaw, columns);\n    this.pushQuery(\n      `alter table ${this.tableName()} drop constraint ${indexName}`\n    );\n  }\n\n  dropForeign(columns, indexName) {\n    indexName = indexName\n      ? this.formatter.wrap(indexName)\n      : this._indexCommand('foreign', this.tableNameRaw, columns);\n    this.pushQuery(\n      `alter table ${this.tableName()} drop constraint ${indexName}`\n    );\n  }\n}\n\nmodule.exports = TableCompiler_PG;\n"]},"metadata":{},"sourceType":"script"}