{"ast":null,"code":"// PostgreSQL\n// -------\nconst extend = require('lodash/extend');\n\nconst map = require('lodash/map');\n\nconst {\n  promisify\n} = require('util');\n\nconst Client = require('../../client');\n\nconst Transaction = require('./execution/pg-transaction');\n\nconst QueryCompiler = require('./query/pg-querycompiler');\n\nconst ColumnCompiler = require('./schema/pg-columncompiler');\n\nconst TableCompiler = require('./schema/pg-tablecompiler');\n\nconst SchemaCompiler = require('./schema/pg-compiler');\n\nconst {\n  makeEscape\n} = require('../../util/string');\n\nconst {\n  isString\n} = require('../../util/is');\n\nclass Client_PG extends Client {\n  constructor(config) {\n    super(config);\n\n    if (config.returning) {\n      this.defaultReturning = config.returning;\n    }\n\n    if (config.searchPath) {\n      this.searchPath = config.searchPath;\n    }\n  }\n\n  transaction() {\n    return new Transaction(this, ...arguments);\n  }\n\n  queryCompiler(builder, formatter) {\n    return new QueryCompiler(this, builder, formatter);\n  }\n\n  columnCompiler() {\n    return new ColumnCompiler(this, ...arguments);\n  }\n\n  schemaCompiler() {\n    return new SchemaCompiler(this, ...arguments);\n  }\n\n  tableCompiler() {\n    return new TableCompiler(this, ...arguments);\n  }\n\n  _driver() {\n    return require('pg');\n  }\n\n  wrapIdentifierImpl(value) {\n    if (value === '*') return value;\n    let arrayAccessor = '';\n    const arrayAccessorMatch = value.match(/(.*?)(\\[[0-9]+\\])/);\n\n    if (arrayAccessorMatch) {\n      value = arrayAccessorMatch[1];\n      arrayAccessor = arrayAccessorMatch[2];\n    }\n\n    return `\"${value.replace(/\"/g, '\"\"')}\"${arrayAccessor}`;\n  } // Get a raw connection, called by the `pool` whenever a new\n  // connection needs to be added to the pool.\n\n\n  acquireRawConnection() {\n    const client = this;\n    return new Promise(function (resolver, rejecter) {\n      const connection = new client.driver.Client(client.connectionSettings);\n      connection.connect(function (err, connection) {\n        if (err) {\n          return rejecter(err);\n        }\n\n        connection.on('error', err => {\n          connection.__knex__disposed = err;\n        });\n        connection.on('end', err => {\n          connection.__knex__disposed = err || 'Connection ended unexpectedly';\n        });\n\n        if (!client.version) {\n          return client.checkVersion(connection).then(function (version) {\n            client.version = version;\n            resolver(connection);\n          });\n        }\n\n        resolver(connection);\n      });\n    }).then(function setSearchPath(connection) {\n      client.setSchemaSearchPath(connection);\n      return connection;\n    });\n  } // Used to explicitly close a connection, called internally by the pool\n  // when a connection times out or the pool is shutdown.\n\n\n  async destroyRawConnection(connection) {\n    const end = promisify(cb => connection.end(cb));\n    return end();\n  } // In PostgreSQL, we need to do a version check to do some feature\n  // checking on the database.\n\n\n  checkVersion(connection) {\n    return new Promise(function (resolver, rejecter) {\n      connection.query('select version();', function (err, resp) {\n        if (err) return rejecter(err);\n        resolver(/^PostgreSQL (.*?)( |$)/.exec(resp.rows[0].version)[1]);\n      });\n    });\n  } // Position the bindings for the query. The escape sequence for question mark\n  // is \\? (e.g. knex.raw(\"\\\\?\") since javascript requires '\\' to be escaped too...)\n\n\n  positionBindings(sql) {\n    let questionCount = 0;\n    return sql.replace(/(\\\\*)(\\?)/g, function (match, escapes) {\n      if (escapes.length % 2) {\n        return '?';\n      } else {\n        questionCount++;\n        return `$${questionCount}`;\n      }\n    });\n  }\n\n  setSchemaSearchPath(connection, searchPath) {\n    let path = searchPath || this.searchPath;\n    if (!path) return Promise.resolve(true);\n\n    if (!Array.isArray(path) && !isString(path)) {\n      throw new TypeError(`knex: Expected searchPath to be Array/String, got: ${typeof path}`);\n    }\n\n    if (isString(path)) {\n      if (path.includes(',')) {\n        const parts = path.split(',');\n        const arraySyntax = `[${parts.map(searchPath => `'${searchPath}'`).join(', ')}]`;\n        this.logger.warn(`Detected comma in searchPath \"${path}\".` + `If you are trying to specify multiple schemas, use Array syntax: ${arraySyntax}`);\n      }\n\n      path = [path];\n    }\n\n    path = path.map(schemaName => `\"${schemaName}\"`).join(',');\n    return new Promise(function (resolver, rejecter) {\n      connection.query(`set search_path to ${path}`, function (err) {\n        if (err) return rejecter(err);\n        resolver(true);\n      });\n    });\n  }\n\n  _stream(connection, obj, stream, options) {\n    if (!obj.sql) throw new Error('The query is empty');\n    const PGQueryStream = process.browser ? undefined : require('pg-query-stream');\n    const sql = obj.sql;\n    return new Promise(function (resolver, rejecter) {\n      const queryStream = connection.query(new PGQueryStream(sql, obj.bindings, options));\n      queryStream.on('error', function (error) {\n        rejecter(error);\n        stream.emit('error', error);\n      }); // 'end' IS propagated by .pipe, by default\n\n      stream.on('end', resolver);\n      queryStream.pipe(stream);\n    });\n  } // Runs the query on the specified connection, providing the bindings\n  // and any other necessary prep work.\n\n\n  _query(connection, obj) {\n    if (!obj.sql) throw new Error('The query is empty');\n    let queryConfig = {\n      text: obj.sql,\n      values: obj.bindings || []\n    };\n\n    if (obj.options) {\n      queryConfig = extend(queryConfig, obj.options);\n    }\n\n    return new Promise(function (resolver, rejecter) {\n      connection.query(queryConfig, function (err, response) {\n        if (err) return rejecter(err);\n        obj.response = response;\n        resolver(obj);\n      });\n    });\n  } // Ensures the response is returned in the same format as other clients.\n\n\n  processResponse(obj, runner) {\n    const resp = obj.response;\n    if (obj.output) return obj.output.call(runner, resp);\n    if (obj.method === 'raw') return resp;\n    const {\n      returning\n    } = obj;\n\n    if (resp.command === 'SELECT') {\n      if (obj.method === 'first') return resp.rows[0];\n      if (obj.method === 'pluck') return map(resp.rows, obj.pluck);\n      return resp.rows;\n    }\n\n    if (returning) {\n      const returns = [];\n\n      for (let i = 0, l = resp.rows.length; i < l; i++) {\n        const row = resp.rows[i];\n\n        if (returning === '*' || Array.isArray(returning)) {\n          returns[i] = row;\n        } else {\n          // Pluck the only column in the row.\n          returns[i] = row[Object.keys(row)[0]];\n        }\n      }\n\n      return returns;\n    }\n\n    if (resp.command === 'UPDATE' || resp.command === 'DELETE') {\n      return resp.rowCount;\n    }\n\n    return resp;\n  }\n\n  async cancelQuery(connectionToKill) {\n    const conn = await this.acquireRawConnection();\n\n    try {\n      return await this._wrappedCancelQueryCall(conn, connectionToKill);\n    } finally {\n      await this.destroyRawConnection(conn).catch(err => {\n        this.logger.warn(`Connection Error: ${err}`);\n      });\n    }\n  }\n\n  _wrappedCancelQueryCall(conn, connectionToKill) {\n    return this._query(conn, {\n      sql: 'SELECT pg_cancel_backend($1);',\n      bindings: [connectionToKill.processID],\n      options: {}\n    });\n  }\n\n}\n\nObject.assign(Client_PG.prototype, {\n  dialect: 'postgresql',\n  driverName: 'pg',\n  canCancelQuery: true,\n  _escapeBinding: makeEscape({\n    escapeArray(val, esc) {\n      return esc(arrayString(val, esc));\n    },\n\n    escapeString(str) {\n      let hasBackslash = false;\n      let escaped = \"'\";\n\n      for (let i = 0; i < str.length; i++) {\n        const c = str[i];\n\n        if (c === \"'\") {\n          escaped += c + c;\n        } else if (c === '\\\\') {\n          escaped += c + c;\n          hasBackslash = true;\n        } else {\n          escaped += c;\n        }\n      }\n\n      escaped += \"'\";\n\n      if (hasBackslash === true) {\n        escaped = 'E' + escaped;\n      }\n\n      return escaped;\n    },\n\n    escapeObject(val, prepareValue, timezone, seen = []) {\n      if (val && typeof val.toPostgres === 'function') {\n        seen = seen || [];\n\n        if (seen.indexOf(val) !== -1) {\n          throw new Error(`circular reference detected while preparing \"${val}\" for query`);\n        }\n\n        seen.push(val);\n        return prepareValue(val.toPostgres(prepareValue), seen);\n      }\n\n      return JSON.stringify(val);\n    }\n\n  })\n});\n\nfunction arrayString(arr, esc) {\n  let result = '{';\n\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) result += ',';\n    const val = arr[i];\n\n    if (val === null || typeof val === 'undefined') {\n      result += 'NULL';\n    } else if (Array.isArray(val)) {\n      result += arrayString(val, esc);\n    } else if (typeof val === 'number') {\n      result += val;\n    } else {\n      result += JSON.stringify(typeof val === 'string' ? val : esc(val));\n    }\n  }\n\n  return result + '}';\n}\n\nmodule.exports = Client_PG;","map":{"version":3,"sources":["/home/rosiane/Projeto-completo/back/node_modules/knex/lib/dialects/postgres/index.js"],"names":["extend","require","map","promisify","Client","Transaction","QueryCompiler","ColumnCompiler","TableCompiler","SchemaCompiler","makeEscape","isString","Client_PG","constructor","config","returning","defaultReturning","searchPath","transaction","arguments","queryCompiler","builder","formatter","columnCompiler","schemaCompiler","tableCompiler","_driver","wrapIdentifierImpl","value","arrayAccessor","arrayAccessorMatch","match","replace","acquireRawConnection","client","Promise","resolver","rejecter","connection","driver","connectionSettings","connect","err","on","__knex__disposed","version","checkVersion","then","setSearchPath","setSchemaSearchPath","destroyRawConnection","end","cb","query","resp","exec","rows","positionBindings","sql","questionCount","escapes","length","path","resolve","Array","isArray","TypeError","includes","parts","split","arraySyntax","join","logger","warn","schemaName","_stream","obj","stream","options","Error","PGQueryStream","process","browser","undefined","queryStream","bindings","error","emit","pipe","_query","queryConfig","text","values","response","processResponse","runner","output","call","method","command","pluck","returns","i","l","row","Object","keys","rowCount","cancelQuery","connectionToKill","conn","_wrappedCancelQueryCall","catch","processID","assign","prototype","dialect","driverName","canCancelQuery","_escapeBinding","escapeArray","val","esc","arrayString","escapeString","str","hasBackslash","escaped","c","escapeObject","prepareValue","timezone","seen","toPostgres","indexOf","push","JSON","stringify","arr","result","module","exports"],"mappings":"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","sourcesContent":["// PostgreSQL\n// -------\nconst extend = require('lodash/extend');\nconst map = require('lodash/map');\nconst { promisify } = require('util');\nconst Client = require('../../client');\n\nconst Transaction = require('./execution/pg-transaction');\nconst QueryCompiler = require('./query/pg-querycompiler');\nconst ColumnCompiler = require('./schema/pg-columncompiler');\nconst TableCompiler = require('./schema/pg-tablecompiler');\nconst SchemaCompiler = require('./schema/pg-compiler');\nconst { makeEscape } = require('../../util/string');\nconst { isString } = require('../../util/is');\n\nclass Client_PG extends Client {\n  constructor(config) {\n    super(config);\n    if (config.returning) {\n      this.defaultReturning = config.returning;\n    }\n\n    if (config.searchPath) {\n      this.searchPath = config.searchPath;\n    }\n  }\n  transaction() {\n    return new Transaction(this, ...arguments);\n  }\n\n  queryCompiler(builder, formatter) {\n    return new QueryCompiler(this, builder, formatter);\n  }\n\n  columnCompiler() {\n    return new ColumnCompiler(this, ...arguments);\n  }\n\n  schemaCompiler() {\n    return new SchemaCompiler(this, ...arguments);\n  }\n\n  tableCompiler() {\n    return new TableCompiler(this, ...arguments);\n  }\n\n  _driver() {\n    return require('pg');\n  }\n\n  wrapIdentifierImpl(value) {\n    if (value === '*') return value;\n\n    let arrayAccessor = '';\n    const arrayAccessorMatch = value.match(/(.*?)(\\[[0-9]+\\])/);\n\n    if (arrayAccessorMatch) {\n      value = arrayAccessorMatch[1];\n      arrayAccessor = arrayAccessorMatch[2];\n    }\n\n    return `\"${value.replace(/\"/g, '\"\"')}\"${arrayAccessor}`;\n  }\n\n  // Get a raw connection, called by the `pool` whenever a new\n  // connection needs to be added to the pool.\n  acquireRawConnection() {\n    const client = this;\n    return new Promise(function (resolver, rejecter) {\n      const connection = new client.driver.Client(client.connectionSettings);\n      connection.connect(function (err, connection) {\n        if (err) {\n          return rejecter(err);\n        }\n        connection.on('error', (err) => {\n          connection.__knex__disposed = err;\n        });\n        connection.on('end', (err) => {\n          connection.__knex__disposed = err || 'Connection ended unexpectedly';\n        });\n        if (!client.version) {\n          return client.checkVersion(connection).then(function (version) {\n            client.version = version;\n            resolver(connection);\n          });\n        }\n        resolver(connection);\n      });\n    }).then(function setSearchPath(connection) {\n      client.setSchemaSearchPath(connection);\n      return connection;\n    });\n  }\n\n  // Used to explicitly close a connection, called internally by the pool\n  // when a connection times out or the pool is shutdown.\n  async destroyRawConnection(connection) {\n    const end = promisify((cb) => connection.end(cb));\n    return end();\n  }\n\n  // In PostgreSQL, we need to do a version check to do some feature\n  // checking on the database.\n  checkVersion(connection) {\n    return new Promise(function (resolver, rejecter) {\n      connection.query('select version();', function (err, resp) {\n        if (err) return rejecter(err);\n        resolver(/^PostgreSQL (.*?)( |$)/.exec(resp.rows[0].version)[1]);\n      });\n    });\n  }\n\n  // Position the bindings for the query. The escape sequence for question mark\n  // is \\? (e.g. knex.raw(\"\\\\?\") since javascript requires '\\' to be escaped too...)\n  positionBindings(sql) {\n    let questionCount = 0;\n    return sql.replace(/(\\\\*)(\\?)/g, function (match, escapes) {\n      if (escapes.length % 2) {\n        return '?';\n      } else {\n        questionCount++;\n        return `$${questionCount}`;\n      }\n    });\n  }\n\n  setSchemaSearchPath(connection, searchPath) {\n    let path = searchPath || this.searchPath;\n\n    if (!path) return Promise.resolve(true);\n\n    if (!Array.isArray(path) && !isString(path)) {\n      throw new TypeError(\n        `knex: Expected searchPath to be Array/String, got: ${typeof path}`\n      );\n    }\n\n    if (isString(path)) {\n      if (path.includes(',')) {\n        const parts = path.split(',');\n        const arraySyntax = `[${parts\n          .map((searchPath) => `'${searchPath}'`)\n          .join(', ')}]`;\n        this.logger.warn(\n          `Detected comma in searchPath \"${path}\".` +\n            `If you are trying to specify multiple schemas, use Array syntax: ${arraySyntax}`\n        );\n      }\n      path = [path];\n    }\n\n    path = path.map((schemaName) => `\"${schemaName}\"`).join(',');\n\n    return new Promise(function (resolver, rejecter) {\n      connection.query(`set search_path to ${path}`, function (err) {\n        if (err) return rejecter(err);\n        resolver(true);\n      });\n    });\n  }\n\n  _stream(connection, obj, stream, options) {\n    if (!obj.sql) throw new Error('The query is empty');\n\n    const PGQueryStream = process.browser\n      ? undefined\n      : require('pg-query-stream');\n    const sql = obj.sql;\n\n    return new Promise(function (resolver, rejecter) {\n      const queryStream = connection.query(\n        new PGQueryStream(sql, obj.bindings, options)\n      );\n\n      queryStream.on('error', function (error) {\n        rejecter(error);\n        stream.emit('error', error);\n      });\n\n      // 'end' IS propagated by .pipe, by default\n      stream.on('end', resolver);\n      queryStream.pipe(stream);\n    });\n  }\n\n  // Runs the query on the specified connection, providing the bindings\n  // and any other necessary prep work.\n  _query(connection, obj) {\n    if (!obj.sql) throw new Error('The query is empty');\n\n    let queryConfig = {\n      text: obj.sql,\n      values: obj.bindings || [],\n    };\n\n    if (obj.options) {\n      queryConfig = extend(queryConfig, obj.options);\n    }\n\n    return new Promise(function (resolver, rejecter) {\n      connection.query(queryConfig, function (err, response) {\n        if (err) return rejecter(err);\n        obj.response = response;\n        resolver(obj);\n      });\n    });\n  }\n\n  // Ensures the response is returned in the same format as other clients.\n  processResponse(obj, runner) {\n    const resp = obj.response;\n    if (obj.output) return obj.output.call(runner, resp);\n    if (obj.method === 'raw') return resp;\n    const { returning } = obj;\n    if (resp.command === 'SELECT') {\n      if (obj.method === 'first') return resp.rows[0];\n      if (obj.method === 'pluck') return map(resp.rows, obj.pluck);\n      return resp.rows;\n    }\n    if (returning) {\n      const returns = [];\n      for (let i = 0, l = resp.rows.length; i < l; i++) {\n        const row = resp.rows[i];\n        if (returning === '*' || Array.isArray(returning)) {\n          returns[i] = row;\n        } else {\n          // Pluck the only column in the row.\n          returns[i] = row[Object.keys(row)[0]];\n        }\n      }\n      return returns;\n    }\n    if (resp.command === 'UPDATE' || resp.command === 'DELETE') {\n      return resp.rowCount;\n    }\n    return resp;\n  }\n\n  async cancelQuery(connectionToKill) {\n    const conn = await this.acquireRawConnection();\n\n    try {\n      return await this._wrappedCancelQueryCall(conn, connectionToKill);\n    } finally {\n      await this.destroyRawConnection(conn).catch((err) => {\n        this.logger.warn(`Connection Error: ${err}`);\n      });\n    }\n  }\n  _wrappedCancelQueryCall(conn, connectionToKill) {\n    return this._query(conn, {\n      sql: 'SELECT pg_cancel_backend($1);',\n      bindings: [connectionToKill.processID],\n      options: {},\n    });\n  }\n}\n\nObject.assign(Client_PG.prototype, {\n  dialect: 'postgresql',\n\n  driverName: 'pg',\n  canCancelQuery: true,\n\n  _escapeBinding: makeEscape({\n    escapeArray(val, esc) {\n      return esc(arrayString(val, esc));\n    },\n    escapeString(str) {\n      let hasBackslash = false;\n      let escaped = \"'\";\n      for (let i = 0; i < str.length; i++) {\n        const c = str[i];\n        if (c === \"'\") {\n          escaped += c + c;\n        } else if (c === '\\\\') {\n          escaped += c + c;\n          hasBackslash = true;\n        } else {\n          escaped += c;\n        }\n      }\n      escaped += \"'\";\n      if (hasBackslash === true) {\n        escaped = 'E' + escaped;\n      }\n      return escaped;\n    },\n    escapeObject(val, prepareValue, timezone, seen = []) {\n      if (val && typeof val.toPostgres === 'function') {\n        seen = seen || [];\n        if (seen.indexOf(val) !== -1) {\n          throw new Error(\n            `circular reference detected while preparing \"${val}\" for query`\n          );\n        }\n        seen.push(val);\n        return prepareValue(val.toPostgres(prepareValue), seen);\n      }\n      return JSON.stringify(val);\n    },\n  }),\n});\n\nfunction arrayString(arr, esc) {\n  let result = '{';\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) result += ',';\n    const val = arr[i];\n    if (val === null || typeof val === 'undefined') {\n      result += 'NULL';\n    } else if (Array.isArray(val)) {\n      result += arrayString(val, esc);\n    } else if (typeof val === 'number') {\n      result += val;\n    } else {\n      result += JSON.stringify(typeof val === 'string' ? val : esc(val));\n    }\n  }\n  return result + '}';\n}\n\nmodule.exports = Client_PG;\n"]},"metadata":{},"sourceType":"script"}