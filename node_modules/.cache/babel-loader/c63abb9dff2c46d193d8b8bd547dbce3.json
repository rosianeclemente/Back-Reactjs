{"ast":null,"code":"// SQLite3: Column Builder & Compiler\n// -------\nconst SchemaCompiler = require('../../../schema/compiler');\n\nconst some = require('lodash/some'); // Schema Compiler\n// -------\n\n\nclass SchemaCompiler_SQLite3 extends SchemaCompiler {\n  constructor(client, builder) {\n    super(client, builder);\n  } // Compile the query to determine if a table exists.\n\n\n  hasTable(tableName) {\n    const sql = `select * from sqlite_master ` + `where type = 'table' and name = ${this.client.parameter(tableName, this.builder, this.bindingsHolder)}`;\n    this.pushQuery({\n      sql,\n      output: resp => resp.length > 0\n    });\n  } // Compile the query to determine if a column exists.\n\n\n  hasColumn(tableName, column) {\n    this.pushQuery({\n      sql: `PRAGMA table_info(${this.formatter.wrap(tableName)})`,\n\n      output(resp) {\n        return some(resp, col => {\n          return this.client.wrapIdentifier(col.name.toLowerCase()) === this.client.wrapIdentifier(column.toLowerCase());\n        });\n      }\n\n    });\n  } // Compile a rename table command.\n\n\n  renameTable(from, to) {\n    this.pushQuery(`alter table ${this.formatter.wrap(from)} rename to ${this.formatter.wrap(to)}`);\n  }\n\n  async generateDdlCommands() {\n    const sequence = this.builder._sequence;\n\n    for (let i = 0, l = sequence.length; i < l; i++) {\n      const query = sequence[i];\n      this[query.method].apply(this, query.args);\n    }\n\n    const result = [];\n    const commandSources = this.sequence;\n\n    for (const commandSource of commandSources) {\n      const command = commandSource.statementsProducer ? await commandSource.statementsProducer() : commandSource.sql;\n\n      if (Array.isArray(command)) {\n        result.push(...command);\n      } else {\n        result.push(command);\n      }\n    }\n\n    return {\n      pre: [],\n      sql: result,\n      post: []\n    };\n  }\n\n}\n\nmodule.exports = SchemaCompiler_SQLite3;","map":{"version":3,"sources":["/home/rosiane/Projeto-completo/back/node_modules/knex/lib/dialects/sqlite3/schema/sqlite-compiler.js"],"names":["SchemaCompiler","require","some","SchemaCompiler_SQLite3","constructor","client","builder","hasTable","tableName","sql","parameter","bindingsHolder","pushQuery","output","resp","length","hasColumn","column","formatter","wrap","col","wrapIdentifier","name","toLowerCase","renameTable","from","to","generateDdlCommands","sequence","_sequence","i","l","query","method","apply","args","result","commandSources","commandSource","command","statementsProducer","Array","isArray","push","pre","post","module","exports"],"mappings":"AAAA;AACA;AACA,MAAMA,cAAc,GAAGC,OAAO,CAAC,0BAAD,CAA9B;;AAEA,MAAMC,IAAI,GAAGD,OAAO,CAAC,aAAD,CAApB,C,CAEA;AACA;;;AAEA,MAAME,sBAAN,SAAqCH,cAArC,CAAoD;AAClDI,EAAAA,WAAW,CAACC,MAAD,EAASC,OAAT,EAAkB;AAC3B,UAAMD,MAAN,EAAcC,OAAd;AACD,GAHiD,CAKlD;;;AACAC,EAAAA,QAAQ,CAACC,SAAD,EAAY;AAClB,UAAMC,GAAG,GACN,8BAAD,GACC,mCAAkC,KAAKJ,MAAL,CAAYK,SAAZ,CACjCF,SADiC,EAEjC,KAAKF,OAF4B,EAGjC,KAAKK,cAH4B,CAIjC,EANJ;AAOA,SAAKC,SAAL,CAAe;AAAEH,MAAAA,GAAF;AAAOI,MAAAA,MAAM,EAAGC,IAAD,IAAUA,IAAI,CAACC,MAAL,GAAc;AAAvC,KAAf;AACD,GAfiD,CAiBlD;;;AACAC,EAAAA,SAAS,CAACR,SAAD,EAAYS,MAAZ,EAAoB;AAC3B,SAAKL,SAAL,CAAe;AACbH,MAAAA,GAAG,EAAG,qBAAoB,KAAKS,SAAL,CAAeC,IAAf,CAAoBX,SAApB,CAA+B,GAD5C;;AAEbK,MAAAA,MAAM,CAACC,IAAD,EAAO;AACX,eAAOZ,IAAI,CAACY,IAAD,EAAQM,GAAD,IAAS;AACzB,iBACE,KAAKf,MAAL,CAAYgB,cAAZ,CAA2BD,GAAG,CAACE,IAAJ,CAASC,WAAT,EAA3B,MACA,KAAKlB,MAAL,CAAYgB,cAAZ,CAA2BJ,MAAM,CAACM,WAAP,EAA3B,CAFF;AAID,SALU,CAAX;AAMD;;AATY,KAAf;AAWD,GA9BiD,CAgClD;;;AACAC,EAAAA,WAAW,CAACC,IAAD,EAAOC,EAAP,EAAW;AACpB,SAAKd,SAAL,CACG,eAAc,KAAKM,SAAL,CAAeC,IAAf,CAAoBM,IAApB,CAA0B,cAAa,KAAKP,SAAL,CAAeC,IAAf,CACpDO,EADoD,CAEpD,EAHJ;AAKD;;AAEwB,QAAnBC,mBAAmB,GAAG;AAC1B,UAAMC,QAAQ,GAAG,KAAKtB,OAAL,CAAauB,SAA9B;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGH,QAAQ,CAACb,MAA7B,EAAqCe,CAAC,GAAGC,CAAzC,EAA4CD,CAAC,EAA7C,EAAiD;AAC/C,YAAME,KAAK,GAAGJ,QAAQ,CAACE,CAAD,CAAtB;AACA,WAAKE,KAAK,CAACC,MAAX,EAAmBC,KAAnB,CAAyB,IAAzB,EAA+BF,KAAK,CAACG,IAArC;AACD;;AAED,UAAMC,MAAM,GAAG,EAAf;AACA,UAAMC,cAAc,GAAG,KAAKT,QAA5B;;AACA,SAAK,MAAMU,aAAX,IAA4BD,cAA5B,EAA4C;AAC1C,YAAME,OAAO,GAAGD,aAAa,CAACE,kBAAd,GACZ,MAAMF,aAAa,CAACE,kBAAd,EADM,GAEZF,aAAa,CAAC7B,GAFlB;;AAIA,UAAIgC,KAAK,CAACC,OAAN,CAAcH,OAAd,CAAJ,EAA4B;AAC1BH,QAAAA,MAAM,CAACO,IAAP,CAAY,GAAGJ,OAAf;AACD,OAFD,MAEO;AACLH,QAAAA,MAAM,CAACO,IAAP,CAAYJ,OAAZ;AACD;AACF;;AAED,WAAO;AAAEK,MAAAA,GAAG,EAAE,EAAP;AAAWnC,MAAAA,GAAG,EAAE2B,MAAhB;AAAwBS,MAAAA,IAAI,EAAE;AAA9B,KAAP;AACD;;AA/DiD;;AAkEpDC,MAAM,CAACC,OAAP,GAAiB5C,sBAAjB","sourcesContent":["// SQLite3: Column Builder & Compiler\n// -------\nconst SchemaCompiler = require('../../../schema/compiler');\n\nconst some = require('lodash/some');\n\n// Schema Compiler\n// -------\n\nclass SchemaCompiler_SQLite3 extends SchemaCompiler {\n  constructor(client, builder) {\n    super(client, builder);\n  }\n\n  // Compile the query to determine if a table exists.\n  hasTable(tableName) {\n    const sql =\n      `select * from sqlite_master ` +\n      `where type = 'table' and name = ${this.client.parameter(\n        tableName,\n        this.builder,\n        this.bindingsHolder\n      )}`;\n    this.pushQuery({ sql, output: (resp) => resp.length > 0 });\n  }\n\n  // Compile the query to determine if a column exists.\n  hasColumn(tableName, column) {\n    this.pushQuery({\n      sql: `PRAGMA table_info(${this.formatter.wrap(tableName)})`,\n      output(resp) {\n        return some(resp, (col) => {\n          return (\n            this.client.wrapIdentifier(col.name.toLowerCase()) ===\n            this.client.wrapIdentifier(column.toLowerCase())\n          );\n        });\n      },\n    });\n  }\n\n  // Compile a rename table command.\n  renameTable(from, to) {\n    this.pushQuery(\n      `alter table ${this.formatter.wrap(from)} rename to ${this.formatter.wrap(\n        to\n      )}`\n    );\n  }\n\n  async generateDdlCommands() {\n    const sequence = this.builder._sequence;\n    for (let i = 0, l = sequence.length; i < l; i++) {\n      const query = sequence[i];\n      this[query.method].apply(this, query.args);\n    }\n\n    const result = [];\n    const commandSources = this.sequence;\n    for (const commandSource of commandSources) {\n      const command = commandSource.statementsProducer\n        ? await commandSource.statementsProducer()\n        : commandSource.sql;\n\n      if (Array.isArray(command)) {\n        result.push(...command);\n      } else {\n        result.push(command);\n      }\n    }\n\n    return { pre: [], sql: result, post: [] };\n  }\n}\n\nmodule.exports = SchemaCompiler_SQLite3;\n"]},"metadata":{},"sourceType":"script"}