{"ast":null,"code":"const filter = require('lodash/filter');\n\nconst values = require('lodash/values');\n\nconst identity = require('lodash/identity');\n\nconst TableCompiler = require('../../../schema/tablecompiler');\n\nconst {\n  formatDefault\n} = require('../../../formatter/formatterUtils');\n\nclass TableCompiler_SQLite3 extends TableCompiler {\n  constructor() {\n    super(...arguments);\n  } // Create a new table.\n\n\n  createQuery(columns, ifNot) {\n    const createStatement = ifNot ? 'create table if not exists ' : 'create table ';\n    let sql = createStatement + this.tableName() + ' (' + columns.sql.join(', '); // SQLite forces primary keys to be added when the table is initially created\n    // so we will need to check for a primary key commands and add the columns\n    // to the table's declaration here so they can be created on the tables.\n\n    sql += this.foreignKeys() || '';\n    sql += this.primaryKeys() || '';\n    sql += ')';\n    this.pushQuery(sql);\n  }\n\n  addColumns(columns, prefix, colCompilers) {\n    if (prefix === this.alterColumnsPrefix) {\n      const compiler = this;\n      const columnsInfo = colCompilers.map(col => {\n        const name = this.client.customWrapIdentifier(col.getColumnName(), identity, col.columnBuilder.queryContext());\n        const type = col.getColumnType();\n        const defaultTo = col.modified['defaultTo'] ? formatDefault(col.modified['defaultTo'][0], type, this.client) : null;\n        const notNull = col.modified['nullable'] && col.modified['nullable'][0] === false;\n        return {\n          name,\n          type,\n          defaultTo,\n          notNull\n        };\n      });\n      this.pushQuery({\n        sql: `PRAGMA table_info(${this.tableName()})`,\n\n        output(pragma) {\n          return compiler.client.ddl(compiler, pragma, this.connection).alterColumn(columnsInfo);\n        }\n\n      });\n    } else {\n      for (let i = 0, l = columns.sql.length; i < l; i++) {\n        this.pushQuery({\n          sql: `alter table ${this.tableName()} add column ${columns.sql[i]}`,\n          bindings: columns.bindings[i]\n        });\n      }\n    }\n  } // Compile a drop unique key command.\n\n\n  dropUnique(columns, indexName) {\n    indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('unique', this.tableNameRaw, columns);\n    this.pushQuery(`drop index ${indexName}`);\n  } // Compile a drop foreign key command.\n\n\n  dropForeign(columns, indexName) {\n    const compiler = this;\n    this.pushQuery({\n      sql: `PRAGMA table_info(${this.tableName()})`,\n\n      output(pragma) {\n        return compiler.client.ddl(compiler, pragma, this.connection).dropForeign(columns, indexName);\n      }\n\n    });\n  } // Compile a drop primary key command.\n\n\n  dropPrimary(constraintName) {\n    const compiler = this;\n    this.pushQuery({\n      sql: `PRAGMA table_info(${this.tableName()})`,\n\n      output(pragma) {\n        return compiler.client.ddl(compiler, pragma, this.connection).dropPrimary(constraintName);\n      }\n\n    });\n  }\n\n  dropIndex(columns, indexName) {\n    indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('index', this.tableNameRaw, columns);\n    this.pushQuery(`drop index ${indexName}`);\n  } // Compile a unique key command.\n\n\n  unique(columns, indexName) {\n    indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('unique', this.tableNameRaw, columns);\n    columns = this.formatter.columnize(columns);\n    this.pushQuery(`create unique index ${indexName} on ${this.tableName()} (${columns})`);\n  } // Compile a plain index key command.\n\n\n  index(columns, indexName) {\n    indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('index', this.tableNameRaw, columns);\n    columns = this.formatter.columnize(columns);\n    this.pushQuery(`create index ${indexName} on ${this.tableName()} (${columns})`);\n  }\n  /**\n   * Add a primary key to an existing table.\n   *\n   * @NOTE The `createQuery` method above handles table creation. Don't do anything regarding table\n   *       creation in this method\n   *\n   * @param {string | string[]} columns - Column name(s) to assign as primary keys\n   * @param {string} [constraintName] - Custom name for the PK constraint\n   */\n\n\n  primary(columns, constraintName) {\n    const compiler = this;\n    columns = this.formatter.columnize(columns);\n    columns = Array.isArray(columns) ? columns : [columns];\n\n    if (this.method !== 'create' && this.method !== 'createIfNot') {\n      this.pushQuery({\n        sql: `PRAGMA table_info(${this.tableName()})`,\n\n        output(pragma) {\n          return compiler.client.ddl(compiler, pragma, this.connection).primary(columns, constraintName);\n        }\n\n      });\n    }\n  }\n  /**\n   * Add a foreign key constraint to an existing table\n   *\n   * @NOTE The `createQuery` method above handles foreign key constraints on table creation. Don't do\n   *       anything regarding table creation in this method\n   *\n   * @param {object} foreignInfo - Information about the current column foreign setup\n   * @param {string | string[]} [foreignInfo.column] - Column in the current constraint\n   * @param {string | undefined} foreignInfo.keyName - Name of the foreign key constraint\n   * @param {string} foreignInfo.references - What column it references in the other table\n   * @param {string} foreignInfo.inTable - What table is referenced in this constraint\n   * @param {string} [foreignInfo.onUpdate] - What to do on updates\n   * @param {string} [foreignInfo.onDelete] - What to do on deletions\n   */\n\n\n  foreign(foreignInfo) {\n    const compiler = this;\n\n    if (this.method !== 'create' && this.method !== 'createIfNot') {\n      foreignInfo.column = this.formatter.columnize(foreignInfo.column);\n      foreignInfo.column = Array.isArray(foreignInfo.column) ? foreignInfo.column : [foreignInfo.column];\n      foreignInfo.inTable = this.formatter.columnize(foreignInfo.inTable);\n      foreignInfo.references = this.formatter.columnize(foreignInfo.references);\n      this.pushQuery({\n        sql: `PRAGMA table_info(${this.tableName()})`,\n\n        statementsProducer(pragma, connection) {\n          return compiler.client.ddl(compiler, pragma, connection).foreign(foreignInfo);\n        }\n\n      });\n    }\n  }\n\n  primaryKeys() {\n    const pks = filter(this.grouped.alterTable || [], {\n      method: 'primary'\n    });\n\n    if (pks.length > 0 && pks[0].args.length > 0) {\n      const columns = pks[0].args[0];\n      let constraintName = pks[0].args[1] || '';\n\n      if (constraintName) {\n        constraintName = ' constraint ' + this.formatter.wrap(constraintName);\n      }\n\n      return `,${constraintName} primary key (${this.formatter.columnize(columns)})`;\n    }\n  }\n\n  foreignKeys() {\n    let sql = '';\n    const foreignKeys = filter(this.grouped.alterTable || [], {\n      method: 'foreign'\n    });\n\n    for (let i = 0, l = foreignKeys.length; i < l; i++) {\n      const foreign = foreignKeys[i].args[0];\n      const column = this.formatter.columnize(foreign.column);\n      const references = this.formatter.columnize(foreign.references);\n      const foreignTable = this.formatter.wrap(foreign.inTable);\n      let constraintName = foreign.keyName || '';\n\n      if (constraintName) {\n        constraintName = ' constraint ' + this.formatter.wrap(constraintName);\n      }\n\n      sql += `,${constraintName} foreign key(${column}) references ${foreignTable}(${references})`;\n      if (foreign.onDelete) sql += ` on delete ${foreign.onDelete}`;\n      if (foreign.onUpdate) sql += ` on update ${foreign.onUpdate}`;\n    }\n\n    return sql;\n  }\n\n  createTableBlock() {\n    return this.getColumns().concat().join(',');\n  }\n\n  renameColumn(from, to) {\n    this.pushQuery({\n      sql: `alter table ${this.tableName()} rename ${this.formatter.wrap(from)} to ${this.formatter.wrap(to)}`\n    });\n  }\n\n  dropColumn() {\n    const compiler = this;\n    const columns = values(arguments);\n    this.pushQuery({\n      sql: `PRAGMA table_info(${this.tableName()})`,\n\n      output(pragma) {\n        return compiler.client.ddl(compiler, pragma, this.connection).dropColumn(columns);\n      }\n\n    });\n  }\n\n}\n\nmodule.exports = TableCompiler_SQLite3;","map":{"version":3,"sources":["/home/rosiane/back/node_modules/knex/lib/dialects/sqlite3/schema/sqlite-tablecompiler.js"],"names":["filter","require","values","identity","TableCompiler","formatDefault","TableCompiler_SQLite3","constructor","arguments","createQuery","columns","ifNot","createStatement","sql","tableName","join","foreignKeys","primaryKeys","pushQuery","addColumns","prefix","colCompilers","alterColumnsPrefix","compiler","columnsInfo","map","col","name","client","customWrapIdentifier","getColumnName","columnBuilder","queryContext","type","getColumnType","defaultTo","modified","notNull","output","pragma","ddl","connection","alterColumn","i","l","length","bindings","dropUnique","indexName","formatter","wrap","_indexCommand","tableNameRaw","dropForeign","dropPrimary","constraintName","dropIndex","unique","columnize","index","primary","Array","isArray","method","foreign","foreignInfo","column","inTable","references","statementsProducer","pks","grouped","alterTable","args","foreignTable","keyName","onDelete","onUpdate","createTableBlock","getColumns","concat","renameColumn","from","to","dropColumn","module","exports"],"mappings":"AAAA,MAAMA,MAAM,GAAGC,OAAO,CAAC,eAAD,CAAtB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,eAAD,CAAtB;;AACA,MAAME,QAAQ,GAAGF,OAAO,CAAC,iBAAD,CAAxB;;AAEA,MAAMG,aAAa,GAAGH,OAAO,CAAC,+BAAD,CAA7B;;AACA,MAAM;AAAEI,EAAAA;AAAF,IAAoBJ,OAAO,CAAC,mCAAD,CAAjC;;AAEA,MAAMK,qBAAN,SAAoCF,aAApC,CAAkD;AAChDG,EAAAA,WAAW,GAAG;AACZ,UAAM,GAAGC,SAAT;AACD,GAH+C,CAKhD;;;AACAC,EAAAA,WAAW,CAACC,OAAD,EAAUC,KAAV,EAAiB;AAC1B,UAAMC,eAAe,GAAGD,KAAK,GACzB,6BADyB,GAEzB,eAFJ;AAGA,QAAIE,GAAG,GACLD,eAAe,GAAG,KAAKE,SAAL,EAAlB,GAAqC,IAArC,GAA4CJ,OAAO,CAACG,GAAR,CAAYE,IAAZ,CAAiB,IAAjB,CAD9C,CAJ0B,CAO1B;AACA;AACA;;AACAF,IAAAA,GAAG,IAAI,KAAKG,WAAL,MAAsB,EAA7B;AACAH,IAAAA,GAAG,IAAI,KAAKI,WAAL,MAAsB,EAA7B;AACAJ,IAAAA,GAAG,IAAI,GAAP;AAEA,SAAKK,SAAL,CAAeL,GAAf;AACD;;AAEDM,EAAAA,UAAU,CAACT,OAAD,EAAUU,MAAV,EAAkBC,YAAlB,EAAgC;AACxC,QAAID,MAAM,KAAK,KAAKE,kBAApB,EAAwC;AACtC,YAAMC,QAAQ,GAAG,IAAjB;AAEA,YAAMC,WAAW,GAAGH,YAAY,CAACI,GAAb,CAAkBC,GAAD,IAAS;AAC5C,cAAMC,IAAI,GAAG,KAAKC,MAAL,CAAYC,oBAAZ,CACXH,GAAG,CAACI,aAAJ,EADW,EAEX3B,QAFW,EAGXuB,GAAG,CAACK,aAAJ,CAAkBC,YAAlB,EAHW,CAAb;AAMA,cAAMC,IAAI,GAAGP,GAAG,CAACQ,aAAJ,EAAb;AAEA,cAAMC,SAAS,GAAGT,GAAG,CAACU,QAAJ,CAAa,WAAb,IACd/B,aAAa,CAACqB,GAAG,CAACU,QAAJ,CAAa,WAAb,EAA0B,CAA1B,CAAD,EAA+BH,IAA/B,EAAqC,KAAKL,MAA1C,CADC,GAEd,IAFJ;AAIA,cAAMS,OAAO,GACXX,GAAG,CAACU,QAAJ,CAAa,UAAb,KAA4BV,GAAG,CAACU,QAAJ,CAAa,UAAb,EAAyB,CAAzB,MAAgC,KAD9D;AAGA,eAAO;AAAET,UAAAA,IAAF;AAAQM,UAAAA,IAAR;AAAcE,UAAAA,SAAd;AAAyBE,UAAAA;AAAzB,SAAP;AACD,OAjBmB,CAApB;AAmBA,WAAKnB,SAAL,CAAe;AACbL,QAAAA,GAAG,EAAG,qBAAoB,KAAKC,SAAL,EAAiB,GAD9B;;AAEbwB,QAAAA,MAAM,CAACC,MAAD,EAAS;AACb,iBAAOhB,QAAQ,CAACK,MAAT,CACJY,GADI,CACAjB,QADA,EACUgB,MADV,EACkB,KAAKE,UADvB,EAEJC,WAFI,CAEQlB,WAFR,CAAP;AAGD;;AANY,OAAf;AAQD,KA9BD,MA8BO;AACL,WAAK,IAAImB,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGlC,OAAO,CAACG,GAAR,CAAYgC,MAAhC,EAAwCF,CAAC,GAAGC,CAA5C,EAA+CD,CAAC,EAAhD,EAAoD;AAClD,aAAKzB,SAAL,CAAe;AACbL,UAAAA,GAAG,EAAG,eAAc,KAAKC,SAAL,EAAiB,eAAcJ,OAAO,CAACG,GAAR,CAAY8B,CAAZ,CAAe,EADrD;AAEbG,UAAAA,QAAQ,EAAEpC,OAAO,CAACoC,QAAR,CAAiBH,CAAjB;AAFG,SAAf;AAID;AACF;AACF,GA9D+C,CAgEhD;;;AACAI,EAAAA,UAAU,CAACrC,OAAD,EAAUsC,SAAV,EAAqB;AAC7BA,IAAAA,SAAS,GAAGA,SAAS,GACjB,KAAKC,SAAL,CAAeC,IAAf,CAAoBF,SAApB,CADiB,GAEjB,KAAKG,aAAL,CAAmB,QAAnB,EAA6B,KAAKC,YAAlC,EAAgD1C,OAAhD,CAFJ;AAGA,SAAKQ,SAAL,CAAgB,cAAa8B,SAAU,EAAvC;AACD,GAtE+C,CAwEhD;;;AACAK,EAAAA,WAAW,CAAC3C,OAAD,EAAUsC,SAAV,EAAqB;AAC9B,UAAMzB,QAAQ,GAAG,IAAjB;AAEA,SAAKL,SAAL,CAAe;AACbL,MAAAA,GAAG,EAAG,qBAAoB,KAAKC,SAAL,EAAiB,GAD9B;;AAEbwB,MAAAA,MAAM,CAACC,MAAD,EAAS;AACb,eAAOhB,QAAQ,CAACK,MAAT,CACJY,GADI,CACAjB,QADA,EACUgB,MADV,EACkB,KAAKE,UADvB,EAEJY,WAFI,CAEQ3C,OAFR,EAEiBsC,SAFjB,CAAP;AAGD;;AANY,KAAf;AAQD,GApF+C,CAsFhD;;;AACAM,EAAAA,WAAW,CAACC,cAAD,EAAiB;AAC1B,UAAMhC,QAAQ,GAAG,IAAjB;AAEA,SAAKL,SAAL,CAAe;AACbL,MAAAA,GAAG,EAAG,qBAAoB,KAAKC,SAAL,EAAiB,GAD9B;;AAEbwB,MAAAA,MAAM,CAACC,MAAD,EAAS;AACb,eAAOhB,QAAQ,CAACK,MAAT,CACJY,GADI,CACAjB,QADA,EACUgB,MADV,EACkB,KAAKE,UADvB,EAEJa,WAFI,CAEQC,cAFR,CAAP;AAGD;;AANY,KAAf;AAQD;;AAEDC,EAAAA,SAAS,CAAC9C,OAAD,EAAUsC,SAAV,EAAqB;AAC5BA,IAAAA,SAAS,GAAGA,SAAS,GACjB,KAAKC,SAAL,CAAeC,IAAf,CAAoBF,SAApB,CADiB,GAEjB,KAAKG,aAAL,CAAmB,OAAnB,EAA4B,KAAKC,YAAjC,EAA+C1C,OAA/C,CAFJ;AAGA,SAAKQ,SAAL,CAAgB,cAAa8B,SAAU,EAAvC;AACD,GAzG+C,CA2GhD;;;AACAS,EAAAA,MAAM,CAAC/C,OAAD,EAAUsC,SAAV,EAAqB;AACzBA,IAAAA,SAAS,GAAGA,SAAS,GACjB,KAAKC,SAAL,CAAeC,IAAf,CAAoBF,SAApB,CADiB,GAEjB,KAAKG,aAAL,CAAmB,QAAnB,EAA6B,KAAKC,YAAlC,EAAgD1C,OAAhD,CAFJ;AAGAA,IAAAA,OAAO,GAAG,KAAKuC,SAAL,CAAeS,SAAf,CAAyBhD,OAAzB,CAAV;AACA,SAAKQ,SAAL,CACG,uBAAsB8B,SAAU,OAAM,KAAKlC,SAAL,EAAiB,KAAIJ,OAAQ,GADtE;AAGD,GApH+C,CAsHhD;;;AACAiD,EAAAA,KAAK,CAACjD,OAAD,EAAUsC,SAAV,EAAqB;AACxBA,IAAAA,SAAS,GAAGA,SAAS,GACjB,KAAKC,SAAL,CAAeC,IAAf,CAAoBF,SAApB,CADiB,GAEjB,KAAKG,aAAL,CAAmB,OAAnB,EAA4B,KAAKC,YAAjC,EAA+C1C,OAA/C,CAFJ;AAGAA,IAAAA,OAAO,GAAG,KAAKuC,SAAL,CAAeS,SAAf,CAAyBhD,OAAzB,CAAV;AACA,SAAKQ,SAAL,CACG,gBAAe8B,SAAU,OAAM,KAAKlC,SAAL,EAAiB,KAAIJ,OAAQ,GAD/D;AAGD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEkD,EAAAA,OAAO,CAAClD,OAAD,EAAU6C,cAAV,EAA0B;AAC/B,UAAMhC,QAAQ,GAAG,IAAjB;AAEAb,IAAAA,OAAO,GAAG,KAAKuC,SAAL,CAAeS,SAAf,CAAyBhD,OAAzB,CAAV;AACAA,IAAAA,OAAO,GAAGmD,KAAK,CAACC,OAAN,CAAcpD,OAAd,IAAyBA,OAAzB,GAAmC,CAACA,OAAD,CAA7C;;AAEA,QAAI,KAAKqD,MAAL,KAAgB,QAAhB,IAA4B,KAAKA,MAAL,KAAgB,aAAhD,EAA+D;AAC7D,WAAK7C,SAAL,CAAe;AACbL,QAAAA,GAAG,EAAG,qBAAoB,KAAKC,SAAL,EAAiB,GAD9B;;AAEbwB,QAAAA,MAAM,CAACC,MAAD,EAAS;AACb,iBAAOhB,QAAQ,CAACK,MAAT,CACJY,GADI,CACAjB,QADA,EACUgB,MADV,EACkB,KAAKE,UADvB,EAEJmB,OAFI,CAEIlD,OAFJ,EAEa6C,cAFb,CAAP;AAGD;;AANY,OAAf;AAQD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACES,EAAAA,OAAO,CAACC,WAAD,EAAc;AACnB,UAAM1C,QAAQ,GAAG,IAAjB;;AAEA,QAAI,KAAKwC,MAAL,KAAgB,QAAhB,IAA4B,KAAKA,MAAL,KAAgB,aAAhD,EAA+D;AAC7DE,MAAAA,WAAW,CAACC,MAAZ,GAAqB,KAAKjB,SAAL,CAAeS,SAAf,CAAyBO,WAAW,CAACC,MAArC,CAArB;AACAD,MAAAA,WAAW,CAACC,MAAZ,GAAqBL,KAAK,CAACC,OAAN,CAAcG,WAAW,CAACC,MAA1B,IACjBD,WAAW,CAACC,MADK,GAEjB,CAACD,WAAW,CAACC,MAAb,CAFJ;AAGAD,MAAAA,WAAW,CAACE,OAAZ,GAAsB,KAAKlB,SAAL,CAAeS,SAAf,CAAyBO,WAAW,CAACE,OAArC,CAAtB;AACAF,MAAAA,WAAW,CAACG,UAAZ,GAAyB,KAAKnB,SAAL,CAAeS,SAAf,CAAyBO,WAAW,CAACG,UAArC,CAAzB;AAEA,WAAKlD,SAAL,CAAe;AACbL,QAAAA,GAAG,EAAG,qBAAoB,KAAKC,SAAL,EAAiB,GAD9B;;AAEbuD,QAAAA,kBAAkB,CAAC9B,MAAD,EAASE,UAAT,EAAqB;AACrC,iBAAOlB,QAAQ,CAACK,MAAT,CACJY,GADI,CACAjB,QADA,EACUgB,MADV,EACkBE,UADlB,EAEJuB,OAFI,CAEIC,WAFJ,CAAP;AAGD;;AANY,OAAf;AAQD;AACF;;AAEDhD,EAAAA,WAAW,GAAG;AACZ,UAAMqD,GAAG,GAAGtE,MAAM,CAAC,KAAKuE,OAAL,CAAaC,UAAb,IAA2B,EAA5B,EAAgC;AAAET,MAAAA,MAAM,EAAE;AAAV,KAAhC,CAAlB;;AACA,QAAIO,GAAG,CAACzB,MAAJ,GAAa,CAAb,IAAkByB,GAAG,CAAC,CAAD,CAAH,CAAOG,IAAP,CAAY5B,MAAZ,GAAqB,CAA3C,EAA8C;AAC5C,YAAMnC,OAAO,GAAG4D,GAAG,CAAC,CAAD,CAAH,CAAOG,IAAP,CAAY,CAAZ,CAAhB;AACA,UAAIlB,cAAc,GAAGe,GAAG,CAAC,CAAD,CAAH,CAAOG,IAAP,CAAY,CAAZ,KAAkB,EAAvC;;AACA,UAAIlB,cAAJ,EAAoB;AAClBA,QAAAA,cAAc,GAAG,iBAAiB,KAAKN,SAAL,CAAeC,IAAf,CAAoBK,cAApB,CAAlC;AACD;;AACD,aAAQ,IAAGA,cAAe,iBAAgB,KAAKN,SAAL,CAAeS,SAAf,CACxChD,OADwC,CAExC,GAFF;AAGD;AACF;;AAEDM,EAAAA,WAAW,GAAG;AACZ,QAAIH,GAAG,GAAG,EAAV;AACA,UAAMG,WAAW,GAAGhB,MAAM,CAAC,KAAKuE,OAAL,CAAaC,UAAb,IAA2B,EAA5B,EAAgC;AACxDT,MAAAA,MAAM,EAAE;AADgD,KAAhC,CAA1B;;AAGA,SAAK,IAAIpB,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAG5B,WAAW,CAAC6B,MAAhC,EAAwCF,CAAC,GAAGC,CAA5C,EAA+CD,CAAC,EAAhD,EAAoD;AAClD,YAAMqB,OAAO,GAAGhD,WAAW,CAAC2B,CAAD,CAAX,CAAe8B,IAAf,CAAoB,CAApB,CAAhB;AACA,YAAMP,MAAM,GAAG,KAAKjB,SAAL,CAAeS,SAAf,CAAyBM,OAAO,CAACE,MAAjC,CAAf;AACA,YAAME,UAAU,GAAG,KAAKnB,SAAL,CAAeS,SAAf,CAAyBM,OAAO,CAACI,UAAjC,CAAnB;AACA,YAAMM,YAAY,GAAG,KAAKzB,SAAL,CAAeC,IAAf,CAAoBc,OAAO,CAACG,OAA5B,CAArB;AACA,UAAIZ,cAAc,GAAGS,OAAO,CAACW,OAAR,IAAmB,EAAxC;;AACA,UAAIpB,cAAJ,EAAoB;AAClBA,QAAAA,cAAc,GAAG,iBAAiB,KAAKN,SAAL,CAAeC,IAAf,CAAoBK,cAApB,CAAlC;AACD;;AACD1C,MAAAA,GAAG,IAAK,IAAG0C,cAAe,gBAAeW,MAAO,gBAAeQ,YAAa,IAAGN,UAAW,GAA1F;AACA,UAAIJ,OAAO,CAACY,QAAZ,EAAsB/D,GAAG,IAAK,cAAamD,OAAO,CAACY,QAAS,EAAtC;AACtB,UAAIZ,OAAO,CAACa,QAAZ,EAAsBhE,GAAG,IAAK,cAAamD,OAAO,CAACa,QAAS,EAAtC;AACvB;;AACD,WAAOhE,GAAP;AACD;;AAEDiE,EAAAA,gBAAgB,GAAG;AACjB,WAAO,KAAKC,UAAL,GAAkBC,MAAlB,GAA2BjE,IAA3B,CAAgC,GAAhC,CAAP;AACD;;AAEDkE,EAAAA,YAAY,CAACC,IAAD,EAAOC,EAAP,EAAW;AACrB,SAAKjE,SAAL,CAAe;AACbL,MAAAA,GAAG,EAAG,eAAc,KAAKC,SAAL,EAAiB,WAAU,KAAKmC,SAAL,CAAeC,IAAf,CAC7CgC,IAD6C,CAE7C,OAAM,KAAKjC,SAAL,CAAeC,IAAf,CAAoBiC,EAApB,CAAwB;AAHnB,KAAf;AAKD;;AAEDC,EAAAA,UAAU,GAAG;AACX,UAAM7D,QAAQ,GAAG,IAAjB;AACA,UAAMb,OAAO,GAAGR,MAAM,CAACM,SAAD,CAAtB;AACA,SAAKU,SAAL,CAAe;AACbL,MAAAA,GAAG,EAAG,qBAAoB,KAAKC,SAAL,EAAiB,GAD9B;;AAEbwB,MAAAA,MAAM,CAACC,MAAD,EAAS;AACb,eAAOhB,QAAQ,CAACK,MAAT,CACJY,GADI,CACAjB,QADA,EACUgB,MADV,EACkB,KAAKE,UADvB,EAEJ2C,UAFI,CAEO1E,OAFP,CAAP;AAGD;;AANY,KAAf;AAQD;;AA1P+C;;AA6PlD2E,MAAM,CAACC,OAAP,GAAiBhF,qBAAjB","sourcesContent":["const filter = require('lodash/filter');\nconst values = require('lodash/values');\nconst identity = require('lodash/identity');\n\nconst TableCompiler = require('../../../schema/tablecompiler');\nconst { formatDefault } = require('../../../formatter/formatterUtils');\n\nclass TableCompiler_SQLite3 extends TableCompiler {\n  constructor() {\n    super(...arguments);\n  }\n\n  // Create a new table.\n  createQuery(columns, ifNot) {\n    const createStatement = ifNot\n      ? 'create table if not exists '\n      : 'create table ';\n    let sql =\n      createStatement + this.tableName() + ' (' + columns.sql.join(', ');\n\n    // SQLite forces primary keys to be added when the table is initially created\n    // so we will need to check for a primary key commands and add the columns\n    // to the table's declaration here so they can be created on the tables.\n    sql += this.foreignKeys() || '';\n    sql += this.primaryKeys() || '';\n    sql += ')';\n\n    this.pushQuery(sql);\n  }\n\n  addColumns(columns, prefix, colCompilers) {\n    if (prefix === this.alterColumnsPrefix) {\n      const compiler = this;\n\n      const columnsInfo = colCompilers.map((col) => {\n        const name = this.client.customWrapIdentifier(\n          col.getColumnName(),\n          identity,\n          col.columnBuilder.queryContext()\n        );\n\n        const type = col.getColumnType();\n\n        const defaultTo = col.modified['defaultTo']\n          ? formatDefault(col.modified['defaultTo'][0], type, this.client)\n          : null;\n\n        const notNull =\n          col.modified['nullable'] && col.modified['nullable'][0] === false;\n\n        return { name, type, defaultTo, notNull };\n      });\n\n      this.pushQuery({\n        sql: `PRAGMA table_info(${this.tableName()})`,\n        output(pragma) {\n          return compiler.client\n            .ddl(compiler, pragma, this.connection)\n            .alterColumn(columnsInfo);\n        },\n      });\n    } else {\n      for (let i = 0, l = columns.sql.length; i < l; i++) {\n        this.pushQuery({\n          sql: `alter table ${this.tableName()} add column ${columns.sql[i]}`,\n          bindings: columns.bindings[i],\n        });\n      }\n    }\n  }\n\n  // Compile a drop unique key command.\n  dropUnique(columns, indexName) {\n    indexName = indexName\n      ? this.formatter.wrap(indexName)\n      : this._indexCommand('unique', this.tableNameRaw, columns);\n    this.pushQuery(`drop index ${indexName}`);\n  }\n\n  // Compile a drop foreign key command.\n  dropForeign(columns, indexName) {\n    const compiler = this;\n\n    this.pushQuery({\n      sql: `PRAGMA table_info(${this.tableName()})`,\n      output(pragma) {\n        return compiler.client\n          .ddl(compiler, pragma, this.connection)\n          .dropForeign(columns, indexName);\n      },\n    });\n  }\n\n  // Compile a drop primary key command.\n  dropPrimary(constraintName) {\n    const compiler = this;\n\n    this.pushQuery({\n      sql: `PRAGMA table_info(${this.tableName()})`,\n      output(pragma) {\n        return compiler.client\n          .ddl(compiler, pragma, this.connection)\n          .dropPrimary(constraintName);\n      },\n    });\n  }\n\n  dropIndex(columns, indexName) {\n    indexName = indexName\n      ? this.formatter.wrap(indexName)\n      : this._indexCommand('index', this.tableNameRaw, columns);\n    this.pushQuery(`drop index ${indexName}`);\n  }\n\n  // Compile a unique key command.\n  unique(columns, indexName) {\n    indexName = indexName\n      ? this.formatter.wrap(indexName)\n      : this._indexCommand('unique', this.tableNameRaw, columns);\n    columns = this.formatter.columnize(columns);\n    this.pushQuery(\n      `create unique index ${indexName} on ${this.tableName()} (${columns})`\n    );\n  }\n\n  // Compile a plain index key command.\n  index(columns, indexName) {\n    indexName = indexName\n      ? this.formatter.wrap(indexName)\n      : this._indexCommand('index', this.tableNameRaw, columns);\n    columns = this.formatter.columnize(columns);\n    this.pushQuery(\n      `create index ${indexName} on ${this.tableName()} (${columns})`\n    );\n  }\n\n  /**\n   * Add a primary key to an existing table.\n   *\n   * @NOTE The `createQuery` method above handles table creation. Don't do anything regarding table\n   *       creation in this method\n   *\n   * @param {string | string[]} columns - Column name(s) to assign as primary keys\n   * @param {string} [constraintName] - Custom name for the PK constraint\n   */\n  primary(columns, constraintName) {\n    const compiler = this;\n\n    columns = this.formatter.columnize(columns);\n    columns = Array.isArray(columns) ? columns : [columns];\n\n    if (this.method !== 'create' && this.method !== 'createIfNot') {\n      this.pushQuery({\n        sql: `PRAGMA table_info(${this.tableName()})`,\n        output(pragma) {\n          return compiler.client\n            .ddl(compiler, pragma, this.connection)\n            .primary(columns, constraintName);\n        },\n      });\n    }\n  }\n\n  /**\n   * Add a foreign key constraint to an existing table\n   *\n   * @NOTE The `createQuery` method above handles foreign key constraints on table creation. Don't do\n   *       anything regarding table creation in this method\n   *\n   * @param {object} foreignInfo - Information about the current column foreign setup\n   * @param {string | string[]} [foreignInfo.column] - Column in the current constraint\n   * @param {string | undefined} foreignInfo.keyName - Name of the foreign key constraint\n   * @param {string} foreignInfo.references - What column it references in the other table\n   * @param {string} foreignInfo.inTable - What table is referenced in this constraint\n   * @param {string} [foreignInfo.onUpdate] - What to do on updates\n   * @param {string} [foreignInfo.onDelete] - What to do on deletions\n   */\n  foreign(foreignInfo) {\n    const compiler = this;\n\n    if (this.method !== 'create' && this.method !== 'createIfNot') {\n      foreignInfo.column = this.formatter.columnize(foreignInfo.column);\n      foreignInfo.column = Array.isArray(foreignInfo.column)\n        ? foreignInfo.column\n        : [foreignInfo.column];\n      foreignInfo.inTable = this.formatter.columnize(foreignInfo.inTable);\n      foreignInfo.references = this.formatter.columnize(foreignInfo.references);\n\n      this.pushQuery({\n        sql: `PRAGMA table_info(${this.tableName()})`,\n        statementsProducer(pragma, connection) {\n          return compiler.client\n            .ddl(compiler, pragma, connection)\n            .foreign(foreignInfo);\n        },\n      });\n    }\n  }\n\n  primaryKeys() {\n    const pks = filter(this.grouped.alterTable || [], { method: 'primary' });\n    if (pks.length > 0 && pks[0].args.length > 0) {\n      const columns = pks[0].args[0];\n      let constraintName = pks[0].args[1] || '';\n      if (constraintName) {\n        constraintName = ' constraint ' + this.formatter.wrap(constraintName);\n      }\n      return `,${constraintName} primary key (${this.formatter.columnize(\n        columns\n      )})`;\n    }\n  }\n\n  foreignKeys() {\n    let sql = '';\n    const foreignKeys = filter(this.grouped.alterTable || [], {\n      method: 'foreign',\n    });\n    for (let i = 0, l = foreignKeys.length; i < l; i++) {\n      const foreign = foreignKeys[i].args[0];\n      const column = this.formatter.columnize(foreign.column);\n      const references = this.formatter.columnize(foreign.references);\n      const foreignTable = this.formatter.wrap(foreign.inTable);\n      let constraintName = foreign.keyName || '';\n      if (constraintName) {\n        constraintName = ' constraint ' + this.formatter.wrap(constraintName);\n      }\n      sql += `,${constraintName} foreign key(${column}) references ${foreignTable}(${references})`;\n      if (foreign.onDelete) sql += ` on delete ${foreign.onDelete}`;\n      if (foreign.onUpdate) sql += ` on update ${foreign.onUpdate}`;\n    }\n    return sql;\n  }\n\n  createTableBlock() {\n    return this.getColumns().concat().join(',');\n  }\n\n  renameColumn(from, to) {\n    this.pushQuery({\n      sql: `alter table ${this.tableName()} rename ${this.formatter.wrap(\n        from\n      )} to ${this.formatter.wrap(to)}`,\n    });\n  }\n\n  dropColumn() {\n    const compiler = this;\n    const columns = values(arguments);\n    this.pushQuery({\n      sql: `PRAGMA table_info(${this.tableName()})`,\n      output(pragma) {\n        return compiler.client\n          .ddl(compiler, pragma, this.connection)\n          .dropColumn(columns);\n      },\n    });\n  }\n}\n\nmodule.exports = TableCompiler_SQLite3;\n"]},"metadata":{},"sourceType":"script"}