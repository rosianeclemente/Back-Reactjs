{"ast":null,"code":"/* eslint max-len:0 */\n// Table Compiler\n// -------\nconst {\n  pushAdditional,\n  pushQuery,\n  unshiftQuery\n} = require('./internal/helpers');\n\nconst helpers = require('../util/helpers');\n\nconst groupBy = require('lodash/groupBy');\n\nconst indexOf = require('lodash/indexOf');\n\nconst isEmpty = require('lodash/isEmpty');\n\nconst tail = require('lodash/tail');\n\nclass TableCompiler {\n  constructor(client, tableBuilder) {\n    this.client = client;\n    this.tableBuilder = tableBuilder;\n    this._commonBuilder = this.tableBuilder;\n    this.method = tableBuilder._method;\n    this.schemaNameRaw = tableBuilder._schemaName;\n    this.tableNameRaw = tableBuilder._tableName;\n    this.single = tableBuilder._single;\n    this.grouped = groupBy(tableBuilder._statements, 'grouping');\n    this.formatter = client.formatter(tableBuilder);\n    this.bindings = [];\n    this.formatter.bindings = this.bindings;\n    this.bindingsHolder = this;\n    this.sequence = [];\n    this._formatting = client.config && client.config.formatting;\n  } // Convert the tableCompiler toSQL\n\n\n  toSQL() {\n    this[this.method]();\n    return this.sequence;\n  } // Column Compilation\n  // -------\n  // If this is a table \"creation\", we need to first run through all\n  // of the columns to build them into a single string,\n  // and then run through anything else and push it to the query sequence.\n\n\n  create(ifNot) {\n    const columnBuilders = this.getColumns();\n    const columns = columnBuilders.map(col => col.toSQL());\n    const columnTypes = this.getColumnTypes(columns);\n\n    if (this.createAlterTableMethods) {\n      this.alterTableForCreate(columnTypes);\n    }\n\n    this.createQuery(columnTypes, ifNot);\n    this.columnQueries(columns);\n    delete this.single.comment;\n    this.alterTable();\n  } // Only create the table if it doesn't exist.\n\n\n  createIfNot() {\n    this.create(true);\n  } // If we're altering the table, we need to one-by-one\n  // go through and handle each of the queries associated\n  // with altering the table's schema.\n\n\n  alter() {\n    const addColBuilders = this.getColumns();\n    const addColumns = addColBuilders.map(col => col.toSQL());\n    const alterColBuilders = this.getColumns('alter');\n    const alterColumns = alterColBuilders.map(col => col.toSQL());\n    const addColumnTypes = this.getColumnTypes(addColumns);\n    const alterColumnTypes = this.getColumnTypes(alterColumns);\n    this.addColumns(addColumnTypes);\n    this.alterColumns(alterColumnTypes, alterColBuilders);\n    this.columnQueries(addColumns);\n    this.columnQueries(alterColumns);\n    this.alterTable();\n  }\n\n  foreign(foreignData) {\n    if (foreignData.inTable && foreignData.references) {\n      const keyName = foreignData.keyName ? this.formatter.wrap(foreignData.keyName) : this._indexCommand('foreign', this.tableNameRaw, foreignData.column);\n      const column = this.formatter.columnize(foreignData.column);\n      const references = this.formatter.columnize(foreignData.references);\n      const inTable = this.formatter.wrap(foreignData.inTable);\n      const onUpdate = foreignData.onUpdate ? (this.lowerCase ? ' on update ' : ' ON UPDATE ') + foreignData.onUpdate : '';\n      const onDelete = foreignData.onDelete ? (this.lowerCase ? ' on delete ' : ' ON DELETE ') + foreignData.onDelete : '';\n\n      if (this.lowerCase) {\n        this.pushQuery((!this.forCreate ? `alter table ${this.tableName()} add ` : '') + 'constraint ' + keyName + ' ' + 'foreign key (' + column + ') references ' + inTable + ' (' + references + ')' + onUpdate + onDelete);\n      } else {\n        this.pushQuery((!this.forCreate ? `ALTER TABLE ${this.tableName()} ADD ` : '') + 'CONSTRAINT ' + keyName + ' ' + 'FOREIGN KEY (' + column + ') REFERENCES ' + inTable + ' (' + references + ')' + onUpdate + onDelete);\n      }\n    }\n  } // Get all of the column sql & bindings individually for building the table queries.\n\n\n  getColumnTypes(columns) {\n    return columns.reduce(function (memo, columnSQL) {\n      const column = columnSQL[0];\n      memo.sql.push(column.sql);\n      memo.bindings.concat(column.bindings);\n      return memo;\n    }, {\n      sql: [],\n      bindings: []\n    });\n  } // Adds all of the additional queries from the \"column\"\n\n\n  columnQueries(columns) {\n    const queries = columns.reduce(function (memo, columnSQL) {\n      const column = tail(columnSQL);\n      if (!isEmpty(column)) return memo.concat(column);\n      return memo;\n    }, []);\n\n    for (const q of queries) {\n      this.pushQuery(q);\n    }\n  } // All of the columns to \"add\" for the query\n\n\n  addColumns(columns, prefix) {\n    prefix = prefix || this.addColumnsPrefix;\n\n    if (columns.sql.length > 0) {\n      const columnSql = columns.sql.map(column => {\n        return prefix + column;\n      });\n      this.pushQuery({\n        sql: (this.lowerCase ? 'alter table ' : 'ALTER TABLE ') + this.tableName() + ' ' + columnSql.join(', '),\n        bindings: columns.bindings\n      });\n    }\n  }\n\n  alterColumns(columns, colBuilders) {\n    if (columns.sql.length > 0) {\n      this.addColumns(columns, this.alterColumnsPrefix, colBuilders);\n    }\n  } // Compile the columns as needed for the current create or alter table\n\n\n  getColumns(method) {\n    const columns = this.grouped.columns || [];\n    method = method || 'add';\n    const queryContext = this.tableBuilder.queryContext();\n    return columns.filter(column => column.builder._method === method).map(column => {\n      // pass queryContext down to columnBuilder but do not overwrite it if already set\n      if (queryContext !== undefined && column.builder.queryContext() === undefined) {\n        column.builder.queryContext(queryContext);\n      }\n\n      return this.client.columnCompiler(this, column.builder);\n    });\n  }\n\n  tableName() {\n    const name = this.schemaNameRaw ? `${this.schemaNameRaw}.${this.tableNameRaw}` : this.tableNameRaw;\n    return this.formatter.wrap(name);\n  } // Generate all of the alter column statements necessary for the query.\n\n\n  alterTable() {\n    const alterTable = this.grouped.alterTable || [];\n\n    for (let i = 0, l = alterTable.length; i < l; i++) {\n      const statement = alterTable[i];\n\n      if (this[statement.method]) {\n        this[statement.method].apply(this, statement.args);\n      } else {\n        this.client.logger.error(`Debug: ${statement.method} does not exist`);\n      }\n    }\n\n    for (const item in this.single) {\n      if (typeof this[item] === 'function') this[item](this.single[item]);\n    }\n  }\n\n  alterTableForCreate(columnTypes) {\n    this.forCreate = true;\n    const savedSequence = this.sequence;\n    const alterTable = this.grouped.alterTable || [];\n    this.grouped.alterTable = [];\n\n    for (let i = 0, l = alterTable.length; i < l; i++) {\n      const statement = alterTable[i];\n\n      if (indexOf(this.createAlterTableMethods, statement.method) < 0) {\n        this.grouped.alterTable.push(statement);\n        continue;\n      }\n\n      if (this[statement.method]) {\n        this.sequence = [];\n        this[statement.method].apply(this, statement.args);\n        columnTypes.sql.push(this.sequence[0].sql);\n      } else {\n        this.client.logger.error(`Debug: ${statement.method} does not exist`);\n      }\n    }\n\n    this.sequence = savedSequence;\n    this.forCreate = false;\n  } // Drop the index on the current table.\n\n\n  dropIndex(value) {\n    this.pushQuery(`drop index${value}`);\n  }\n\n  dropUnique() {\n    throw new Error('Method implemented in the dialect driver');\n  }\n\n  dropForeign() {\n    throw new Error('Method implemented in the dialect driver');\n  }\n\n  dropColumn() {\n    const columns = helpers.normalizeArr.apply(null, arguments);\n    const drops = (Array.isArray(columns) ? columns : [columns]).map(column => {\n      return this.dropColumnPrefix + this.formatter.wrap(column);\n    });\n    this.pushQuery((this.lowerCase ? 'alter table ' : 'ALTER TABLE ') + this.tableName() + ' ' + drops.join(', '));\n  } // If no name was specified for this index, we will create one using a basic\n  // convention of the table name, followed by the columns, followed by an\n  // index type, such as primary or index, which makes the index unique.\n\n\n  _indexCommand(type, tableName, columns) {\n    if (!Array.isArray(columns)) columns = columns ? [columns] : [];\n    const table = tableName.replace(/\\.|-/g, '_');\n    const indexName = (table + '_' + columns.join('_') + '_' + type).toLowerCase();\n    return this.formatter.wrap(indexName);\n  }\n\n}\n\nTableCompiler.prototype.pushQuery = pushQuery;\nTableCompiler.prototype.pushAdditional = pushAdditional;\nTableCompiler.prototype.unshiftQuery = unshiftQuery;\nTableCompiler.prototype.lowerCase = true;\nTableCompiler.prototype.createAlterTableMethods = null;\nTableCompiler.prototype.addColumnsPrefix = 'add column ';\nTableCompiler.prototype.alterColumnsPrefix = 'alter column ';\nTableCompiler.prototype.dropColumnPrefix = 'drop column ';\nmodule.exports = TableCompiler;","map":{"version":3,"sources":["/home/rosiane/Projeto-completo/back/node_modules/knex/lib/schema/tablecompiler.js"],"names":["pushAdditional","pushQuery","unshiftQuery","require","helpers","groupBy","indexOf","isEmpty","tail","TableCompiler","constructor","client","tableBuilder","_commonBuilder","method","_method","schemaNameRaw","_schemaName","tableNameRaw","_tableName","single","_single","grouped","_statements","formatter","bindings","bindingsHolder","sequence","_formatting","config","formatting","toSQL","create","ifNot","columnBuilders","getColumns","columns","map","col","columnTypes","getColumnTypes","createAlterTableMethods","alterTableForCreate","createQuery","columnQueries","comment","alterTable","createIfNot","alter","addColBuilders","addColumns","alterColBuilders","alterColumns","addColumnTypes","alterColumnTypes","foreign","foreignData","inTable","references","keyName","wrap","_indexCommand","column","columnize","onUpdate","lowerCase","onDelete","forCreate","tableName","reduce","memo","columnSQL","sql","push","concat","queries","q","prefix","addColumnsPrefix","length","columnSql","join","colBuilders","alterColumnsPrefix","queryContext","filter","builder","undefined","columnCompiler","name","i","l","statement","apply","args","logger","error","item","savedSequence","dropIndex","value","dropUnique","Error","dropForeign","dropColumn","normalizeArr","arguments","drops","Array","isArray","dropColumnPrefix","type","table","replace","indexName","toLowerCase","prototype","module","exports"],"mappings":"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","sourcesContent":["/* eslint max-len:0 */\n\n// Table Compiler\n// -------\nconst {\n  pushAdditional,\n  pushQuery,\n  unshiftQuery,\n} = require('./internal/helpers');\nconst helpers = require('../util/helpers');\nconst groupBy = require('lodash/groupBy');\nconst indexOf = require('lodash/indexOf');\nconst isEmpty = require('lodash/isEmpty');\nconst tail = require('lodash/tail');\n\nclass TableCompiler {\n  constructor(client, tableBuilder) {\n    this.client = client;\n    this.tableBuilder = tableBuilder;\n    this._commonBuilder = this.tableBuilder;\n    this.method = tableBuilder._method;\n    this.schemaNameRaw = tableBuilder._schemaName;\n    this.tableNameRaw = tableBuilder._tableName;\n    this.single = tableBuilder._single;\n    this.grouped = groupBy(tableBuilder._statements, 'grouping');\n\n    this.formatter = client.formatter(tableBuilder);\n    this.bindings = [];\n    this.formatter.bindings = this.bindings;\n    this.bindingsHolder = this;\n\n    this.sequence = [];\n    this._formatting = client.config && client.config.formatting;\n  }\n\n  // Convert the tableCompiler toSQL\n  toSQL() {\n    this[this.method]();\n    return this.sequence;\n  }\n\n  // Column Compilation\n  // -------\n\n  // If this is a table \"creation\", we need to first run through all\n  // of the columns to build them into a single string,\n  // and then run through anything else and push it to the query sequence.\n  create(ifNot) {\n    const columnBuilders = this.getColumns();\n    const columns = columnBuilders.map((col) => col.toSQL());\n    const columnTypes = this.getColumnTypes(columns);\n    if (this.createAlterTableMethods) {\n      this.alterTableForCreate(columnTypes);\n    }\n    this.createQuery(columnTypes, ifNot);\n    this.columnQueries(columns);\n    delete this.single.comment;\n    this.alterTable();\n  }\n\n  // Only create the table if it doesn't exist.\n  createIfNot() {\n    this.create(true);\n  }\n\n  // If we're altering the table, we need to one-by-one\n  // go through and handle each of the queries associated\n  // with altering the table's schema.\n  alter() {\n    const addColBuilders = this.getColumns();\n    const addColumns = addColBuilders.map((col) => col.toSQL());\n    const alterColBuilders = this.getColumns('alter');\n    const alterColumns = alterColBuilders.map((col) => col.toSQL());\n    const addColumnTypes = this.getColumnTypes(addColumns);\n    const alterColumnTypes = this.getColumnTypes(alterColumns);\n\n    this.addColumns(addColumnTypes);\n    this.alterColumns(alterColumnTypes, alterColBuilders);\n    this.columnQueries(addColumns);\n    this.columnQueries(alterColumns);\n    this.alterTable();\n  }\n\n  foreign(foreignData) {\n    if (foreignData.inTable && foreignData.references) {\n      const keyName = foreignData.keyName\n        ? this.formatter.wrap(foreignData.keyName)\n        : this._indexCommand('foreign', this.tableNameRaw, foreignData.column);\n      const column = this.formatter.columnize(foreignData.column);\n      const references = this.formatter.columnize(foreignData.references);\n      const inTable = this.formatter.wrap(foreignData.inTable);\n      const onUpdate = foreignData.onUpdate\n        ? (this.lowerCase ? ' on update ' : ' ON UPDATE ') +\n          foreignData.onUpdate\n        : '';\n      const onDelete = foreignData.onDelete\n        ? (this.lowerCase ? ' on delete ' : ' ON DELETE ') +\n          foreignData.onDelete\n        : '';\n      if (this.lowerCase) {\n        this.pushQuery(\n          (!this.forCreate ? `alter table ${this.tableName()} add ` : '') +\n            'constraint ' +\n            keyName +\n            ' ' +\n            'foreign key (' +\n            column +\n            ') references ' +\n            inTable +\n            ' (' +\n            references +\n            ')' +\n            onUpdate +\n            onDelete\n        );\n      } else {\n        this.pushQuery(\n          (!this.forCreate ? `ALTER TABLE ${this.tableName()} ADD ` : '') +\n            'CONSTRAINT ' +\n            keyName +\n            ' ' +\n            'FOREIGN KEY (' +\n            column +\n            ') REFERENCES ' +\n            inTable +\n            ' (' +\n            references +\n            ')' +\n            onUpdate +\n            onDelete\n        );\n      }\n    }\n  }\n\n  // Get all of the column sql & bindings individually for building the table queries.\n  getColumnTypes(columns) {\n    return columns.reduce(\n      function (memo, columnSQL) {\n        const column = columnSQL[0];\n        memo.sql.push(column.sql);\n        memo.bindings.concat(column.bindings);\n        return memo;\n      },\n      { sql: [], bindings: [] }\n    );\n  }\n\n  // Adds all of the additional queries from the \"column\"\n  columnQueries(columns) {\n    const queries = columns.reduce(function (memo, columnSQL) {\n      const column = tail(columnSQL);\n      if (!isEmpty(column)) return memo.concat(column);\n      return memo;\n    }, []);\n    for (const q of queries) {\n      this.pushQuery(q);\n    }\n  }\n\n  // All of the columns to \"add\" for the query\n  addColumns(columns, prefix) {\n    prefix = prefix || this.addColumnsPrefix;\n\n    if (columns.sql.length > 0) {\n      const columnSql = columns.sql.map((column) => {\n        return prefix + column;\n      });\n      this.pushQuery({\n        sql:\n          (this.lowerCase ? 'alter table ' : 'ALTER TABLE ') +\n          this.tableName() +\n          ' ' +\n          columnSql.join(', '),\n        bindings: columns.bindings,\n      });\n    }\n  }\n\n  alterColumns(columns, colBuilders) {\n    if (columns.sql.length > 0) {\n      this.addColumns(columns, this.alterColumnsPrefix, colBuilders);\n    }\n  }\n\n  // Compile the columns as needed for the current create or alter table\n  getColumns(method) {\n    const columns = this.grouped.columns || [];\n    method = method || 'add';\n\n    const queryContext = this.tableBuilder.queryContext();\n\n    return columns\n      .filter((column) => column.builder._method === method)\n      .map((column) => {\n        // pass queryContext down to columnBuilder but do not overwrite it if already set\n        if (\n          queryContext !== undefined &&\n          column.builder.queryContext() === undefined\n        ) {\n          column.builder.queryContext(queryContext);\n        }\n        return this.client.columnCompiler(this, column.builder);\n      });\n  }\n\n  tableName() {\n    const name = this.schemaNameRaw\n      ? `${this.schemaNameRaw}.${this.tableNameRaw}`\n      : this.tableNameRaw;\n\n    return this.formatter.wrap(name);\n  }\n\n  // Generate all of the alter column statements necessary for the query.\n  alterTable() {\n    const alterTable = this.grouped.alterTable || [];\n    for (let i = 0, l = alterTable.length; i < l; i++) {\n      const statement = alterTable[i];\n      if (this[statement.method]) {\n        this[statement.method].apply(this, statement.args);\n      } else {\n        this.client.logger.error(`Debug: ${statement.method} does not exist`);\n      }\n    }\n    for (const item in this.single) {\n      if (typeof this[item] === 'function') this[item](this.single[item]);\n    }\n  }\n\n  alterTableForCreate(columnTypes) {\n    this.forCreate = true;\n    const savedSequence = this.sequence;\n    const alterTable = this.grouped.alterTable || [];\n    this.grouped.alterTable = [];\n    for (let i = 0, l = alterTable.length; i < l; i++) {\n      const statement = alterTable[i];\n      if (indexOf(this.createAlterTableMethods, statement.method) < 0) {\n        this.grouped.alterTable.push(statement);\n        continue;\n      }\n      if (this[statement.method]) {\n        this.sequence = [];\n        this[statement.method].apply(this, statement.args);\n        columnTypes.sql.push(this.sequence[0].sql);\n      } else {\n        this.client.logger.error(`Debug: ${statement.method} does not exist`);\n      }\n    }\n    this.sequence = savedSequence;\n    this.forCreate = false;\n  }\n\n  // Drop the index on the current table.\n  dropIndex(value) {\n    this.pushQuery(`drop index${value}`);\n  }\n\n  dropUnique() {\n    throw new Error('Method implemented in the dialect driver');\n  }\n\n  dropForeign() {\n    throw new Error('Method implemented in the dialect driver');\n  }\n\n  dropColumn() {\n    const columns = helpers.normalizeArr.apply(null, arguments);\n    const drops = (Array.isArray(columns) ? columns : [columns]).map(\n      (column) => {\n        return this.dropColumnPrefix + this.formatter.wrap(column);\n      }\n    );\n    this.pushQuery(\n      (this.lowerCase ? 'alter table ' : 'ALTER TABLE ') +\n        this.tableName() +\n        ' ' +\n        drops.join(', ')\n    );\n  }\n\n  // If no name was specified for this index, we will create one using a basic\n  // convention of the table name, followed by the columns, followed by an\n  // index type, such as primary or index, which makes the index unique.\n  _indexCommand(type, tableName, columns) {\n    if (!Array.isArray(columns)) columns = columns ? [columns] : [];\n    const table = tableName.replace(/\\.|-/g, '_');\n    const indexName = (\n      table +\n      '_' +\n      columns.join('_') +\n      '_' +\n      type\n    ).toLowerCase();\n    return this.formatter.wrap(indexName);\n  }\n}\n\nTableCompiler.prototype.pushQuery = pushQuery;\nTableCompiler.prototype.pushAdditional = pushAdditional;\nTableCompiler.prototype.unshiftQuery = unshiftQuery;\nTableCompiler.prototype.lowerCase = true;\nTableCompiler.prototype.createAlterTableMethods = null;\nTableCompiler.prototype.addColumnsPrefix = 'add column ';\nTableCompiler.prototype.alterColumnsPrefix = 'alter column ';\nTableCompiler.prototype.dropColumnPrefix = 'drop column ';\n\nmodule.exports = TableCompiler;\n"]},"metadata":{},"sourceType":"script"}