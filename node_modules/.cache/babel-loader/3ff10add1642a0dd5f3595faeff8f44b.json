{"ast":null,"code":"// PostgreSQL Schema Compiler\n// -------\nconst SchemaCompiler = require('../../../schema/compiler');\n\nclass SchemaCompiler_PG extends SchemaCompiler {\n  constructor(client, builder) {\n    super(client, builder);\n  } // Check whether the current table\n\n\n  hasTable(tableName) {\n    let sql = 'select * from information_schema.tables where table_name = ?';\n    const bindings = [tableName];\n\n    if (this.schema) {\n      sql += ' and table_schema = ?';\n      bindings.push(this.schema);\n    } else {\n      sql += ' and table_schema = current_schema()';\n    }\n\n    this.pushQuery({\n      sql,\n      bindings,\n\n      output(resp) {\n        return resp.rows.length > 0;\n      }\n\n    });\n  } // Compile the query to determine if a column exists in a table.\n\n\n  hasColumn(tableName, columnName) {\n    let sql = 'select * from information_schema.columns where table_name = ? and column_name = ?';\n    const bindings = [tableName, columnName];\n\n    if (this.schema) {\n      sql += ' and table_schema = ?';\n      bindings.push(this.schema);\n    } else {\n      sql += ' and table_schema = current_schema()';\n    }\n\n    this.pushQuery({\n      sql,\n      bindings,\n\n      output(resp) {\n        return resp.rows.length > 0;\n      }\n\n    });\n  }\n\n  qualifiedTableName(tableName) {\n    const name = this.schema ? `${this.schema}.${tableName}` : tableName;\n    return this.formatter.wrap(name);\n  } // Compile a rename table command.\n\n\n  renameTable(from, to) {\n    this.pushQuery(`alter table ${this.qualifiedTableName(from)} rename to ${this.formatter.wrap(to)}`);\n  }\n\n  createSchema(schemaName) {\n    this.pushQuery(`create schema ${this.formatter.wrap(schemaName)}`);\n  }\n\n  createSchemaIfNotExists(schemaName) {\n    this.pushQuery(`create schema if not exists ${this.formatter.wrap(schemaName)}`);\n  }\n\n  dropSchema(schemaName) {\n    this.pushQuery(`drop schema ${this.formatter.wrap(schemaName)}`);\n  }\n\n  dropSchemaIfExists(schemaName) {\n    this.pushQuery(`drop schema if exists ${this.formatter.wrap(schemaName)}`);\n  }\n\n  dropExtension(extensionName) {\n    this.pushQuery(`drop extension ${this.formatter.wrap(extensionName)}`);\n  }\n\n  dropExtensionIfExists(extensionName) {\n    this.pushQuery(`drop extension if exists ${this.formatter.wrap(extensionName)}`);\n  }\n\n  createExtension(extensionName) {\n    this.pushQuery(`create extension ${this.formatter.wrap(extensionName)}`);\n  }\n\n  createExtensionIfNotExists(extensionName) {\n    this.pushQuery(`create extension if not exists ${this.formatter.wrap(extensionName)}`);\n  }\n\n}\n\nmodule.exports = SchemaCompiler_PG;","map":{"version":3,"sources":["/home/rosiane/Projeto-completo/back/node_modules/knex/lib/dialects/postgres/schema/pg-compiler.js"],"names":["SchemaCompiler","require","SchemaCompiler_PG","constructor","client","builder","hasTable","tableName","sql","bindings","schema","push","pushQuery","output","resp","rows","length","hasColumn","columnName","qualifiedTableName","name","formatter","wrap","renameTable","from","to","createSchema","schemaName","createSchemaIfNotExists","dropSchema","dropSchemaIfExists","dropExtension","extensionName","dropExtensionIfExists","createExtension","createExtensionIfNotExists","module","exports"],"mappings":"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","sourcesContent":["// PostgreSQL Schema Compiler\n// -------\n\nconst SchemaCompiler = require('../../../schema/compiler');\n\nclass SchemaCompiler_PG extends SchemaCompiler {\n  constructor(client, builder) {\n    super(client, builder);\n  }\n\n  // Check whether the current table\n  hasTable(tableName) {\n    let sql = 'select * from information_schema.tables where table_name = ?';\n    const bindings = [tableName];\n\n    if (this.schema) {\n      sql += ' and table_schema = ?';\n      bindings.push(this.schema);\n    } else {\n      sql += ' and table_schema = current_schema()';\n    }\n\n    this.pushQuery({\n      sql,\n      bindings,\n      output(resp) {\n        return resp.rows.length > 0;\n      },\n    });\n  }\n\n  // Compile the query to determine if a column exists in a table.\n  hasColumn(tableName, columnName) {\n    let sql =\n      'select * from information_schema.columns where table_name = ? and column_name = ?';\n    const bindings = [tableName, columnName];\n\n    if (this.schema) {\n      sql += ' and table_schema = ?';\n      bindings.push(this.schema);\n    } else {\n      sql += ' and table_schema = current_schema()';\n    }\n\n    this.pushQuery({\n      sql,\n      bindings,\n      output(resp) {\n        return resp.rows.length > 0;\n      },\n    });\n  }\n\n  qualifiedTableName(tableName) {\n    const name = this.schema ? `${this.schema}.${tableName}` : tableName;\n    return this.formatter.wrap(name);\n  }\n\n  // Compile a rename table command.\n  renameTable(from, to) {\n    this.pushQuery(\n      `alter table ${this.qualifiedTableName(\n        from\n      )} rename to ${this.formatter.wrap(to)}`\n    );\n  }\n\n  createSchema(schemaName) {\n    this.pushQuery(`create schema ${this.formatter.wrap(schemaName)}`);\n  }\n\n  createSchemaIfNotExists(schemaName) {\n    this.pushQuery(\n      `create schema if not exists ${this.formatter.wrap(schemaName)}`\n    );\n  }\n\n  dropSchema(schemaName) {\n    this.pushQuery(`drop schema ${this.formatter.wrap(schemaName)}`);\n  }\n\n  dropSchemaIfExists(schemaName) {\n    this.pushQuery(`drop schema if exists ${this.formatter.wrap(schemaName)}`);\n  }\n\n  dropExtension(extensionName) {\n    this.pushQuery(`drop extension ${this.formatter.wrap(extensionName)}`);\n  }\n\n  dropExtensionIfExists(extensionName) {\n    this.pushQuery(\n      `drop extension if exists ${this.formatter.wrap(extensionName)}`\n    );\n  }\n\n  createExtension(extensionName) {\n    this.pushQuery(`create extension ${this.formatter.wrap(extensionName)}`);\n  }\n\n  createExtensionIfNotExists(extensionName) {\n    this.pushQuery(\n      `create extension if not exists ${this.formatter.wrap(extensionName)}`\n    );\n  }\n}\n\nmodule.exports = SchemaCompiler_PG;\n"]},"metadata":{},"sourceType":"script"}