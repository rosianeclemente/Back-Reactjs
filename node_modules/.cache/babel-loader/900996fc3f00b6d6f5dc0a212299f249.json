{"ast":null,"code":"const {\n  KnexTimeoutError\n} = require('../util/timeout');\n\nconst {\n  timeout\n} = require('../util/timeout');\n\nconst {\n  ensureConnectionCallback,\n  ensureConnectionStreamCallback\n} = require('./internal/ensure-connection-callback');\n\nlet Transform; // The \"Runner\" constructor takes a \"builder\" (query, schema, or raw)\n// and runs through each of the query statements, calling any additional\n// \"output\" method provided alongside the query and bindings.\n\nclass Runner {\n  constructor(client, builder) {\n    this.client = client;\n    this.builder = builder;\n    this.queries = []; // The \"connection\" object is set on the runner when\n    // \"run\" is called.\n\n    this.connection = undefined;\n  } // \"Run\" the target, calling \"toSQL\" on the builder, returning\n  // an object or array of queries to run, each of which are run on\n  // a single connection.\n\n\n  async run() {\n    const runner = this;\n\n    try {\n      const res = await this.ensureConnection(ensureConnectionCallback); // Fire a single \"end\" event on the builder when\n      // all queries have successfully completed.\n\n      runner.builder.emit('end');\n      return res; // If there are any \"error\" listeners, we fire an error event\n      // and then re-throw the error to be eventually handled by\n      // the promise chain. Useful if you're wrapping in a custom `Promise`.\n    } catch (err) {\n      if (runner.builder._events && runner.builder._events.error) {\n        runner.builder.emit('error', err);\n      }\n\n      throw err;\n    }\n  } // Stream the result set, by passing through to the dialect's streaming\n  // capabilities. If the options are\n\n\n  stream(optionsOrHandler, handlerOrNil) {\n    const firstOptionIsHandler = typeof optionsOrHandler === 'function' && arguments.length === 1;\n    const options = firstOptionIsHandler ? {} : optionsOrHandler;\n    const handler = firstOptionIsHandler ? optionsOrHandler : handlerOrNil; // Determines whether we emit an error or throw here.\n\n    const hasHandler = typeof handler === 'function'; // Lazy-load the \"Transform\" dependency.\n\n    Transform = Transform || require('stream').Transform;\n    const queryContext = this.builder.queryContext();\n    let queryStream;\n    const stream = new Transform({\n      objectMode: true,\n      transform: (chunk, _, callback) => {\n        callback(null, this.client.postProcessResponse(chunk, queryContext));\n      },\n\n      destroy() {\n        // For some reason destroy is not available for mssql on Node 14. Might be a problem with tedious: https://github.com/tediousjs/tedious/issues/1139\n        if (queryStream && queryStream.destroy) {\n          queryStream.destroy(new Error('stream destroyed'));\n        }\n      }\n\n    });\n    stream.on('pipe', qs => {\n      queryStream = qs;\n    });\n    const connectionAcquirePromise = this.ensureConnection(ensureConnectionStreamCallback, {\n      options,\n      hasHandler,\n      stream\n    }) // Emit errors on the stream if the error occurred before a connection\n    // could be acquired.\n    // If the connection was acquired, assume the error occurred in the client\n    // code and has already been emitted on the stream. Don't emit it twice.\n    .catch(err => {\n      if (!this.connection) {\n        stream.emit('error', err);\n      }\n    }); // If a function is passed to handle the stream, send the stream\n    // there and return the promise, otherwise just return the stream\n    // and the promise will take care of itself.\n\n    if (hasHandler) {\n      handler(stream);\n      return connectionAcquirePromise;\n    }\n\n    return stream;\n  } // Allow you to pipe the stream to a writable stream.\n\n\n  pipe(writable, options) {\n    return this.stream(options).pipe(writable);\n  } // \"Runs\" a query, returning a promise. All queries specified by the builder are guaranteed\n  // to run in sequence, and on the same connection, especially helpful when schema building\n  // and dealing with foreign key constraints, etc.\n\n\n  async query(obj) {\n    const {\n      __knexUid,\n      __knexTxId\n    } = this.connection;\n    this.builder.emit('query', Object.assign({\n      __knexUid,\n      __knexTxId\n    }, obj));\n    const runner = this;\n    const queryContext = this.builder.queryContext(); // query-error events are emitted before the queryPromise continuations.\n    // pass queryContext into client.query so it can be raised properly.\n\n    if (obj !== null && typeof obj === 'object') {\n      obj.queryContext = queryContext;\n    }\n\n    let queryPromise = this.client.query(this.connection, obj);\n\n    if (obj.timeout) {\n      queryPromise = timeout(queryPromise, obj.timeout);\n    } // Await the return value of client.processResponse; in the case of sqlite3's\n    // dropColumn()/renameColumn(), it will be a Promise for the transaction\n    // containing the complete rename procedure.\n\n\n    return queryPromise.then(resp => this.client.processResponse(resp, runner)).then(processedResponse => {\n      const postProcessedResponse = this.client.postProcessResponse(processedResponse, queryContext);\n      this.builder.emit('query-response', postProcessedResponse, Object.assign({\n        __knexUid,\n        __knexTxId\n      }, obj), this.builder);\n      this.client.emit('query-response', postProcessedResponse, Object.assign({\n        __knexUid,\n        __knexTxId\n      }, obj), this.builder);\n      return postProcessedResponse;\n    }).catch(error => {\n      if (!(error instanceof KnexTimeoutError)) {\n        return Promise.reject(error);\n      }\n\n      const {\n        timeout,\n        sql,\n        bindings\n      } = obj;\n      let cancelQuery;\n\n      if (obj.cancelOnTimeout) {\n        cancelQuery = this.client.cancelQuery(this.connection);\n      } else {\n        // If we don't cancel the query, we need to mark the connection as disposed so that\n        // it gets destroyed by the pool and is never used again. If we don't do this and\n        // return the connection to the pool, it will be useless until the current operation\n        // that timed out, finally finishes.\n        this.connection.__knex__disposed = error;\n        cancelQuery = Promise.resolve();\n      }\n\n      return cancelQuery.catch(cancelError => {\n        // If the cancellation failed, we need to mark the connection as disposed so that\n        // it gets destroyed by the pool and is never used again. If we don't do this and\n        // return the connection to the pool, it will be useless until the current operation\n        // that timed out, finally finishes.\n        this.connection.__knex__disposed = error; // cancellation failed\n\n        throw Object.assign(cancelError, {\n          message: `After query timeout of ${timeout}ms exceeded, cancelling of query failed.`,\n          sql,\n          bindings,\n          timeout\n        });\n      }).then(() => {\n        // cancellation succeeded, rethrow timeout error\n        throw Object.assign(error, {\n          message: `Defined query timeout of ${timeout}ms exceeded when running query.`,\n          sql,\n          bindings,\n          timeout\n        });\n      });\n    }).catch(error => {\n      this.builder.emit('query-error', error, Object.assign({\n        __knexUid,\n        __knexTxId,\n        queryContext\n      }, obj));\n      throw error;\n    });\n  } // In the case of the \"schema builder\" we call `queryArray`, which runs each\n  // of the queries in sequence.\n\n\n  async queryArray(queries) {\n    if (queries.length === 1) {\n      const query = queries[0];\n\n      if (!query.statementsProducer) {\n        return this.query(query);\n      }\n\n      const statements = await query.statementsProducer(undefined, this.connection);\n      const queryObjects = statements.map(statement => ({\n        sql: statement,\n        bindings: query.bindings\n      }));\n      return this.queryArray(queryObjects);\n    }\n\n    const results = [];\n\n    for (const query of queries) {\n      results.push(await this.query(query));\n    }\n\n    return results;\n  } // Check whether there's a transaction flag, and that it has a connection.\n\n\n  async ensureConnection(cb, cbParams) {\n    // Use override from a builder if passed\n    if (this.builder._connection) {\n      this.connection = this.builder._connection;\n    }\n\n    if (this.connection) {\n      return cb(this, cbParams);\n    }\n\n    let acquiredConnection;\n\n    try {\n      acquiredConnection = await this.client.acquireConnection();\n    } catch (error) {\n      if (!(error instanceof KnexTimeoutError)) {\n        return Promise.reject(error);\n      }\n\n      if (this.builder) {\n        error.sql = this.builder.sql;\n        error.bindings = this.builder.bindings;\n      }\n\n      throw error;\n    }\n\n    try {\n      this.connection = acquiredConnection;\n      return await cb(this, cbParams);\n    } finally {\n      await this.client.releaseConnection(acquiredConnection);\n    }\n  }\n\n}\n\nmodule.exports = Runner;","map":{"version":3,"sources":["/home/rosiane/Projeto-completo/back/node_modules/knex/lib/execution/runner.js"],"names":["KnexTimeoutError","require","timeout","ensureConnectionCallback","ensureConnectionStreamCallback","Transform","Runner","constructor","client","builder","queries","connection","undefined","run","runner","res","ensureConnection","emit","err","_events","error","stream","optionsOrHandler","handlerOrNil","firstOptionIsHandler","arguments","length","options","handler","hasHandler","queryContext","queryStream","objectMode","transform","chunk","_","callback","postProcessResponse","destroy","Error","on","qs","connectionAcquirePromise","catch","pipe","writable","query","obj","__knexUid","__knexTxId","Object","assign","queryPromise","then","resp","processResponse","processedResponse","postProcessedResponse","Promise","reject","sql","bindings","cancelQuery","cancelOnTimeout","__knex__disposed","resolve","cancelError","message","queryArray","statementsProducer","statements","queryObjects","map","statement","results","push","cb","cbParams","_connection","acquiredConnection","acquireConnection","releaseConnection","module","exports"],"mappings":"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","sourcesContent":["const { KnexTimeoutError } = require('../util/timeout');\nconst { timeout } = require('../util/timeout');\nconst {\n  ensureConnectionCallback,\n  ensureConnectionStreamCallback,\n} = require('./internal/ensure-connection-callback');\n\nlet Transform;\n\n// The \"Runner\" constructor takes a \"builder\" (query, schema, or raw)\n// and runs through each of the query statements, calling any additional\n// \"output\" method provided alongside the query and bindings.\nclass Runner {\n  constructor(client, builder) {\n    this.client = client;\n    this.builder = builder;\n    this.queries = [];\n\n    // The \"connection\" object is set on the runner when\n    // \"run\" is called.\n    this.connection = undefined;\n  }\n\n  // \"Run\" the target, calling \"toSQL\" on the builder, returning\n  // an object or array of queries to run, each of which are run on\n  // a single connection.\n  async run() {\n    const runner = this;\n    try {\n      const res = await this.ensureConnection(ensureConnectionCallback);\n\n      // Fire a single \"end\" event on the builder when\n      // all queries have successfully completed.\n      runner.builder.emit('end');\n      return res;\n\n      // If there are any \"error\" listeners, we fire an error event\n      // and then re-throw the error to be eventually handled by\n      // the promise chain. Useful if you're wrapping in a custom `Promise`.\n    } catch (err) {\n      if (runner.builder._events && runner.builder._events.error) {\n        runner.builder.emit('error', err);\n      }\n      throw err;\n    }\n  }\n\n  // Stream the result set, by passing through to the dialect's streaming\n  // capabilities. If the options are\n  stream(optionsOrHandler, handlerOrNil) {\n    const firstOptionIsHandler =\n      typeof optionsOrHandler === 'function' && arguments.length === 1;\n\n    const options = firstOptionIsHandler ? {} : optionsOrHandler;\n    const handler = firstOptionIsHandler ? optionsOrHandler : handlerOrNil;\n\n    // Determines whether we emit an error or throw here.\n    const hasHandler = typeof handler === 'function';\n\n    // Lazy-load the \"Transform\" dependency.\n    Transform = Transform || require('stream').Transform;\n\n    const queryContext = this.builder.queryContext();\n    let queryStream;\n\n    const stream = new Transform({\n      objectMode: true,\n      transform: (chunk, _, callback) => {\n        callback(null, this.client.postProcessResponse(chunk, queryContext));\n      },\n      destroy() {\n        // For some reason destroy is not available for mssql on Node 14. Might be a problem with tedious: https://github.com/tediousjs/tedious/issues/1139\n        if (queryStream && queryStream.destroy) {\n          queryStream.destroy(new Error('stream destroyed'));\n        }\n      },\n    });\n    stream.on('pipe', (qs) => {\n      queryStream = qs;\n    });\n\n    const connectionAcquirePromise = this.ensureConnection(\n      ensureConnectionStreamCallback,\n      {\n        options,\n        hasHandler,\n        stream,\n      }\n    )\n      // Emit errors on the stream if the error occurred before a connection\n      // could be acquired.\n      // If the connection was acquired, assume the error occurred in the client\n      // code and has already been emitted on the stream. Don't emit it twice.\n      .catch((err) => {\n        if (!this.connection) {\n          stream.emit('error', err);\n        }\n      });\n\n    // If a function is passed to handle the stream, send the stream\n    // there and return the promise, otherwise just return the stream\n    // and the promise will take care of itself.\n    if (hasHandler) {\n      handler(stream);\n      return connectionAcquirePromise;\n    }\n    return stream;\n  }\n\n  // Allow you to pipe the stream to a writable stream.\n  pipe(writable, options) {\n    return this.stream(options).pipe(writable);\n  }\n\n  // \"Runs\" a query, returning a promise. All queries specified by the builder are guaranteed\n  // to run in sequence, and on the same connection, especially helpful when schema building\n  // and dealing with foreign key constraints, etc.\n  async query(obj) {\n    const { __knexUid, __knexTxId } = this.connection;\n\n    this.builder.emit('query', Object.assign({ __knexUid, __knexTxId }, obj));\n\n    const runner = this;\n    const queryContext = this.builder.queryContext();\n    // query-error events are emitted before the queryPromise continuations.\n    // pass queryContext into client.query so it can be raised properly.\n    if (obj !== null && typeof obj === 'object') {\n      obj.queryContext = queryContext;\n    }\n    let queryPromise = this.client.query(this.connection, obj);\n\n    if (obj.timeout) {\n      queryPromise = timeout(queryPromise, obj.timeout);\n    }\n\n    // Await the return value of client.processResponse; in the case of sqlite3's\n    // dropColumn()/renameColumn(), it will be a Promise for the transaction\n    // containing the complete rename procedure.\n    return queryPromise\n      .then((resp) => this.client.processResponse(resp, runner))\n      .then((processedResponse) => {\n        const postProcessedResponse = this.client.postProcessResponse(\n          processedResponse,\n          queryContext\n        );\n\n        this.builder.emit(\n          'query-response',\n          postProcessedResponse,\n          Object.assign({ __knexUid, __knexTxId }, obj),\n          this.builder\n        );\n\n        this.client.emit(\n          'query-response',\n          postProcessedResponse,\n          Object.assign({ __knexUid, __knexTxId }, obj),\n          this.builder\n        );\n\n        return postProcessedResponse;\n      })\n      .catch((error) => {\n        if (!(error instanceof KnexTimeoutError)) {\n          return Promise.reject(error);\n        }\n        const { timeout, sql, bindings } = obj;\n\n        let cancelQuery;\n        if (obj.cancelOnTimeout) {\n          cancelQuery = this.client.cancelQuery(this.connection);\n        } else {\n          // If we don't cancel the query, we need to mark the connection as disposed so that\n          // it gets destroyed by the pool and is never used again. If we don't do this and\n          // return the connection to the pool, it will be useless until the current operation\n          // that timed out, finally finishes.\n          this.connection.__knex__disposed = error;\n          cancelQuery = Promise.resolve();\n        }\n\n        return cancelQuery\n          .catch((cancelError) => {\n            // If the cancellation failed, we need to mark the connection as disposed so that\n            // it gets destroyed by the pool and is never used again. If we don't do this and\n            // return the connection to the pool, it will be useless until the current operation\n            // that timed out, finally finishes.\n            this.connection.__knex__disposed = error;\n\n            // cancellation failed\n            throw Object.assign(cancelError, {\n              message: `After query timeout of ${timeout}ms exceeded, cancelling of query failed.`,\n              sql,\n              bindings,\n              timeout,\n            });\n          })\n          .then(() => {\n            // cancellation succeeded, rethrow timeout error\n            throw Object.assign(error, {\n              message: `Defined query timeout of ${timeout}ms exceeded when running query.`,\n              sql,\n              bindings,\n              timeout,\n            });\n          });\n      })\n      .catch((error) => {\n        this.builder.emit(\n          'query-error',\n          error,\n          Object.assign({ __knexUid, __knexTxId, queryContext }, obj)\n        );\n        throw error;\n      });\n  }\n\n  // In the case of the \"schema builder\" we call `queryArray`, which runs each\n  // of the queries in sequence.\n  async queryArray(queries) {\n    if (queries.length === 1) {\n      const query = queries[0];\n\n      if (!query.statementsProducer) {\n        return this.query(query);\n      }\n\n      const statements = await query.statementsProducer(\n        undefined,\n        this.connection\n      );\n      const queryObjects = statements.map((statement) => ({\n        sql: statement,\n        bindings: query.bindings,\n      }));\n\n      return this.queryArray(queryObjects);\n    }\n\n    const results = [];\n    for (const query of queries) {\n      results.push(await this.query(query));\n    }\n    return results;\n  }\n\n  // Check whether there's a transaction flag, and that it has a connection.\n  async ensureConnection(cb, cbParams) {\n    // Use override from a builder if passed\n    if (this.builder._connection) {\n      this.connection = this.builder._connection;\n    }\n\n    if (this.connection) {\n      return cb(this, cbParams);\n    }\n\n    let acquiredConnection;\n    try {\n      acquiredConnection = await this.client.acquireConnection();\n    } catch (error) {\n      if (!(error instanceof KnexTimeoutError)) {\n        return Promise.reject(error);\n      }\n      if (this.builder) {\n        error.sql = this.builder.sql;\n        error.bindings = this.builder.bindings;\n      }\n      throw error;\n    }\n    try {\n      this.connection = acquiredConnection;\n      return await cb(this, cbParams);\n    } finally {\n      await this.client.releaseConnection(acquiredConnection);\n    }\n  }\n}\n\nmodule.exports = Runner;\n"]},"metadata":{},"sourceType":"script"}