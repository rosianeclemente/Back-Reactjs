{"ast":null,"code":"// Migrator\n// -------\nconst differenceWith = require('lodash/differenceWith');\n\nconst get = require('lodash/get');\n\nconst isEmpty = require('lodash/isEmpty');\n\nconst max = require('lodash/max');\n\nconst {\n  inherits\n} = require('util');\n\nconst {\n  getLockTableName,\n  getTable,\n  getTableName\n} = require('./table-resolver');\n\nconst {\n  getSchemaBuilder\n} = require('./table-creator');\n\nconst migrationListResolver = require('./migration-list-resolver');\n\nconst MigrationGenerator = require('./MigrationGenerator');\n\nconst {\n  getMergedConfig\n} = require('./configuration-merger');\n\nconst {\n  isBoolean,\n  isFunction\n} = require('../../util/is');\n\nfunction LockError(msg) {\n  this.name = 'MigrationLocked';\n  this.message = msg;\n}\n\ninherits(LockError, Error); // The new migration we're performing, typically called from the `knex.migrate`\n// interface on the main `knex` object. Passes the `knex` instance performing\n// the migration.\n\nclass Migrator {\n  constructor(knex) {\n    // Clone knex instance and remove post-processing that is unnecessary for internal queries from a cloned config\n    if (isFunction(knex)) {\n      if (!knex.isTransaction) {\n        this.knex = knex.withUserParams({ ...knex.userParams\n        });\n      } else {\n        this.knex = knex;\n      }\n    } else {\n      this.knex = Object.assign({}, knex);\n      this.knex.userParams = this.knex.userParams || {};\n    }\n\n    this.config = getMergedConfig(this.knex.client.config.migrations, undefined, this.knex.client.logger);\n    this.generator = new MigrationGenerator(this.knex.client.config.migrations, this.knex.client.logger);\n    this._activeMigration = {\n      fileName: null\n    };\n  } // Migrators to the latest configuration.\n\n\n  async latest(config) {\n    this._disableProcessing();\n\n    this.config = getMergedConfig(config, this.config, this.knex.client.logger);\n    const allAndCompleted = await migrationListResolver.listAllAndCompleted(this.config, this.knex);\n\n    if (!this.config.disableMigrationsListValidation) {\n      validateMigrationList(this.config.migrationSource, allAndCompleted);\n    }\n\n    const [all, completed] = allAndCompleted;\n    const migrations = getNewMigrations(this.config.migrationSource, all, completed);\n    const transactionForAll = !this.config.disableTransactions && !(await Promise.all(migrations.map(async migration => {\n      const migrationContents = await this.config.migrationSource.getMigration(migration);\n      return !this._useTransaction(migrationContents);\n    }))).some(isTransactionUsed => isTransactionUsed);\n\n    if (transactionForAll) {\n      return this.knex.transaction(trx => {\n        return this._runBatch(migrations, 'up', trx);\n      });\n    } else {\n      return this._runBatch(migrations, 'up');\n    }\n  } // Runs the next migration that has not yet been run\n\n\n  up(config) {\n    this._disableProcessing();\n\n    this.config = getMergedConfig(config, this.config, this.knex.client.logger);\n    return migrationListResolver.listAllAndCompleted(this.config, this.knex).then(value => {\n      if (!this.config.disableMigrationsListValidation) {\n        validateMigrationList(this.config.migrationSource, value);\n      }\n\n      return value;\n    }).then(([all, completed]) => {\n      const newMigrations = getNewMigrations(this.config.migrationSource, all, completed);\n      let migrationToRun;\n      const name = this.config.name;\n\n      if (name) {\n        if (!completed.includes(name)) {\n          migrationToRun = newMigrations.find(migration => {\n            return this.config.migrationSource.getMigrationName(migration) === name;\n          });\n\n          if (!migrationToRun) {\n            throw new Error(`Migration \"${name}\" not found.`);\n          }\n        }\n      } else {\n        migrationToRun = newMigrations[0];\n      }\n\n      return {\n        migrationToRun,\n        useTransaction: !migrationToRun || this._useTransaction(this.config.migrationSource.getMigration(migrationToRun))\n      };\n    }).then(({\n      migrationToRun,\n      useTransaction\n    }) => {\n      const migrationsToRun = [];\n\n      if (migrationToRun) {\n        migrationsToRun.push(migrationToRun);\n      }\n\n      const transactionForAll = !this.config.disableTransactions && (!migrationToRun || useTransaction);\n\n      if (transactionForAll) {\n        return this.knex.transaction(trx => {\n          return this._runBatch(migrationsToRun, 'up', trx);\n        });\n      } else {\n        return this._runBatch(migrationsToRun, 'up');\n      }\n    });\n  } // Rollback the last \"batch\", or all, of migrations that were run.\n\n\n  rollback(config, all = false) {\n    this._disableProcessing();\n\n    return new Promise((resolve, reject) => {\n      try {\n        this.config = getMergedConfig(config, this.config, this.knex.client.logger);\n      } catch (e) {\n        reject(e);\n      }\n\n      migrationListResolver.listAllAndCompleted(this.config, this.knex).then(value => {\n        if (!this.config.disableMigrationsListValidation) {\n          validateMigrationList(this.config.migrationSource, value);\n        }\n\n        return value;\n      }).then(val => {\n        const [allMigrations, completedMigrations] = val;\n        return all ? allMigrations.filter(migration => {\n          return completedMigrations.includes(this.config.migrationSource.getMigrationName(migration));\n        }).reverse() : this._getLastBatch(val);\n      }).then(migrations => {\n        return this._runBatch(migrations, 'down');\n      }).then(resolve, reject);\n    });\n  }\n\n  down(config) {\n    this._disableProcessing();\n\n    this.config = getMergedConfig(config, this.config, this.knex.client.logger);\n    return migrationListResolver.listAllAndCompleted(this.config, this.knex).then(value => {\n      if (!this.config.disableMigrationsListValidation) {\n        validateMigrationList(this.config.migrationSource, value);\n      }\n\n      return value;\n    }).then(([all, completed]) => {\n      const completedMigrations = all.filter(migration => {\n        return completed.includes(this.config.migrationSource.getMigrationName(migration));\n      });\n      let migrationToRun;\n      const name = this.config.name;\n\n      if (name) {\n        migrationToRun = completedMigrations.find(migration => {\n          return this.config.migrationSource.getMigrationName(migration) === name;\n        });\n\n        if (!migrationToRun) {\n          throw new Error(`Migration \"${name}\" was not run.`);\n        }\n      } else {\n        migrationToRun = completedMigrations[completedMigrations.length - 1];\n      }\n\n      const migrationsToRun = [];\n\n      if (migrationToRun) {\n        migrationsToRun.push(migrationToRun);\n      }\n\n      return this._runBatch(migrationsToRun, 'down');\n    });\n  }\n\n  status(config) {\n    this._disableProcessing();\n\n    this.config = getMergedConfig(config, this.config, this.knex.client.logger);\n    return Promise.all([getTable(this.knex, this.config.tableName, this.config.schemaName).select('*'), migrationListResolver.listAll(this.config.migrationSource)]).then(([db, code]) => db.length - code.length);\n  } // Retrieves and returns the current migration version we're on, as a promise.\n  // If no migrations have been run yet, return \"none\".\n\n\n  currentVersion(config) {\n    this._disableProcessing();\n\n    this.config = getMergedConfig(config, this.config, this.knex.client.logger);\n    return migrationListResolver.listCompleted(this.config.tableName, this.config.schemaName, this.knex).then(completed => {\n      const val = max(completed.map(value => value.split('_')[0]));\n      return val === undefined ? 'none' : val;\n    });\n  } // list all migrations\n\n\n  async list(config) {\n    this._disableProcessing();\n\n    this.config = getMergedConfig(config, this.config, this.knex.client.logger);\n    const [all, completed] = await migrationListResolver.listAllAndCompleted(this.config, this.knex);\n\n    if (!this.config.disableMigrationsListValidation) {\n      validateMigrationList(this.config.migrationSource, [all, completed]);\n    }\n\n    const newMigrations = getNewMigrations(this.config.migrationSource, all, completed);\n    return [completed, newMigrations];\n  }\n\n  async forceFreeMigrationsLock(config) {\n    this.config = getMergedConfig(config, this.config, this.knex.client.logger);\n    const {\n      schemaName,\n      tableName\n    } = this.config;\n    const lockTableName = getLockTableName(tableName);\n    const {\n      knex\n    } = this;\n\n    const getLockTable = () => getTable(knex, lockTableName, schemaName);\n\n    const tableExists = await getSchemaBuilder(knex, schemaName).hasTable(lockTableName);\n\n    if (tableExists) {\n      await getLockTable().del();\n      await getLockTable().insert({\n        is_locked: 0\n      });\n    }\n  } // Creates a new migration, with a given name.\n\n\n  make(name, config) {\n    return this.generator.make(name, config, this.knex.client.logger);\n  }\n\n  _disableProcessing() {\n    if (this.knex.disableProcessing) {\n      this.knex.disableProcessing();\n    }\n  }\n\n  _lockMigrations(trx) {\n    const tableName = getLockTableName(this.config.tableName);\n    return getTable(this.knex, tableName, this.config.schemaName).transacting(trx).where('is_locked', '=', 0).update({\n      is_locked: 1\n    }).then(rowCount => {\n      if (rowCount != 1) {\n        throw new Error('Migration table is already locked');\n      }\n    });\n  }\n\n  _getLock(trx) {\n    const transact = trx ? fn => fn(trx) : fn => this.knex.transaction(fn);\n    return transact(trx => {\n      return this._lockMigrations(trx);\n    }).catch(err => {\n      throw new LockError(err.message);\n    });\n  }\n\n  _freeLock(trx = this.knex) {\n    const tableName = getLockTableName(this.config.tableName);\n    return getTable(trx, tableName, this.config.schemaName).update({\n      is_locked: 0\n    });\n  } // Run a batch of current migrations, in sequence.\n\n\n  _runBatch(migrations, direction, trx) {\n    return this._getLock(trx) // When there is a wrapping transaction, some migrations\n    // could have been done while waiting for the lock:\n    .then(() => trx ? migrationListResolver.listCompleted(this.config.tableName, this.config.schemaName, trx) : []).then(completed => migrations = getNewMigrations(this.config.migrationSource, migrations, completed)).then(() => Promise.all(migrations.map(this._validateMigrationStructure.bind(this)))).then(() => this._latestBatchNumber(trx)).then(batchNo => {\n      if (direction === 'up') batchNo++;\n      return batchNo;\n    }).then(batchNo => {\n      return this._waterfallBatch(batchNo, migrations, direction, trx);\n    }).then(async res => {\n      await this._freeLock(trx);\n      return res;\n    }).catch(async error => {\n      let cleanupReady = Promise.resolve();\n\n      if (error instanceof LockError) {\n        // If locking error do not free the lock.\n        this.knex.client.logger.warn(`Can't take lock to run migrations: ${error.message}`);\n        this.knex.client.logger.warn('If you are sure migrations are not running you can release the ' + \"lock manually by running 'knex migrate:unlock'\");\n      } else {\n        if (this._activeMigration.fileName) {\n          this.knex.client.logger.warn(`migration file \"${this._activeMigration.fileName}\" failed`);\n        }\n\n        this.knex.client.logger.warn(`migration failed with error: ${error.message}`); // If the error was not due to a locking issue, then remove the lock.\n\n        cleanupReady = this._freeLock(trx);\n      }\n\n      try {\n        await cleanupReady; // eslint-disable-next-line no-empty\n      } catch (e) {}\n\n      throw error;\n    });\n  } // Validates some migrations by requiring and checking for an `up` and `down`\n  // function.\n\n\n  async _validateMigrationStructure(migration) {\n    const migrationName = this.config.migrationSource.getMigrationName(migration); // maybe promise\n\n    const migrationContent = await this.config.migrationSource.getMigration(migration);\n\n    if (typeof migrationContent.up !== 'function' || typeof migrationContent.down !== 'function') {\n      throw new Error(`Invalid migration: ${migrationName} must have both an up and down function`);\n    }\n\n    return migration;\n  } // Get the last batch of migrations, by name, ordered by insert id in reverse\n  // order.\n\n\n  async _getLastBatch([allMigrations]) {\n    const {\n      tableName,\n      schemaName\n    } = this.config;\n    const migrationNames = await getTable(this.knex, tableName, schemaName).where('batch', function (qb) {\n      qb.max('batch').from(getTableName(tableName, schemaName));\n    }).orderBy('id', 'desc');\n    const lastBatchMigrations = migrationNames.map(migration => {\n      return allMigrations.find(entry => {\n        return this.config.migrationSource.getMigrationName(entry) === migration.name;\n      });\n    });\n    return Promise.all(lastBatchMigrations);\n  } // Returns the latest batch number.\n\n\n  _latestBatchNumber(trx = this.knex) {\n    return trx.from(getTableName(this.config.tableName, this.config.schemaName)).max('batch as max_batch').then(obj => obj[0].max_batch || 0);\n  } // If transaction config for a single migration is defined, use that.\n  // Otherwise, rely on the common config. This allows enabling/disabling\n  // transaction for a single migration at will, regardless of the common\n  // config.\n\n\n  _useTransaction(migrationContent, allTransactionsDisabled) {\n    const singleTransactionValue = get(migrationContent, 'config.transaction');\n    return isBoolean(singleTransactionValue) ? singleTransactionValue : !allTransactionsDisabled;\n  } // Runs a batch of `migrations` in a specified `direction`, saving the\n  // appropriate database information as the migrations are run.\n\n\n  _waterfallBatch(batchNo, migrations, direction, trx) {\n    const trxOrKnex = trx || this.knex;\n    const {\n      tableName,\n      schemaName,\n      disableTransactions\n    } = this.config;\n    let current = Promise.resolve();\n    const log = [];\n    migrations.forEach(migration => {\n      const name = this.config.migrationSource.getMigrationName(migration);\n      this._activeMigration.fileName = name;\n      const migrationContent = this.config.migrationSource.getMigration(migration); // We're going to run each of the migrations in the current \"up\".\n\n      current = current.then(async () => await migrationContent) //maybe promise\n      .then(migrationContent => {\n        this._activeMigration.fileName = name;\n\n        if (!trx && this._useTransaction(migrationContent, disableTransactions)) {\n          this.knex.enableProcessing();\n          return this._transaction(this.knex, migrationContent, direction, name);\n        }\n\n        trxOrKnex.enableProcessing();\n        return checkPromise(this.knex.client.logger, migrationContent[direction](trxOrKnex), name);\n      }).then(() => {\n        trxOrKnex.disableProcessing();\n        this.knex.disableProcessing();\n        log.push(name);\n\n        if (direction === 'up') {\n          return trxOrKnex.into(getTableName(tableName, schemaName)).insert({\n            name,\n            batch: batchNo,\n            migration_time: new Date()\n          });\n        }\n\n        if (direction === 'down') {\n          return trxOrKnex.from(getTableName(tableName, schemaName)).where({\n            name\n          }).del();\n        }\n      });\n    });\n    return current.then(() => [batchNo, log]);\n  }\n\n  _transaction(knex, migrationContent, direction, name) {\n    return knex.transaction(trx => {\n      return checkPromise(knex.client.logger, migrationContent[direction](trx), name, () => {\n        trx.commit();\n      });\n    });\n  }\n\n} // Validates that migrations are present in the appropriate directories.\n\n\nfunction validateMigrationList(migrationSource, migrations) {\n  const [all, completed] = migrations;\n  const diff = getMissingMigrations(migrationSource, completed, all);\n\n  if (!isEmpty(diff)) {\n    throw new Error(`The migration directory is corrupt, the following files are missing: ${diff.join(', ')}`);\n  }\n}\n\nfunction getMissingMigrations(migrationSource, completed, all) {\n  return differenceWith(completed, all, (completedMigration, allMigration) => {\n    return completedMigration === migrationSource.getMigrationName(allMigration);\n  });\n}\n\nfunction getNewMigrations(migrationSource, all, completed) {\n  return differenceWith(all, completed, (allMigration, completedMigration) => {\n    return completedMigration === migrationSource.getMigrationName(allMigration);\n  });\n}\n\nfunction checkPromise(logger, migrationPromise, name, commitFn) {\n  if (!migrationPromise || typeof migrationPromise.then !== 'function') {\n    logger.warn(`migration ${name} did not return a promise`);\n\n    if (commitFn) {\n      commitFn();\n    }\n  }\n\n  return migrationPromise;\n}\n\nmodule.exports = {\n  Migrator\n};","map":{"version":3,"sources":["/home/rosiane/Projeto-completo/back/node_modules/knex/lib/migrations/migrate/Migrator.js"],"names":["differenceWith","require","get","isEmpty","max","inherits","getLockTableName","getTable","getTableName","getSchemaBuilder","migrationListResolver","MigrationGenerator","getMergedConfig","isBoolean","isFunction","LockError","msg","name","message","Error","Migrator","constructor","knex","isTransaction","withUserParams","userParams","Object","assign","config","client","migrations","undefined","logger","generator","_activeMigration","fileName","latest","_disableProcessing","allAndCompleted","listAllAndCompleted","disableMigrationsListValidation","validateMigrationList","migrationSource","all","completed","getNewMigrations","transactionForAll","disableTransactions","Promise","map","migration","migrationContents","getMigration","_useTransaction","some","isTransactionUsed","transaction","trx","_runBatch","up","then","value","newMigrations","migrationToRun","includes","find","getMigrationName","useTransaction","migrationsToRun","push","rollback","resolve","reject","e","val","allMigrations","completedMigrations","filter","reverse","_getLastBatch","down","length","status","tableName","schemaName","select","listAll","db","code","currentVersion","listCompleted","split","list","forceFreeMigrationsLock","lockTableName","getLockTable","tableExists","hasTable","del","insert","is_locked","make","disableProcessing","_lockMigrations","transacting","where","update","rowCount","_getLock","transact","fn","catch","err","_freeLock","direction","_validateMigrationStructure","bind","_latestBatchNumber","batchNo","_waterfallBatch","res","error","cleanupReady","warn","migrationName","migrationContent","migrationNames","qb","from","orderBy","lastBatchMigrations","entry","obj","max_batch","allTransactionsDisabled","singleTransactionValue","trxOrKnex","current","log","forEach","enableProcessing","_transaction","checkPromise","into","batch","migration_time","Date","commit","diff","getMissingMigrations","join","completedMigration","allMigration","migrationPromise","commitFn","module","exports"],"mappings":"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","sourcesContent":["// Migrator\n// -------\nconst differenceWith = require('lodash/differenceWith');\nconst get = require('lodash/get');\nconst isEmpty = require('lodash/isEmpty');\nconst max = require('lodash/max');\nconst { inherits } = require('util');\nconst {\n  getLockTableName,\n  getTable,\n  getTableName,\n} = require('./table-resolver');\nconst { getSchemaBuilder } = require('./table-creator');\nconst migrationListResolver = require('./migration-list-resolver');\nconst MigrationGenerator = require('./MigrationGenerator');\nconst { getMergedConfig } = require('./configuration-merger');\nconst { isBoolean, isFunction } = require('../../util/is');\n\nfunction LockError(msg) {\n  this.name = 'MigrationLocked';\n  this.message = msg;\n}\n\ninherits(LockError, Error);\n\n// The new migration we're performing, typically called from the `knex.migrate`\n// interface on the main `knex` object. Passes the `knex` instance performing\n// the migration.\nclass Migrator {\n  constructor(knex) {\n    // Clone knex instance and remove post-processing that is unnecessary for internal queries from a cloned config\n    if (isFunction(knex)) {\n      if (!knex.isTransaction) {\n        this.knex = knex.withUserParams({\n          ...knex.userParams,\n        });\n      } else {\n        this.knex = knex;\n      }\n    } else {\n      this.knex = Object.assign({}, knex);\n      this.knex.userParams = this.knex.userParams || {};\n    }\n\n    this.config = getMergedConfig(\n      this.knex.client.config.migrations,\n      undefined,\n      this.knex.client.logger\n    );\n    this.generator = new MigrationGenerator(\n      this.knex.client.config.migrations,\n      this.knex.client.logger\n    );\n    this._activeMigration = {\n      fileName: null,\n    };\n  }\n\n  // Migrators to the latest configuration.\n  async latest(config) {\n    this._disableProcessing();\n    this.config = getMergedConfig(config, this.config, this.knex.client.logger);\n\n    const allAndCompleted = await migrationListResolver.listAllAndCompleted(\n      this.config,\n      this.knex\n    );\n\n    if (!this.config.disableMigrationsListValidation) {\n      validateMigrationList(this.config.migrationSource, allAndCompleted);\n    }\n\n    const [all, completed] = allAndCompleted;\n\n    const migrations = getNewMigrations(\n      this.config.migrationSource,\n      all,\n      completed\n    );\n\n    const transactionForAll =\n      !this.config.disableTransactions &&\n      !(\n        await Promise.all(\n          migrations.map(async (migration) => {\n            const migrationContents = await this.config.migrationSource.getMigration(\n              migration\n            );\n            return !this._useTransaction(migrationContents);\n          })\n        )\n      ).some((isTransactionUsed) => isTransactionUsed);\n\n    if (transactionForAll) {\n      return this.knex.transaction((trx) => {\n        return this._runBatch(migrations, 'up', trx);\n      });\n    } else {\n      return this._runBatch(migrations, 'up');\n    }\n  }\n\n  // Runs the next migration that has not yet been run\n  up(config) {\n    this._disableProcessing();\n    this.config = getMergedConfig(config, this.config, this.knex.client.logger);\n\n    return migrationListResolver\n      .listAllAndCompleted(this.config, this.knex)\n      .then((value) => {\n        if (!this.config.disableMigrationsListValidation) {\n          validateMigrationList(this.config.migrationSource, value);\n        }\n        return value;\n      })\n      .then(([all, completed]) => {\n        const newMigrations = getNewMigrations(\n          this.config.migrationSource,\n          all,\n          completed\n        );\n\n        let migrationToRun;\n        const name = this.config.name;\n        if (name) {\n          if (!completed.includes(name)) {\n            migrationToRun = newMigrations.find((migration) => {\n              return (\n                this.config.migrationSource.getMigrationName(migration) === name\n              );\n            });\n            if (!migrationToRun) {\n              throw new Error(`Migration \"${name}\" not found.`);\n            }\n          }\n        } else {\n          migrationToRun = newMigrations[0];\n        }\n\n        return {\n          migrationToRun,\n          useTransaction:\n            !migrationToRun ||\n            this._useTransaction(\n              this.config.migrationSource.getMigration(migrationToRun)\n            ),\n        };\n      })\n      .then(({ migrationToRun, useTransaction }) => {\n        const migrationsToRun = [];\n        if (migrationToRun) {\n          migrationsToRun.push(migrationToRun);\n        }\n\n        const transactionForAll =\n          !this.config.disableTransactions &&\n          (!migrationToRun || useTransaction);\n\n        if (transactionForAll) {\n          return this.knex.transaction((trx) => {\n            return this._runBatch(migrationsToRun, 'up', trx);\n          });\n        } else {\n          return this._runBatch(migrationsToRun, 'up');\n        }\n      });\n  }\n\n  // Rollback the last \"batch\", or all, of migrations that were run.\n  rollback(config, all = false) {\n    this._disableProcessing();\n    return new Promise((resolve, reject) => {\n      try {\n        this.config = getMergedConfig(\n          config,\n          this.config,\n          this.knex.client.logger\n        );\n      } catch (e) {\n        reject(e);\n      }\n      migrationListResolver\n        .listAllAndCompleted(this.config, this.knex)\n        .then((value) => {\n          if (!this.config.disableMigrationsListValidation) {\n            validateMigrationList(this.config.migrationSource, value);\n          }\n          return value;\n        })\n        .then((val) => {\n          const [allMigrations, completedMigrations] = val;\n\n          return all\n            ? allMigrations\n                .filter((migration) => {\n                  return completedMigrations.includes(\n                    this.config.migrationSource.getMigrationName(migration)\n                  );\n                })\n                .reverse()\n            : this._getLastBatch(val);\n        })\n        .then((migrations) => {\n          return this._runBatch(migrations, 'down');\n        })\n        .then(resolve, reject);\n    });\n  }\n\n  down(config) {\n    this._disableProcessing();\n    this.config = getMergedConfig(config, this.config, this.knex.client.logger);\n\n    return migrationListResolver\n      .listAllAndCompleted(this.config, this.knex)\n      .then((value) => {\n        if (!this.config.disableMigrationsListValidation) {\n          validateMigrationList(this.config.migrationSource, value);\n        }\n        return value;\n      })\n      .then(([all, completed]) => {\n        const completedMigrations = all.filter((migration) => {\n          return completed.includes(\n            this.config.migrationSource.getMigrationName(migration)\n          );\n        });\n\n        let migrationToRun;\n        const name = this.config.name;\n        if (name) {\n          migrationToRun = completedMigrations.find((migration) => {\n            return (\n              this.config.migrationSource.getMigrationName(migration) === name\n            );\n          });\n          if (!migrationToRun) {\n            throw new Error(`Migration \"${name}\" was not run.`);\n          }\n        } else {\n          migrationToRun = completedMigrations[completedMigrations.length - 1];\n        }\n\n        const migrationsToRun = [];\n        if (migrationToRun) {\n          migrationsToRun.push(migrationToRun);\n        }\n\n        return this._runBatch(migrationsToRun, 'down');\n      });\n  }\n\n  status(config) {\n    this._disableProcessing();\n    this.config = getMergedConfig(config, this.config, this.knex.client.logger);\n\n    return Promise.all([\n      getTable(this.knex, this.config.tableName, this.config.schemaName).select(\n        '*'\n      ),\n      migrationListResolver.listAll(this.config.migrationSource),\n    ]).then(([db, code]) => db.length - code.length);\n  }\n\n  // Retrieves and returns the current migration version we're on, as a promise.\n  // If no migrations have been run yet, return \"none\".\n  currentVersion(config) {\n    this._disableProcessing();\n    this.config = getMergedConfig(config, this.config, this.knex.client.logger);\n\n    return migrationListResolver\n      .listCompleted(this.config.tableName, this.config.schemaName, this.knex)\n      .then((completed) => {\n        const val = max(completed.map((value) => value.split('_')[0]));\n        return val === undefined ? 'none' : val;\n      });\n  }\n\n  // list all migrations\n  async list(config) {\n    this._disableProcessing();\n    this.config = getMergedConfig(config, this.config, this.knex.client.logger);\n\n    const [all, completed] = await migrationListResolver.listAllAndCompleted(\n      this.config,\n      this.knex\n    );\n\n    if (!this.config.disableMigrationsListValidation) {\n      validateMigrationList(this.config.migrationSource, [all, completed]);\n    }\n\n    const newMigrations = getNewMigrations(\n      this.config.migrationSource,\n      all,\n      completed\n    );\n    return [completed, newMigrations];\n  }\n\n  async forceFreeMigrationsLock(config) {\n    this.config = getMergedConfig(config, this.config, this.knex.client.logger);\n    const { schemaName, tableName } = this.config;\n    const lockTableName = getLockTableName(tableName);\n    const { knex } = this;\n    const getLockTable = () => getTable(knex, lockTableName, schemaName);\n    const tableExists = await getSchemaBuilder(knex, schemaName).hasTable(\n      lockTableName\n    );\n    if (tableExists) {\n      await getLockTable().del();\n      await getLockTable().insert({\n        is_locked: 0,\n      });\n    }\n  }\n\n  // Creates a new migration, with a given name.\n  make(name, config) {\n    return this.generator.make(name, config, this.knex.client.logger);\n  }\n\n  _disableProcessing() {\n    if (this.knex.disableProcessing) {\n      this.knex.disableProcessing();\n    }\n  }\n\n  _lockMigrations(trx) {\n    const tableName = getLockTableName(this.config.tableName);\n    return getTable(this.knex, tableName, this.config.schemaName)\n      .transacting(trx)\n      .where('is_locked', '=', 0)\n      .update({ is_locked: 1 })\n      .then((rowCount) => {\n        if (rowCount != 1) {\n          throw new Error('Migration table is already locked');\n        }\n      });\n  }\n\n  _getLock(trx) {\n    const transact = trx ? (fn) => fn(trx) : (fn) => this.knex.transaction(fn);\n    return transact((trx) => {\n      return this._lockMigrations(trx);\n    }).catch((err) => {\n      throw new LockError(err.message);\n    });\n  }\n\n  _freeLock(trx = this.knex) {\n    const tableName = getLockTableName(this.config.tableName);\n    return getTable(trx, tableName, this.config.schemaName).update({\n      is_locked: 0,\n    });\n  }\n\n  // Run a batch of current migrations, in sequence.\n  _runBatch(migrations, direction, trx) {\n    return (\n      this._getLock(trx)\n        // When there is a wrapping transaction, some migrations\n        // could have been done while waiting for the lock:\n        .then(() =>\n          trx\n            ? migrationListResolver.listCompleted(\n                this.config.tableName,\n                this.config.schemaName,\n                trx\n              )\n            : []\n        )\n        .then(\n          (completed) =>\n            (migrations = getNewMigrations(\n              this.config.migrationSource,\n              migrations,\n              completed\n            ))\n        )\n        .then(() =>\n          Promise.all(\n            migrations.map(this._validateMigrationStructure.bind(this))\n          )\n        )\n        .then(() => this._latestBatchNumber(trx))\n        .then((batchNo) => {\n          if (direction === 'up') batchNo++;\n          return batchNo;\n        })\n        .then((batchNo) => {\n          return this._waterfallBatch(batchNo, migrations, direction, trx);\n        })\n        .then(async (res) => {\n          await this._freeLock(trx);\n          return res;\n        })\n        .catch(async (error) => {\n          let cleanupReady = Promise.resolve();\n\n          if (error instanceof LockError) {\n            // If locking error do not free the lock.\n            this.knex.client.logger.warn(\n              `Can't take lock to run migrations: ${error.message}`\n            );\n            this.knex.client.logger.warn(\n              'If you are sure migrations are not running you can release the ' +\n                \"lock manually by running 'knex migrate:unlock'\"\n            );\n          } else {\n            if (this._activeMigration.fileName) {\n              this.knex.client.logger.warn(\n                `migration file \"${this._activeMigration.fileName}\" failed`\n              );\n            }\n            this.knex.client.logger.warn(\n              `migration failed with error: ${error.message}`\n            );\n            // If the error was not due to a locking issue, then remove the lock.\n            cleanupReady = this._freeLock(trx);\n          }\n\n          try {\n            await cleanupReady;\n            // eslint-disable-next-line no-empty\n          } catch (e) {}\n          throw error;\n        })\n    );\n  }\n\n  // Validates some migrations by requiring and checking for an `up` and `down`\n  // function.\n  async _validateMigrationStructure(migration) {\n    const migrationName = this.config.migrationSource.getMigrationName(\n      migration\n    );\n    // maybe promise\n    const migrationContent = await this.config.migrationSource.getMigration(\n      migration\n    );\n    if (\n      typeof migrationContent.up !== 'function' ||\n      typeof migrationContent.down !== 'function'\n    ) {\n      throw new Error(\n        `Invalid migration: ${migrationName} must have both an up and down function`\n      );\n    }\n\n    return migration;\n  }\n\n  // Get the last batch of migrations, by name, ordered by insert id in reverse\n  // order.\n  async _getLastBatch([allMigrations]) {\n    const { tableName, schemaName } = this.config;\n    const migrationNames = await getTable(this.knex, tableName, schemaName)\n      .where('batch', function (qb) {\n        qb.max('batch').from(getTableName(tableName, schemaName));\n      })\n      .orderBy('id', 'desc');\n\n    const lastBatchMigrations = migrationNames.map((migration) => {\n      return allMigrations.find((entry) => {\n        return (\n          this.config.migrationSource.getMigrationName(entry) === migration.name\n        );\n      });\n    });\n    return Promise.all(lastBatchMigrations);\n  }\n\n  // Returns the latest batch number.\n  _latestBatchNumber(trx = this.knex) {\n    return trx\n      .from(getTableName(this.config.tableName, this.config.schemaName))\n      .max('batch as max_batch')\n      .then((obj) => obj[0].max_batch || 0);\n  }\n\n  // If transaction config for a single migration is defined, use that.\n  // Otherwise, rely on the common config. This allows enabling/disabling\n  // transaction for a single migration at will, regardless of the common\n  // config.\n  _useTransaction(migrationContent, allTransactionsDisabled) {\n    const singleTransactionValue = get(migrationContent, 'config.transaction');\n\n    return isBoolean(singleTransactionValue)\n      ? singleTransactionValue\n      : !allTransactionsDisabled;\n  }\n\n  // Runs a batch of `migrations` in a specified `direction`, saving the\n  // appropriate database information as the migrations are run.\n  _waterfallBatch(batchNo, migrations, direction, trx) {\n    const trxOrKnex = trx || this.knex;\n    const { tableName, schemaName, disableTransactions } = this.config;\n    let current = Promise.resolve();\n    const log = [];\n    migrations.forEach((migration) => {\n      const name = this.config.migrationSource.getMigrationName(migration);\n      this._activeMigration.fileName = name;\n      const migrationContent = this.config.migrationSource.getMigration(\n        migration\n      );\n\n      // We're going to run each of the migrations in the current \"up\".\n      current = current\n        .then(async () => await migrationContent) //maybe promise\n        .then((migrationContent) => {\n          this._activeMigration.fileName = name;\n          if (\n            !trx &&\n            this._useTransaction(migrationContent, disableTransactions)\n          ) {\n            this.knex.enableProcessing();\n            return this._transaction(\n              this.knex,\n              migrationContent,\n              direction,\n              name\n            );\n          }\n\n          trxOrKnex.enableProcessing();\n          return checkPromise(\n            this.knex.client.logger,\n            migrationContent[direction](trxOrKnex),\n            name\n          );\n        })\n        .then(() => {\n          trxOrKnex.disableProcessing();\n          this.knex.disableProcessing();\n          log.push(name);\n          if (direction === 'up') {\n            return trxOrKnex.into(getTableName(tableName, schemaName)).insert({\n              name,\n              batch: batchNo,\n              migration_time: new Date(),\n            });\n          }\n          if (direction === 'down') {\n            return trxOrKnex\n              .from(getTableName(tableName, schemaName))\n              .where({ name })\n              .del();\n          }\n        });\n    });\n\n    return current.then(() => [batchNo, log]);\n  }\n\n  _transaction(knex, migrationContent, direction, name) {\n    return knex.transaction((trx) => {\n      return checkPromise(\n        knex.client.logger,\n        migrationContent[direction](trx),\n        name,\n        () => {\n          trx.commit();\n        }\n      );\n    });\n  }\n}\n\n// Validates that migrations are present in the appropriate directories.\nfunction validateMigrationList(migrationSource, migrations) {\n  const [all, completed] = migrations;\n  const diff = getMissingMigrations(migrationSource, completed, all);\n  if (!isEmpty(diff)) {\n    throw new Error(\n      `The migration directory is corrupt, the following files are missing: ${diff.join(\n        ', '\n      )}`\n    );\n  }\n}\n\nfunction getMissingMigrations(migrationSource, completed, all) {\n  return differenceWith(completed, all, (completedMigration, allMigration) => {\n    return (\n      completedMigration === migrationSource.getMigrationName(allMigration)\n    );\n  });\n}\n\nfunction getNewMigrations(migrationSource, all, completed) {\n  return differenceWith(all, completed, (allMigration, completedMigration) => {\n    return (\n      completedMigration === migrationSource.getMigrationName(allMigration)\n    );\n  });\n}\n\nfunction checkPromise(logger, migrationPromise, name, commitFn) {\n  if (!migrationPromise || typeof migrationPromise.then !== 'function') {\n    logger.warn(`migration ${name} did not return a promise`);\n    if (commitFn) {\n      commitFn();\n    }\n  }\n  return migrationPromise;\n}\n\nmodule.exports = {\n  Migrator,\n};\n"]},"metadata":{},"sourceType":"script"}