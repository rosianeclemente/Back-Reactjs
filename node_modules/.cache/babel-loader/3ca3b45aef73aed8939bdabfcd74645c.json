{"ast":null,"code":"const {\n  EventEmitter\n} = require('events');\n\nconst {\n  Migrator\n} = require('../migrations/migrate/Migrator');\n\nconst Seeder = require('../migrations/seed/Seeder');\n\nconst FunctionHelper = require('./FunctionHelper');\n\nconst QueryInterface = require('../query/method-constants');\n\nconst merge = require('lodash/merge');\n\nconst batchInsert = require('../execution/batch-insert');\n\nconst {\n  isObject\n} = require('../util/is'); // Javascript does not officially support \"callable objects\".  Instead,\n// you must create a regular Function and inject properties/methods\n// into it.  In other words: you can't leverage Prototype Inheritance\n// to share the property/method definitions.\n//\n// To work around this, we're creating an Object Property Definition.\n// This allow us to quickly inject everything into the `knex` function\n// via the `Object.defineProperties(..)` function.  More importantly,\n// it allows the same definitions to be shared across `knex` instances.\n\n\nconst KNEX_PROPERTY_DEFINITIONS = {\n  client: {\n    get() {\n      return this.context.client;\n    },\n\n    set(client) {\n      this.context.client = client;\n    },\n\n    configurable: true\n  },\n  userParams: {\n    get() {\n      return this.context.userParams;\n    },\n\n    set(userParams) {\n      this.context.userParams = userParams;\n    },\n\n    configurable: true\n  },\n  schema: {\n    get() {\n      return this.client.schemaBuilder();\n    },\n\n    configurable: true\n  },\n  migrate: {\n    get() {\n      return new Migrator(this);\n    },\n\n    configurable: true\n  },\n  seed: {\n    get() {\n      return new Seeder(this);\n    },\n\n    configurable: true\n  },\n  fn: {\n    get() {\n      return new FunctionHelper(this.client);\n    },\n\n    configurable: true\n  }\n}; // `knex` instances serve as proxies around `context` objects.  So, calling\n// any of these methods on the `knex` instance will forward the call to\n// the `knex.context` object. This ensures that `this` will correctly refer\n// to `context` within each of these methods.\n\nconst CONTEXT_METHODS = ['raw', 'batchInsert', 'transaction', 'transactionProvider', 'initialize', 'destroy', 'ref', 'withUserParams', 'queryBuilder', 'disableProcessing', 'enableProcessing'];\n\nfor (const m of CONTEXT_METHODS) {\n  KNEX_PROPERTY_DEFINITIONS[m] = {\n    value: function (...args) {\n      return this.context[m](...args);\n    },\n    configurable: true\n  };\n}\n\nfunction makeKnex(client) {\n  // The object we're potentially using to kick off an initial chain.\n  function knex(tableName, options) {\n    return createQueryBuilder(knex.context, tableName, options);\n  }\n\n  redefineProperties(knex, client);\n  return knex;\n}\n\nfunction initContext(knexFn) {\n  const knexContext = knexFn.context || {};\n  Object.assign(knexContext, {\n    queryBuilder() {\n      return this.client.queryBuilder();\n    },\n\n    raw() {\n      return this.client.raw.apply(this.client, arguments);\n    },\n\n    batchInsert(table, batch, chunkSize = 1000) {\n      return batchInsert(this, table, batch, chunkSize);\n    },\n\n    // Creates a new transaction.\n    // If container is provided, returns a promise for when the transaction is resolved.\n    // If container is not provided, returns a promise with a transaction that is resolved\n    // when transaction is ready to be used.\n    transaction(container, _config) {\n      // Overload support of `transaction(config)`\n      if (!_config && isObject(container)) {\n        _config = container;\n        container = null;\n      }\n\n      const config = Object.assign({}, _config);\n      config.userParams = this.userParams || {};\n\n      if (config.doNotRejectOnRollback === undefined) {\n        config.doNotRejectOnRollback = true;\n      }\n\n      return this._transaction(container, config);\n    },\n\n    // Internal method that actually establishes the Transaction.  It makes no assumptions\n    // about the `config` or `outerTx`, and expects the caller to handle these details.\n    _transaction(container, config, outerTx = null) {\n      if (container) {\n        const trx = this.client.transaction(container, config, outerTx);\n        return trx;\n      } else {\n        return new Promise((resolve, reject) => {\n          this.client.transaction(resolve, config, outerTx).catch(reject);\n        });\n      }\n    },\n\n    transactionProvider(config) {\n      let trx;\n      return () => {\n        if (!trx) {\n          trx = this.transaction(undefined, config);\n        }\n\n        return trx;\n      };\n    },\n\n    // Typically never needed, initializes the pool for a knex client.\n    initialize(config) {\n      return this.client.initializePool(config);\n    },\n\n    // Convenience method for tearing down the pool.\n    destroy(callback) {\n      return this.client.destroy(callback);\n    },\n\n    ref(ref) {\n      return this.client.ref(ref);\n    },\n\n    // Do not document this as public API until naming and API is improved for general consumption\n    // This method exists to disable processing of internal queries in migrations\n    disableProcessing() {\n      if (this.userParams.isProcessingDisabled) {\n        return;\n      }\n\n      this.userParams.wrapIdentifier = this.client.config.wrapIdentifier;\n      this.userParams.postProcessResponse = this.client.config.postProcessResponse;\n      this.client.config.wrapIdentifier = null;\n      this.client.config.postProcessResponse = null;\n      this.userParams.isProcessingDisabled = true;\n    },\n\n    // Do not document this as public API until naming and API is improved for general consumption\n    // This method exists to enable execution of non-internal queries with consistent identifier naming in migrations\n    enableProcessing() {\n      if (!this.userParams.isProcessingDisabled) {\n        return;\n      }\n\n      this.client.config.wrapIdentifier = this.userParams.wrapIdentifier;\n      this.client.config.postProcessResponse = this.userParams.postProcessResponse;\n      this.userParams.isProcessingDisabled = false;\n    },\n\n    withUserParams(params) {\n      const knexClone = shallowCloneFunction(knexFn); // We need to include getters in our clone\n\n      if (this.client) {\n        knexClone.client = Object.create(this.client.constructor.prototype); // Clone client to avoid leaking listeners that are set on it\n\n        merge(knexClone.client, this.client);\n        knexClone.client.config = Object.assign({}, this.client.config); // Clone client config to make sure they can be modified independently\n      }\n\n      redefineProperties(knexClone, knexClone.client);\n\n      _copyEventListeners('query', knexFn, knexClone);\n\n      _copyEventListeners('query-error', knexFn, knexClone);\n\n      _copyEventListeners('query-response', knexFn, knexClone);\n\n      _copyEventListeners('start', knexFn, knexClone);\n\n      knexClone.userParams = params;\n      return knexClone;\n    }\n\n  });\n\n  if (!knexFn.context) {\n    knexFn.context = knexContext;\n  }\n}\n\nfunction _copyEventListeners(eventName, sourceKnex, targetKnex) {\n  const listeners = sourceKnex.listeners(eventName);\n  listeners.forEach(listener => {\n    targetKnex.on(eventName, listener);\n  });\n}\n\nfunction redefineProperties(knex, client) {\n  // Allow chaining methods from the root object, before\n  // any other information is specified.\n  //\n  // TODO: `QueryBuilder.extend(..)` allows new QueryBuilder\n  //       methods to be introduced via external components.\n  //       As a side-effect, it also pushes the new method names\n  //       into the `QueryInterface` array.\n  //\n  //       The Problem: due to the way the code is currently\n  //       structured, these new methods cannot be retroactively\n  //       injected into existing `knex` instances!  As a result,\n  //       some `knex` instances will support the methods, and\n  //       others will not.\n  //\n  //       We should revisit this once we figure out the desired\n  //       behavior / usage.  For instance: do we really want to\n  //       allow external components to directly manipulate `knex`\n  //       data structures?  Or, should we come up w/ a different\n  //       approach that avoids side-effects / mutation?\n  //\n  //      (FYI: I noticed this issue because I attempted to integrate\n  //       this logic directly into the `KNEX_PROPERTY_DEFINITIONS`\n  //       construction.  However, `KNEX_PROPERTY_DEFINITIONS` is\n  //       constructed before any `knex` instances are created.\n  //       As a result, the method extensions were missing from all\n  //       `knex` instances.)\n  for (let i = 0; i < QueryInterface.length; i++) {\n    const method = QueryInterface[i];\n\n    knex[method] = function () {\n      const builder = this.queryBuilder();\n      return builder[method].apply(builder, arguments);\n    };\n  }\n\n  Object.defineProperties(knex, KNEX_PROPERTY_DEFINITIONS);\n  initContext(knex);\n  knex.client = client;\n  knex.userParams = {}; // Hook up the \"knex\" object as an EventEmitter.\n\n  const ee = new EventEmitter();\n\n  for (const key in ee) {\n    knex[key] = ee[key];\n  } // Unfortunately, something seems to be broken in Node 6 and removing events from a clone also mutates original Knex,\n  // which is highly undesirable\n\n\n  if (knex._internalListeners) {\n    knex._internalListeners.forEach(({\n      eventName,\n      listener\n    }) => {\n      knex.client.removeListener(eventName, listener); // Remove duplicates for copies\n    });\n  }\n\n  knex._internalListeners = []; // Passthrough all \"start\" and \"query\" events to the knex object.\n\n  _addInternalListener(knex, 'start', obj => {\n    knex.emit('start', obj);\n  });\n\n  _addInternalListener(knex, 'query', obj => {\n    knex.emit('query', obj);\n  });\n\n  _addInternalListener(knex, 'query-error', (err, obj) => {\n    knex.emit('query-error', err, obj);\n  });\n\n  _addInternalListener(knex, 'query-response', (response, obj, builder) => {\n    knex.emit('query-response', response, obj, builder);\n  });\n}\n\nfunction _addInternalListener(knex, eventName, listener) {\n  knex.client.on(eventName, listener);\n\n  knex._internalListeners.push({\n    eventName,\n    listener\n  });\n}\n\nfunction createQueryBuilder(knexContext, tableName, options) {\n  const qb = knexContext.queryBuilder();\n  if (!tableName) knexContext.client.logger.warn('calling knex without a tableName is deprecated. Use knex.queryBuilder() instead.');\n  return tableName ? qb.table(tableName, options) : qb;\n}\n\nfunction shallowCloneFunction(originalFunction) {\n  const fnContext = Object.create(Object.getPrototypeOf(originalFunction), Object.getOwnPropertyDescriptors(originalFunction));\n  const knexContext = {};\n\n  const knexFnWrapper = (tableName, options) => {\n    return createQueryBuilder(knexContext, tableName, options);\n  };\n\n  const clonedFunction = knexFnWrapper.bind(fnContext);\n  Object.assign(clonedFunction, originalFunction);\n  clonedFunction.context = knexContext;\n  return clonedFunction;\n}\n\nmodule.exports = makeKnex;","map":{"version":3,"sources":["/home/rosiane/Projeto-completo/back/node_modules/knex/lib/knex-builder/make-knex.js"],"names":["EventEmitter","require","Migrator","Seeder","FunctionHelper","QueryInterface","merge","batchInsert","isObject","KNEX_PROPERTY_DEFINITIONS","client","get","context","set","configurable","userParams","schema","schemaBuilder","migrate","seed","fn","CONTEXT_METHODS","m","value","args","makeKnex","knex","tableName","options","createQueryBuilder","redefineProperties","initContext","knexFn","knexContext","Object","assign","queryBuilder","raw","apply","arguments","table","batch","chunkSize","transaction","container","_config","config","doNotRejectOnRollback","undefined","_transaction","outerTx","trx","Promise","resolve","reject","catch","transactionProvider","initialize","initializePool","destroy","callback","ref","disableProcessing","isProcessingDisabled","wrapIdentifier","postProcessResponse","enableProcessing","withUserParams","params","knexClone","shallowCloneFunction","create","constructor","prototype","_copyEventListeners","eventName","sourceKnex","targetKnex","listeners","forEach","listener","on","i","length","method","builder","defineProperties","ee","key","_internalListeners","removeListener","_addInternalListener","obj","emit","err","response","push","qb","logger","warn","originalFunction","fnContext","getPrototypeOf","getOwnPropertyDescriptors","knexFnWrapper","clonedFunction","bind","module","exports"],"mappings":"AAAA,MAAM;AAAEA,EAAAA;AAAF,IAAmBC,OAAO,CAAC,QAAD,CAAhC;;AAEA,MAAM;AAAEC,EAAAA;AAAF,IAAeD,OAAO,CAAC,gCAAD,CAA5B;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,2BAAD,CAAtB;;AACA,MAAMG,cAAc,GAAGH,OAAO,CAAC,kBAAD,CAA9B;;AACA,MAAMI,cAAc,GAAGJ,OAAO,CAAC,2BAAD,CAA9B;;AACA,MAAMK,KAAK,GAAGL,OAAO,CAAC,cAAD,CAArB;;AACA,MAAMM,WAAW,GAAGN,OAAO,CAAC,2BAAD,CAA3B;;AACA,MAAM;AAAEO,EAAAA;AAAF,IAAeP,OAAO,CAAC,YAAD,CAA5B,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMQ,yBAAyB,GAAG;AAChCC,EAAAA,MAAM,EAAE;AACNC,IAAAA,GAAG,GAAG;AACJ,aAAO,KAAKC,OAAL,CAAaF,MAApB;AACD,KAHK;;AAING,IAAAA,GAAG,CAACH,MAAD,EAAS;AACV,WAAKE,OAAL,CAAaF,MAAb,GAAsBA,MAAtB;AACD,KANK;;AAONI,IAAAA,YAAY,EAAE;AAPR,GADwB;AAWhCC,EAAAA,UAAU,EAAE;AACVJ,IAAAA,GAAG,GAAG;AACJ,aAAO,KAAKC,OAAL,CAAaG,UAApB;AACD,KAHS;;AAIVF,IAAAA,GAAG,CAACE,UAAD,EAAa;AACd,WAAKH,OAAL,CAAaG,UAAb,GAA0BA,UAA1B;AACD,KANS;;AAOVD,IAAAA,YAAY,EAAE;AAPJ,GAXoB;AAqBhCE,EAAAA,MAAM,EAAE;AACNL,IAAAA,GAAG,GAAG;AACJ,aAAO,KAAKD,MAAL,CAAYO,aAAZ,EAAP;AACD,KAHK;;AAINH,IAAAA,YAAY,EAAE;AAJR,GArBwB;AA4BhCI,EAAAA,OAAO,EAAE;AACPP,IAAAA,GAAG,GAAG;AACJ,aAAO,IAAIT,QAAJ,CAAa,IAAb,CAAP;AACD,KAHM;;AAIPY,IAAAA,YAAY,EAAE;AAJP,GA5BuB;AAmChCK,EAAAA,IAAI,EAAE;AACJR,IAAAA,GAAG,GAAG;AACJ,aAAO,IAAIR,MAAJ,CAAW,IAAX,CAAP;AACD,KAHG;;AAIJW,IAAAA,YAAY,EAAE;AAJV,GAnC0B;AA0ChCM,EAAAA,EAAE,EAAE;AACFT,IAAAA,GAAG,GAAG;AACJ,aAAO,IAAIP,cAAJ,CAAmB,KAAKM,MAAxB,CAAP;AACD,KAHC;;AAIFI,IAAAA,YAAY,EAAE;AAJZ;AA1C4B,CAAlC,C,CAkDA;AACA;AACA;AACA;;AACA,MAAMO,eAAe,GAAG,CACtB,KADsB,EAEtB,aAFsB,EAGtB,aAHsB,EAItB,qBAJsB,EAKtB,YALsB,EAMtB,SANsB,EAOtB,KAPsB,EAQtB,gBARsB,EAStB,cATsB,EAUtB,mBAVsB,EAWtB,kBAXsB,CAAxB;;AAcA,KAAK,MAAMC,CAAX,IAAgBD,eAAhB,EAAiC;AAC/BZ,EAAAA,yBAAyB,CAACa,CAAD,CAAzB,GAA+B;AAC7BC,IAAAA,KAAK,EAAE,UAAU,GAAGC,IAAb,EAAmB;AACxB,aAAO,KAAKZ,OAAL,CAAaU,CAAb,EAAgB,GAAGE,IAAnB,CAAP;AACD,KAH4B;AAI7BV,IAAAA,YAAY,EAAE;AAJe,GAA/B;AAMD;;AAED,SAASW,QAAT,CAAkBf,MAAlB,EAA0B;AACxB;AACA,WAASgB,IAAT,CAAcC,SAAd,EAAyBC,OAAzB,EAAkC;AAChC,WAAOC,kBAAkB,CAACH,IAAI,CAACd,OAAN,EAAee,SAAf,EAA0BC,OAA1B,CAAzB;AACD;;AAEDE,EAAAA,kBAAkB,CAACJ,IAAD,EAAOhB,MAAP,CAAlB;AACA,SAAOgB,IAAP;AACD;;AAED,SAASK,WAAT,CAAqBC,MAArB,EAA6B;AAC3B,QAAMC,WAAW,GAAGD,MAAM,CAACpB,OAAP,IAAkB,EAAtC;AACAsB,EAAAA,MAAM,CAACC,MAAP,CAAcF,WAAd,EAA2B;AACzBG,IAAAA,YAAY,GAAG;AACb,aAAO,KAAK1B,MAAL,CAAY0B,YAAZ,EAAP;AACD,KAHwB;;AAKzBC,IAAAA,GAAG,GAAG;AACJ,aAAO,KAAK3B,MAAL,CAAY2B,GAAZ,CAAgBC,KAAhB,CAAsB,KAAK5B,MAA3B,EAAmC6B,SAAnC,CAAP;AACD,KAPwB;;AASzBhC,IAAAA,WAAW,CAACiC,KAAD,EAAQC,KAAR,EAAeC,SAAS,GAAG,IAA3B,EAAiC;AAC1C,aAAOnC,WAAW,CAAC,IAAD,EAAOiC,KAAP,EAAcC,KAAd,EAAqBC,SAArB,CAAlB;AACD,KAXwB;;AAazB;AACA;AACA;AACA;AACAC,IAAAA,WAAW,CAACC,SAAD,EAAYC,OAAZ,EAAqB;AAC9B;AACA,UAAI,CAACA,OAAD,IAAYrC,QAAQ,CAACoC,SAAD,CAAxB,EAAqC;AACnCC,QAAAA,OAAO,GAAGD,SAAV;AACAA,QAAAA,SAAS,GAAG,IAAZ;AACD;;AAED,YAAME,MAAM,GAAGZ,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBU,OAAlB,CAAf;AACAC,MAAAA,MAAM,CAAC/B,UAAP,GAAoB,KAAKA,UAAL,IAAmB,EAAvC;;AACA,UAAI+B,MAAM,CAACC,qBAAP,KAAiCC,SAArC,EAAgD;AAC9CF,QAAAA,MAAM,CAACC,qBAAP,GAA+B,IAA/B;AACD;;AAED,aAAO,KAAKE,YAAL,CAAkBL,SAAlB,EAA6BE,MAA7B,CAAP;AACD,KA/BwB;;AAiCzB;AACA;AACAG,IAAAA,YAAY,CAACL,SAAD,EAAYE,MAAZ,EAAoBI,OAAO,GAAG,IAA9B,EAAoC;AAC9C,UAAIN,SAAJ,EAAe;AACb,cAAMO,GAAG,GAAG,KAAKzC,MAAL,CAAYiC,WAAZ,CAAwBC,SAAxB,EAAmCE,MAAnC,EAA2CI,OAA3C,CAAZ;AACA,eAAOC,GAAP;AACD,OAHD,MAGO;AACL,eAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,eAAK5C,MAAL,CAAYiC,WAAZ,CAAwBU,OAAxB,EAAiCP,MAAjC,EAAyCI,OAAzC,EAAkDK,KAAlD,CAAwDD,MAAxD;AACD,SAFM,CAAP;AAGD;AACF,KA5CwB;;AA8CzBE,IAAAA,mBAAmB,CAACV,MAAD,EAAS;AAC1B,UAAIK,GAAJ;AACA,aAAO,MAAM;AACX,YAAI,CAACA,GAAL,EAAU;AACRA,UAAAA,GAAG,GAAG,KAAKR,WAAL,CAAiBK,SAAjB,EAA4BF,MAA5B,CAAN;AACD;;AACD,eAAOK,GAAP;AACD,OALD;AAMD,KAtDwB;;AAwDzB;AACAM,IAAAA,UAAU,CAACX,MAAD,EAAS;AACjB,aAAO,KAAKpC,MAAL,CAAYgD,cAAZ,CAA2BZ,MAA3B,CAAP;AACD,KA3DwB;;AA6DzB;AACAa,IAAAA,OAAO,CAACC,QAAD,EAAW;AAChB,aAAO,KAAKlD,MAAL,CAAYiD,OAAZ,CAAoBC,QAApB,CAAP;AACD,KAhEwB;;AAkEzBC,IAAAA,GAAG,CAACA,GAAD,EAAM;AACP,aAAO,KAAKnD,MAAL,CAAYmD,GAAZ,CAAgBA,GAAhB,CAAP;AACD,KApEwB;;AAsEzB;AACA;AACAC,IAAAA,iBAAiB,GAAG;AAClB,UAAI,KAAK/C,UAAL,CAAgBgD,oBAApB,EAA0C;AACxC;AACD;;AACD,WAAKhD,UAAL,CAAgBiD,cAAhB,GAAiC,KAAKtD,MAAL,CAAYoC,MAAZ,CAAmBkB,cAApD;AACA,WAAKjD,UAAL,CAAgBkD,mBAAhB,GAAsC,KAAKvD,MAAL,CAAYoC,MAAZ,CAAmBmB,mBAAzD;AACA,WAAKvD,MAAL,CAAYoC,MAAZ,CAAmBkB,cAAnB,GAAoC,IAApC;AACA,WAAKtD,MAAL,CAAYoC,MAAZ,CAAmBmB,mBAAnB,GAAyC,IAAzC;AACA,WAAKlD,UAAL,CAAgBgD,oBAAhB,GAAuC,IAAvC;AACD,KAjFwB;;AAmFzB;AACA;AACAG,IAAAA,gBAAgB,GAAG;AACjB,UAAI,CAAC,KAAKnD,UAAL,CAAgBgD,oBAArB,EAA2C;AACzC;AACD;;AACD,WAAKrD,MAAL,CAAYoC,MAAZ,CAAmBkB,cAAnB,GAAoC,KAAKjD,UAAL,CAAgBiD,cAApD;AACA,WAAKtD,MAAL,CAAYoC,MAAZ,CAAmBmB,mBAAnB,GAAyC,KAAKlD,UAAL,CAAgBkD,mBAAzD;AACA,WAAKlD,UAAL,CAAgBgD,oBAAhB,GAAuC,KAAvC;AACD,KA5FwB;;AA8FzBI,IAAAA,cAAc,CAACC,MAAD,EAAS;AACrB,YAAMC,SAAS,GAAGC,oBAAoB,CAACtC,MAAD,CAAtC,CADqB,CAC2B;;AAChD,UAAI,KAAKtB,MAAT,EAAiB;AACf2D,QAAAA,SAAS,CAAC3D,MAAV,GAAmBwB,MAAM,CAACqC,MAAP,CAAc,KAAK7D,MAAL,CAAY8D,WAAZ,CAAwBC,SAAtC,CAAnB,CADe,CACsD;;AACrEnE,QAAAA,KAAK,CAAC+D,SAAS,CAAC3D,MAAX,EAAmB,KAAKA,MAAxB,CAAL;AACA2D,QAAAA,SAAS,CAAC3D,MAAV,CAAiBoC,MAAjB,GAA0BZ,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB,KAAKzB,MAAL,CAAYoC,MAA9B,CAA1B,CAHe,CAGkD;AAClE;;AAEDhB,MAAAA,kBAAkB,CAACuC,SAAD,EAAYA,SAAS,CAAC3D,MAAtB,CAAlB;;AACAgE,MAAAA,mBAAmB,CAAC,OAAD,EAAU1C,MAAV,EAAkBqC,SAAlB,CAAnB;;AACAK,MAAAA,mBAAmB,CAAC,aAAD,EAAgB1C,MAAhB,EAAwBqC,SAAxB,CAAnB;;AACAK,MAAAA,mBAAmB,CAAC,gBAAD,EAAmB1C,MAAnB,EAA2BqC,SAA3B,CAAnB;;AACAK,MAAAA,mBAAmB,CAAC,OAAD,EAAU1C,MAAV,EAAkBqC,SAAlB,CAAnB;;AACAA,MAAAA,SAAS,CAACtD,UAAV,GAAuBqD,MAAvB;AACA,aAAOC,SAAP;AACD;;AA7GwB,GAA3B;;AAgHA,MAAI,CAACrC,MAAM,CAACpB,OAAZ,EAAqB;AACnBoB,IAAAA,MAAM,CAACpB,OAAP,GAAiBqB,WAAjB;AACD;AACF;;AAED,SAASyC,mBAAT,CAA6BC,SAA7B,EAAwCC,UAAxC,EAAoDC,UAApD,EAAgE;AAC9D,QAAMC,SAAS,GAAGF,UAAU,CAACE,SAAX,CAAqBH,SAArB,CAAlB;AACAG,EAAAA,SAAS,CAACC,OAAV,CAAmBC,QAAD,IAAc;AAC9BH,IAAAA,UAAU,CAACI,EAAX,CAAcN,SAAd,EAAyBK,QAAzB;AACD,GAFD;AAGD;;AAED,SAASlD,kBAAT,CAA4BJ,IAA5B,EAAkChB,MAAlC,EAA0C;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAK,IAAIwE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG7E,cAAc,CAAC8E,MAAnC,EAA2CD,CAAC,EAA5C,EAAgD;AAC9C,UAAME,MAAM,GAAG/E,cAAc,CAAC6E,CAAD,CAA7B;;AACAxD,IAAAA,IAAI,CAAC0D,MAAD,CAAJ,GAAe,YAAY;AACzB,YAAMC,OAAO,GAAG,KAAKjD,YAAL,EAAhB;AACA,aAAOiD,OAAO,CAACD,MAAD,CAAP,CAAgB9C,KAAhB,CAAsB+C,OAAtB,EAA+B9C,SAA/B,CAAP;AACD,KAHD;AAID;;AAEDL,EAAAA,MAAM,CAACoD,gBAAP,CAAwB5D,IAAxB,EAA8BjB,yBAA9B;AAEAsB,EAAAA,WAAW,CAACL,IAAD,CAAX;AACAA,EAAAA,IAAI,CAAChB,MAAL,GAAcA,MAAd;AACAgB,EAAAA,IAAI,CAACX,UAAL,GAAkB,EAAlB,CAvCwC,CAyCxC;;AACA,QAAMwE,EAAE,GAAG,IAAIvF,YAAJ,EAAX;;AACA,OAAK,MAAMwF,GAAX,IAAkBD,EAAlB,EAAsB;AACpB7D,IAAAA,IAAI,CAAC8D,GAAD,CAAJ,GAAYD,EAAE,CAACC,GAAD,CAAd;AACD,GA7CuC,CA+CxC;AACA;;;AACA,MAAI9D,IAAI,CAAC+D,kBAAT,EAA6B;AAC3B/D,IAAAA,IAAI,CAAC+D,kBAAL,CAAwBV,OAAxB,CAAgC,CAAC;AAAEJ,MAAAA,SAAF;AAAaK,MAAAA;AAAb,KAAD,KAA6B;AAC3DtD,MAAAA,IAAI,CAAChB,MAAL,CAAYgF,cAAZ,CAA2Bf,SAA3B,EAAsCK,QAAtC,EAD2D,CACV;AAClD,KAFD;AAGD;;AACDtD,EAAAA,IAAI,CAAC+D,kBAAL,GAA0B,EAA1B,CAtDwC,CAwDxC;;AACAE,EAAAA,oBAAoB,CAACjE,IAAD,EAAO,OAAP,EAAiBkE,GAAD,IAAS;AAC3ClE,IAAAA,IAAI,CAACmE,IAAL,CAAU,OAAV,EAAmBD,GAAnB;AACD,GAFmB,CAApB;;AAGAD,EAAAA,oBAAoB,CAACjE,IAAD,EAAO,OAAP,EAAiBkE,GAAD,IAAS;AAC3ClE,IAAAA,IAAI,CAACmE,IAAL,CAAU,OAAV,EAAmBD,GAAnB;AACD,GAFmB,CAApB;;AAGAD,EAAAA,oBAAoB,CAACjE,IAAD,EAAO,aAAP,EAAsB,CAACoE,GAAD,EAAMF,GAAN,KAAc;AACtDlE,IAAAA,IAAI,CAACmE,IAAL,CAAU,aAAV,EAAyBC,GAAzB,EAA8BF,GAA9B;AACD,GAFmB,CAApB;;AAGAD,EAAAA,oBAAoB,CAACjE,IAAD,EAAO,gBAAP,EAAyB,CAACqE,QAAD,EAAWH,GAAX,EAAgBP,OAAhB,KAA4B;AACvE3D,IAAAA,IAAI,CAACmE,IAAL,CAAU,gBAAV,EAA4BE,QAA5B,EAAsCH,GAAtC,EAA2CP,OAA3C;AACD,GAFmB,CAApB;AAGD;;AAED,SAASM,oBAAT,CAA8BjE,IAA9B,EAAoCiD,SAApC,EAA+CK,QAA/C,EAAyD;AACvDtD,EAAAA,IAAI,CAAChB,MAAL,CAAYuE,EAAZ,CAAeN,SAAf,EAA0BK,QAA1B;;AACAtD,EAAAA,IAAI,CAAC+D,kBAAL,CAAwBO,IAAxB,CAA6B;AAC3BrB,IAAAA,SAD2B;AAE3BK,IAAAA;AAF2B,GAA7B;AAID;;AAED,SAASnD,kBAAT,CAA4BI,WAA5B,EAAyCN,SAAzC,EAAoDC,OAApD,EAA6D;AAC3D,QAAMqE,EAAE,GAAGhE,WAAW,CAACG,YAAZ,EAAX;AACA,MAAI,CAACT,SAAL,EACEM,WAAW,CAACvB,MAAZ,CAAmBwF,MAAnB,CAA0BC,IAA1B,CACE,kFADF;AAGF,SAAOxE,SAAS,GAAGsE,EAAE,CAACzD,KAAH,CAASb,SAAT,EAAoBC,OAApB,CAAH,GAAkCqE,EAAlD;AACD;;AAED,SAAS3B,oBAAT,CAA8B8B,gBAA9B,EAAgD;AAC9C,QAAMC,SAAS,GAAGnE,MAAM,CAACqC,MAAP,CAChBrC,MAAM,CAACoE,cAAP,CAAsBF,gBAAtB,CADgB,EAEhBlE,MAAM,CAACqE,yBAAP,CAAiCH,gBAAjC,CAFgB,CAAlB;AAKA,QAAMnE,WAAW,GAAG,EAApB;;AACA,QAAMuE,aAAa,GAAG,CAAC7E,SAAD,EAAYC,OAAZ,KAAwB;AAC5C,WAAOC,kBAAkB,CAACI,WAAD,EAAcN,SAAd,EAAyBC,OAAzB,CAAzB;AACD,GAFD;;AAIA,QAAM6E,cAAc,GAAGD,aAAa,CAACE,IAAd,CAAmBL,SAAnB,CAAvB;AACAnE,EAAAA,MAAM,CAACC,MAAP,CAAcsE,cAAd,EAA8BL,gBAA9B;AACAK,EAAAA,cAAc,CAAC7F,OAAf,GAAyBqB,WAAzB;AACA,SAAOwE,cAAP;AACD;;AAEDE,MAAM,CAACC,OAAP,GAAiBnF,QAAjB","sourcesContent":["const { EventEmitter } = require('events');\n\nconst { Migrator } = require('../migrations/migrate/Migrator');\nconst Seeder = require('../migrations/seed/Seeder');\nconst FunctionHelper = require('./FunctionHelper');\nconst QueryInterface = require('../query/method-constants');\nconst merge = require('lodash/merge');\nconst batchInsert = require('../execution/batch-insert');\nconst { isObject } = require('../util/is');\n\n// Javascript does not officially support \"callable objects\".  Instead,\n// you must create a regular Function and inject properties/methods\n// into it.  In other words: you can't leverage Prototype Inheritance\n// to share the property/method definitions.\n//\n// To work around this, we're creating an Object Property Definition.\n// This allow us to quickly inject everything into the `knex` function\n// via the `Object.defineProperties(..)` function.  More importantly,\n// it allows the same definitions to be shared across `knex` instances.\nconst KNEX_PROPERTY_DEFINITIONS = {\n  client: {\n    get() {\n      return this.context.client;\n    },\n    set(client) {\n      this.context.client = client;\n    },\n    configurable: true,\n  },\n\n  userParams: {\n    get() {\n      return this.context.userParams;\n    },\n    set(userParams) {\n      this.context.userParams = userParams;\n    },\n    configurable: true,\n  },\n\n  schema: {\n    get() {\n      return this.client.schemaBuilder();\n    },\n    configurable: true,\n  },\n\n  migrate: {\n    get() {\n      return new Migrator(this);\n    },\n    configurable: true,\n  },\n\n  seed: {\n    get() {\n      return new Seeder(this);\n    },\n    configurable: true,\n  },\n\n  fn: {\n    get() {\n      return new FunctionHelper(this.client);\n    },\n    configurable: true,\n  },\n};\n\n// `knex` instances serve as proxies around `context` objects.  So, calling\n// any of these methods on the `knex` instance will forward the call to\n// the `knex.context` object. This ensures that `this` will correctly refer\n// to `context` within each of these methods.\nconst CONTEXT_METHODS = [\n  'raw',\n  'batchInsert',\n  'transaction',\n  'transactionProvider',\n  'initialize',\n  'destroy',\n  'ref',\n  'withUserParams',\n  'queryBuilder',\n  'disableProcessing',\n  'enableProcessing',\n];\n\nfor (const m of CONTEXT_METHODS) {\n  KNEX_PROPERTY_DEFINITIONS[m] = {\n    value: function (...args) {\n      return this.context[m](...args);\n    },\n    configurable: true,\n  };\n}\n\nfunction makeKnex(client) {\n  // The object we're potentially using to kick off an initial chain.\n  function knex(tableName, options) {\n    return createQueryBuilder(knex.context, tableName, options);\n  }\n\n  redefineProperties(knex, client);\n  return knex;\n}\n\nfunction initContext(knexFn) {\n  const knexContext = knexFn.context || {};\n  Object.assign(knexContext, {\n    queryBuilder() {\n      return this.client.queryBuilder();\n    },\n\n    raw() {\n      return this.client.raw.apply(this.client, arguments);\n    },\n\n    batchInsert(table, batch, chunkSize = 1000) {\n      return batchInsert(this, table, batch, chunkSize);\n    },\n\n    // Creates a new transaction.\n    // If container is provided, returns a promise for when the transaction is resolved.\n    // If container is not provided, returns a promise with a transaction that is resolved\n    // when transaction is ready to be used.\n    transaction(container, _config) {\n      // Overload support of `transaction(config)`\n      if (!_config && isObject(container)) {\n        _config = container;\n        container = null;\n      }\n\n      const config = Object.assign({}, _config);\n      config.userParams = this.userParams || {};\n      if (config.doNotRejectOnRollback === undefined) {\n        config.doNotRejectOnRollback = true;\n      }\n\n      return this._transaction(container, config);\n    },\n\n    // Internal method that actually establishes the Transaction.  It makes no assumptions\n    // about the `config` or `outerTx`, and expects the caller to handle these details.\n    _transaction(container, config, outerTx = null) {\n      if (container) {\n        const trx = this.client.transaction(container, config, outerTx);\n        return trx;\n      } else {\n        return new Promise((resolve, reject) => {\n          this.client.transaction(resolve, config, outerTx).catch(reject);\n        });\n      }\n    },\n\n    transactionProvider(config) {\n      let trx;\n      return () => {\n        if (!trx) {\n          trx = this.transaction(undefined, config);\n        }\n        return trx;\n      };\n    },\n\n    // Typically never needed, initializes the pool for a knex client.\n    initialize(config) {\n      return this.client.initializePool(config);\n    },\n\n    // Convenience method for tearing down the pool.\n    destroy(callback) {\n      return this.client.destroy(callback);\n    },\n\n    ref(ref) {\n      return this.client.ref(ref);\n    },\n\n    // Do not document this as public API until naming and API is improved for general consumption\n    // This method exists to disable processing of internal queries in migrations\n    disableProcessing() {\n      if (this.userParams.isProcessingDisabled) {\n        return;\n      }\n      this.userParams.wrapIdentifier = this.client.config.wrapIdentifier;\n      this.userParams.postProcessResponse = this.client.config.postProcessResponse;\n      this.client.config.wrapIdentifier = null;\n      this.client.config.postProcessResponse = null;\n      this.userParams.isProcessingDisabled = true;\n    },\n\n    // Do not document this as public API until naming and API is improved for general consumption\n    // This method exists to enable execution of non-internal queries with consistent identifier naming in migrations\n    enableProcessing() {\n      if (!this.userParams.isProcessingDisabled) {\n        return;\n      }\n      this.client.config.wrapIdentifier = this.userParams.wrapIdentifier;\n      this.client.config.postProcessResponse = this.userParams.postProcessResponse;\n      this.userParams.isProcessingDisabled = false;\n    },\n\n    withUserParams(params) {\n      const knexClone = shallowCloneFunction(knexFn); // We need to include getters in our clone\n      if (this.client) {\n        knexClone.client = Object.create(this.client.constructor.prototype); // Clone client to avoid leaking listeners that are set on it\n        merge(knexClone.client, this.client);\n        knexClone.client.config = Object.assign({}, this.client.config); // Clone client config to make sure they can be modified independently\n      }\n\n      redefineProperties(knexClone, knexClone.client);\n      _copyEventListeners('query', knexFn, knexClone);\n      _copyEventListeners('query-error', knexFn, knexClone);\n      _copyEventListeners('query-response', knexFn, knexClone);\n      _copyEventListeners('start', knexFn, knexClone);\n      knexClone.userParams = params;\n      return knexClone;\n    },\n  });\n\n  if (!knexFn.context) {\n    knexFn.context = knexContext;\n  }\n}\n\nfunction _copyEventListeners(eventName, sourceKnex, targetKnex) {\n  const listeners = sourceKnex.listeners(eventName);\n  listeners.forEach((listener) => {\n    targetKnex.on(eventName, listener);\n  });\n}\n\nfunction redefineProperties(knex, client) {\n  // Allow chaining methods from the root object, before\n  // any other information is specified.\n  //\n  // TODO: `QueryBuilder.extend(..)` allows new QueryBuilder\n  //       methods to be introduced via external components.\n  //       As a side-effect, it also pushes the new method names\n  //       into the `QueryInterface` array.\n  //\n  //       The Problem: due to the way the code is currently\n  //       structured, these new methods cannot be retroactively\n  //       injected into existing `knex` instances!  As a result,\n  //       some `knex` instances will support the methods, and\n  //       others will not.\n  //\n  //       We should revisit this once we figure out the desired\n  //       behavior / usage.  For instance: do we really want to\n  //       allow external components to directly manipulate `knex`\n  //       data structures?  Or, should we come up w/ a different\n  //       approach that avoids side-effects / mutation?\n  //\n  //      (FYI: I noticed this issue because I attempted to integrate\n  //       this logic directly into the `KNEX_PROPERTY_DEFINITIONS`\n  //       construction.  However, `KNEX_PROPERTY_DEFINITIONS` is\n  //       constructed before any `knex` instances are created.\n  //       As a result, the method extensions were missing from all\n  //       `knex` instances.)\n  for (let i = 0; i < QueryInterface.length; i++) {\n    const method = QueryInterface[i];\n    knex[method] = function () {\n      const builder = this.queryBuilder();\n      return builder[method].apply(builder, arguments);\n    };\n  }\n\n  Object.defineProperties(knex, KNEX_PROPERTY_DEFINITIONS);\n\n  initContext(knex);\n  knex.client = client;\n  knex.userParams = {};\n\n  // Hook up the \"knex\" object as an EventEmitter.\n  const ee = new EventEmitter();\n  for (const key in ee) {\n    knex[key] = ee[key];\n  }\n\n  // Unfortunately, something seems to be broken in Node 6 and removing events from a clone also mutates original Knex,\n  // which is highly undesirable\n  if (knex._internalListeners) {\n    knex._internalListeners.forEach(({ eventName, listener }) => {\n      knex.client.removeListener(eventName, listener); // Remove duplicates for copies\n    });\n  }\n  knex._internalListeners = [];\n\n  // Passthrough all \"start\" and \"query\" events to the knex object.\n  _addInternalListener(knex, 'start', (obj) => {\n    knex.emit('start', obj);\n  });\n  _addInternalListener(knex, 'query', (obj) => {\n    knex.emit('query', obj);\n  });\n  _addInternalListener(knex, 'query-error', (err, obj) => {\n    knex.emit('query-error', err, obj);\n  });\n  _addInternalListener(knex, 'query-response', (response, obj, builder) => {\n    knex.emit('query-response', response, obj, builder);\n  });\n}\n\nfunction _addInternalListener(knex, eventName, listener) {\n  knex.client.on(eventName, listener);\n  knex._internalListeners.push({\n    eventName,\n    listener,\n  });\n}\n\nfunction createQueryBuilder(knexContext, tableName, options) {\n  const qb = knexContext.queryBuilder();\n  if (!tableName)\n    knexContext.client.logger.warn(\n      'calling knex without a tableName is deprecated. Use knex.queryBuilder() instead.'\n    );\n  return tableName ? qb.table(tableName, options) : qb;\n}\n\nfunction shallowCloneFunction(originalFunction) {\n  const fnContext = Object.create(\n    Object.getPrototypeOf(originalFunction),\n    Object.getOwnPropertyDescriptors(originalFunction)\n  );\n\n  const knexContext = {};\n  const knexFnWrapper = (tableName, options) => {\n    return createQueryBuilder(knexContext, tableName, options);\n  };\n\n  const clonedFunction = knexFnWrapper.bind(fnContext);\n  Object.assign(clonedFunction, originalFunction);\n  clonedFunction.context = knexContext;\n  return clonedFunction;\n}\n\nmodule.exports = makeKnex;\n"]},"metadata":{},"sourceType":"script"}