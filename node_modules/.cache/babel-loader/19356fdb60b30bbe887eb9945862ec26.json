{"ast":null,"code":"const Client = require('../../client');\n\nconst {\n  SUPPORTED_CLIENTS\n} = require('../../constants');\n\nconst parseConnection = require('./parse-connection');\n\nconst {\n  resolveClientNameWithAliases\n} = require('../../util/helpers');\n\nfunction resolveConfig(config) {\n  let Dialect;\n  let resolvedConfig; // If config is a string, try to parse it\n\n  const parsedConfig = typeof config === 'string' ? Object.assign(parseConnection(config), arguments[2]) : config; // If user provided no relevant parameters, use generic client\n\n  if (arguments.length === 0 || !parsedConfig.client && !parsedConfig.dialect) {\n    Dialect = Client;\n  } // If user provided Client constructor as a parameter, use it\n  else if (typeof parsedConfig.client === 'function') {\n      Dialect = parsedConfig.client;\n    } // If neither applies, let's assume user specified name of a client or dialect as a string\n    else {\n        const clientName = parsedConfig.client || parsedConfig.dialect;\n\n        if (!SUPPORTED_CLIENTS.includes(clientName)) {\n          throw new Error(`knex: Unknown configuration option 'client' value ${clientName}. Note that it is case-sensitive, check documentation for supported values.`);\n        }\n\n        const resolvedClientName = resolveClientNameWithAliases(clientName);\n        Dialect = require(`../../dialects/${resolvedClientName}/index.js`);\n      } // If config connection parameter is passed as string, try to parse it\n\n\n  if (typeof parsedConfig.connection === 'string') {\n    resolvedConfig = Object.assign({}, parsedConfig, {\n      connection: parseConnection(parsedConfig.connection).connection\n    });\n  } else {\n    resolvedConfig = Object.assign({}, parsedConfig);\n  }\n\n  return {\n    resolvedConfig,\n    Dialect\n  };\n}\n\nmodule.exports = {\n  resolveConfig\n};","map":{"version":3,"sources":["/home/rosiane/Projeto-completo/back/node_modules/knex/lib/knex-builder/internal/config-resolver.js"],"names":["Client","require","SUPPORTED_CLIENTS","parseConnection","resolveClientNameWithAliases","resolveConfig","config","Dialect","resolvedConfig","parsedConfig","Object","assign","arguments","length","client","dialect","clientName","includes","Error","resolvedClientName","connection","module","exports"],"mappings":"AAAA,MAAMA,MAAM,GAAGC,OAAO,CAAC,cAAD,CAAtB;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAwBD,OAAO,CAAC,iBAAD,CAArC;;AAEA,MAAME,eAAe,GAAGF,OAAO,CAAC,oBAAD,CAA/B;;AACA,MAAM;AAAEG,EAAAA;AAAF,IAAmCH,OAAO,CAAC,oBAAD,CAAhD;;AAEA,SAASI,aAAT,CAAuBC,MAAvB,EAA+B;AAC7B,MAAIC,OAAJ;AACA,MAAIC,cAAJ,CAF6B,CAI7B;;AACA,QAAMC,YAAY,GAChB,OAAOH,MAAP,KAAkB,QAAlB,GACII,MAAM,CAACC,MAAP,CAAcR,eAAe,CAACG,MAAD,CAA7B,EAAuCM,SAAS,CAAC,CAAD,CAAhD,CADJ,GAEIN,MAHN,CAL6B,CAU7B;;AACA,MACEM,SAAS,CAACC,MAAV,KAAqB,CAArB,IACC,CAACJ,YAAY,CAACK,MAAd,IAAwB,CAACL,YAAY,CAACM,OAFzC,EAGE;AACAR,IAAAA,OAAO,GAAGP,MAAV;AACD,GALD,CAMA;AANA,OAOK,IACH,OAAOS,YAAY,CAACK,MAApB,KAA+B,UAD5B,EAEH;AACAP,MAAAA,OAAO,GAAGE,YAAY,CAACK,MAAvB;AACD,KAJI,CAKL;AALK,SAMA;AACH,cAAME,UAAU,GAAGP,YAAY,CAACK,MAAb,IAAuBL,YAAY,CAACM,OAAvD;;AACA,YAAI,CAACb,iBAAiB,CAACe,QAAlB,CAA2BD,UAA3B,CAAL,EAA6C;AAC3C,gBAAM,IAAIE,KAAJ,CACH,qDAAoDF,UAAW,6EAD5D,CAAN;AAGD;;AAED,cAAMG,kBAAkB,GAAGf,4BAA4B,CAACY,UAAD,CAAvD;AACAT,QAAAA,OAAO,GAAGN,OAAO,CAAE,kBAAiBkB,kBAAmB,WAAtC,CAAjB;AACD,OAlC4B,CAoC7B;;;AACA,MAAI,OAAOV,YAAY,CAACW,UAApB,KAAmC,QAAvC,EAAiD;AAC/CZ,IAAAA,cAAc,GAAGE,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBF,YAAlB,EAAgC;AAC/CW,MAAAA,UAAU,EAAEjB,eAAe,CAACM,YAAY,CAACW,UAAd,CAAf,CAAyCA;AADN,KAAhC,CAAjB;AAGD,GAJD,MAIO;AACLZ,IAAAA,cAAc,GAAGE,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBF,YAAlB,CAAjB;AACD;;AAED,SAAO;AACLD,IAAAA,cADK;AAELD,IAAAA;AAFK,GAAP;AAID;;AAEDc,MAAM,CAACC,OAAP,GAAiB;AACfjB,EAAAA;AADe,CAAjB","sourcesContent":["const Client = require('../../client');\nconst { SUPPORTED_CLIENTS } = require('../../constants');\n\nconst parseConnection = require('./parse-connection');\nconst { resolveClientNameWithAliases } = require('../../util/helpers');\n\nfunction resolveConfig(config) {\n  let Dialect;\n  let resolvedConfig;\n\n  // If config is a string, try to parse it\n  const parsedConfig =\n    typeof config === 'string'\n      ? Object.assign(parseConnection(config), arguments[2])\n      : config;\n\n  // If user provided no relevant parameters, use generic client\n  if (\n    arguments.length === 0 ||\n    (!parsedConfig.client && !parsedConfig.dialect)\n  ) {\n    Dialect = Client;\n  }\n  // If user provided Client constructor as a parameter, use it\n  else if (\n    typeof parsedConfig.client === 'function'\n  ) {\n    Dialect = parsedConfig.client;\n  }\n  // If neither applies, let's assume user specified name of a client or dialect as a string\n  else {\n    const clientName = parsedConfig.client || parsedConfig.dialect;\n    if (!SUPPORTED_CLIENTS.includes(clientName)) {\n      throw new Error(\n        `knex: Unknown configuration option 'client' value ${clientName}. Note that it is case-sensitive, check documentation for supported values.`\n      );\n    }\n\n    const resolvedClientName = resolveClientNameWithAliases(clientName);\n    Dialect = require(`../../dialects/${resolvedClientName}/index.js`);\n  }\n\n  // If config connection parameter is passed as string, try to parse it\n  if (typeof parsedConfig.connection === 'string') {\n    resolvedConfig = Object.assign({}, parsedConfig, {\n      connection: parseConnection(parsedConfig.connection).connection,\n    });\n  } else {\n    resolvedConfig = Object.assign({}, parsedConfig);\n  }\n\n  return {\n    resolvedConfig,\n    Dialect,\n  };\n}\n\nmodule.exports = {\n  resolveConfig,\n};\n"]},"metadata":{},"sourceType":"script"}