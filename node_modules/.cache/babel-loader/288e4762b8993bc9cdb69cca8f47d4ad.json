{"ast":null,"code":"// MSSQL Query Compiler\n// ------\nconst QueryCompiler = require('../../../query/querycompiler');\n\nconst compact = require('lodash/compact');\n\nconst identity = require('lodash/identity');\n\nconst isEmpty = require('lodash/isEmpty');\n\nconst components = ['columns', 'join', 'lock', 'where', 'union', 'group', 'having', 'order', 'limit', 'offset'];\n\nclass QueryCompiler_MSSQL extends QueryCompiler {\n  constructor(client, builder, formatter) {\n    super(client, builder, formatter);\n    const {\n      onConflict\n    } = this.single;\n\n    if (onConflict) {\n      throw new Error('.onConflict() is not supported for mssql.');\n    }\n\n    this._emptyInsertValue = 'default values';\n  }\n\n  select() {\n    const sql = this.with();\n    const statements = components.map(component => this[component](this));\n    return sql + compact(statements).join(' ');\n  } //#region Insert\n  // Compiles an \"insert\" query, allowing for multiple\n  // inserts using a single query statement.\n\n\n  insert() {\n    if (this.single.options && this.single.options.includeTriggerModifications) {\n      return this.insertWithTriggers();\n    } else {\n      return this.standardInsert();\n    }\n  }\n\n  insertWithTriggers() {\n    const insertValues = this.single.insert || [];\n    const {\n      returning\n    } = this.single;\n    let sql = this.with() + `${this._buildTempTable(returning)}insert into ${this.tableName} `;\n    const returningSql = returning ? this._returning('insert', returning, true) + ' ' : '';\n\n    if (Array.isArray(insertValues)) {\n      if (insertValues.length === 0) {\n        return '';\n      }\n    } else if (typeof insertValues === 'object' && isEmpty(insertValues)) {\n      return {\n        sql: sql + returningSql + this._emptyInsertValue + this._buildReturningSelect(returning),\n        returning\n      };\n    }\n\n    const insertData = this._prepInsert(insertValues);\n\n    if (typeof insertData === 'string') {\n      sql += insertData;\n    } else {\n      if (insertData.columns.length) {\n        sql += `(${this.formatter.columnize(insertData.columns)}`;\n        sql += `) ${returningSql}values (`;\n        let i = -1;\n\n        while (++i < insertData.values.length) {\n          if (i !== 0) sql += '), (';\n          sql += this.client.parameterize(insertData.values[i], this.client.valueForUndefined, this.builder, this.bindingsHolder);\n        }\n\n        sql += ')';\n      } else if (insertValues.length === 1 && insertValues[0]) {\n        sql += returningSql + this._emptyInsertValue;\n      } else {\n        sql = '';\n      }\n    }\n\n    if (returning) {\n      sql += this._buildReturningSelect(returning);\n    }\n\n    return {\n      sql,\n      returning\n    };\n  }\n\n  standardInsert() {\n    const insertValues = this.single.insert || [];\n    let sql = this.with() + `insert into ${this.tableName} `;\n    const {\n      returning\n    } = this.single;\n    const returningSql = returning ? this._returning('insert', returning) + ' ' : '';\n\n    if (Array.isArray(insertValues)) {\n      if (insertValues.length === 0) {\n        return '';\n      }\n    } else if (typeof insertValues === 'object' && isEmpty(insertValues)) {\n      return {\n        sql: sql + returningSql + this._emptyInsertValue,\n        returning\n      };\n    }\n\n    const insertData = this._prepInsert(insertValues);\n\n    if (typeof insertData === 'string') {\n      sql += insertData;\n    } else {\n      if (insertData.columns.length) {\n        sql += `(${this.formatter.columnize(insertData.columns)}`;\n        sql += `) ${returningSql}values (`;\n        let i = -1;\n\n        while (++i < insertData.values.length) {\n          if (i !== 0) sql += '), (';\n          sql += this.client.parameterize(insertData.values[i], this.client.valueForUndefined, this.builder, this.bindingsHolder);\n        }\n\n        sql += ')';\n      } else if (insertValues.length === 1 && insertValues[0]) {\n        sql += returningSql + this._emptyInsertValue;\n      } else {\n        sql = '';\n      }\n    }\n\n    return {\n      sql,\n      returning\n    };\n  } //#endregion\n  //#region Update\n  // Compiles an `update` query, allowing for a return value.\n\n\n  update() {\n    if (this.single.options && this.single.options.includeTriggerModifications) {\n      return this.updateWithTriggers();\n    } else {\n      return this.standardUpdate();\n    }\n  }\n\n  updateWithTriggers() {\n    const top = this.top();\n    const withSQL = this.with();\n\n    const updates = this._prepUpdate(this.single.update);\n\n    const join = this.join();\n    const where = this.where();\n    const order = this.order();\n    const {\n      returning\n    } = this.single;\n\n    const declaredTemp = this._buildTempTable(returning);\n\n    return {\n      sql: withSQL + declaredTemp + `update ${top ? top + ' ' : ''}${this.tableName}` + ' set ' + updates.join(', ') + (returning ? ` ${this._returning('update', returning, true)}` : '') + (join ? ` from ${this.tableName} ${join}` : '') + (where ? ` ${where}` : '') + (order ? ` ${order}` : '') + (!returning ? this._returning('rowcount', '@@rowcount') : this._buildReturningSelect(returning)),\n      returning: returning || '@@rowcount'\n    };\n  }\n\n  standardUpdate() {\n    const top = this.top();\n    const withSQL = this.with();\n\n    const updates = this._prepUpdate(this.single.update);\n\n    const join = this.join();\n    const where = this.where();\n    const order = this.order();\n    const {\n      returning\n    } = this.single;\n    return {\n      sql: withSQL + `update ${top ? top + ' ' : ''}${this.tableName}` + ' set ' + updates.join(', ') + (returning ? ` ${this._returning('update', returning)}` : '') + (join ? ` from ${this.tableName} ${join}` : '') + (where ? ` ${where}` : '') + (order ? ` ${order}` : '') + (!returning ? this._returning('rowcount', '@@rowcount') : ''),\n      returning: returning || '@@rowcount'\n    };\n  } //#endregion\n  //#region Delete\n  // Compiles a `delete` query.\n\n\n  del() {\n    if (this.single.options && this.single.options.includeTriggerModifications) {\n      return this.deleteWithTriggers();\n    } else {\n      return this.standardDelete();\n    }\n  }\n\n  deleteWithTriggers() {\n    // Make sure tableName is processed by the formatter first.\n    const withSQL = this.with();\n    const {\n      tableName\n    } = this;\n    const wheres = this.where();\n    const {\n      returning\n    } = this.single;\n    return {\n      sql: withSQL + `${this._buildTempTable(returning)}delete from ${tableName}` + (returning ? ` ${this._returning('del', returning, true)}` : '') + (wheres ? ` ${wheres}` : '') + (!returning ? this._returning('rowcount', '@@rowcount') : this._buildReturningSelect(returning)),\n      returning: returning || '@@rowcount'\n    };\n  }\n\n  standardDelete() {\n    // Make sure tableName is processed by the formatter first.\n    const withSQL = this.with();\n    const {\n      tableName\n    } = this;\n    const wheres = this.where();\n    const {\n      returning\n    } = this.single;\n    return {\n      sql: withSQL + `delete from ${tableName}` + (returning ? ` ${this._returning('del', returning)}` : '') + (wheres ? ` ${wheres}` : '') + (!returning ? this._returning('rowcount', '@@rowcount') : ''),\n      returning: returning || '@@rowcount'\n    };\n  } //#endregion\n  // Compiles the columns in the query, specifying if an item was distinct.\n\n\n  columns() {\n    let distinctClause = '';\n    if (this.onlyUnions()) return '';\n    const top = this.top();\n\n    const hints = this._hintComments();\n\n    const columns = this.grouped.columns || [];\n    let i = -1,\n        sql = [];\n\n    if (columns) {\n      while (++i < columns.length) {\n        const stmt = columns[i];\n        if (stmt.distinct) distinctClause = 'distinct ';\n\n        if (stmt.distinctOn) {\n          distinctClause = this.distinctOn(stmt.value);\n          continue;\n        }\n\n        if (stmt.type === 'aggregate') {\n          sql.push(...this.aggregate(stmt));\n        } else if (stmt.type === 'aggregateRaw') {\n          sql.push(this.aggregateRaw(stmt));\n        } else if (stmt.type === 'analytic') {\n          sql.push(this.analytic(stmt));\n        } else if (stmt.value && stmt.value.length > 0) {\n          sql.push(this.formatter.columnize(stmt.value));\n        }\n      }\n    }\n\n    if (sql.length === 0) sql = ['*'];\n    return `select ${hints}${distinctClause}` + (top ? top + ' ' : '') + sql.join(', ') + (this.tableName ? ` from ${this.tableName}` : '');\n  }\n\n  _returning(method, value, withTrigger) {\n    switch (method) {\n      case 'update':\n      case 'insert':\n        return value ? `output ${this.formatter.columnizeWithPrefix('inserted.', value)}${withTrigger ? ' into #out' : ''}` : '';\n\n      case 'del':\n        return value ? `output ${this.formatter.columnizeWithPrefix('deleted.', value)}${withTrigger ? ' into #out' : ''}` : '';\n\n      case 'rowcount':\n        return value ? ';select @@rowcount' : '';\n    }\n  }\n\n  _buildTempTable(values) {\n    // If value is nothing then return an empty string\n    if (values && values.length > 0) {\n      let selections = ''; // Build values that will be returned from this procedure\n\n      if (Array.isArray(values)) {\n        selections = values.map(value => `[t].${this.formatter.columnize(value)}`).join(',');\n      } else {\n        selections = `[t].${this.formatter.columnize(values)}`;\n      } // Force #out to be correctly populated with the correct column structure.\n\n\n      let sql = `select top(0) ${selections} into #out `;\n      sql += `from ${this.tableName} as t `;\n      sql += `left join ${this.tableName} on 0=1;`;\n      return sql;\n    }\n\n    return '';\n  }\n\n  _buildReturningSelect(values) {\n    // If value is nothing then return an empty string\n    if (values && values.length > 0) {\n      let selections = ''; // Build columns to return\n\n      if (Array.isArray(values)) {\n        selections = values.map(value => `${this.formatter.columnize(value)}`).join(',');\n      } else {\n        selections = this.formatter.columnize(values);\n      } // Get the returned values\n\n\n      let sql = `; select ${selections} from #out; `; // Drop the temp table to prevent memory leaks\n\n      sql += `drop table #out;`;\n      return sql;\n    }\n\n    return '';\n  } // Compiles a `truncate` query.\n\n\n  truncate() {\n    return `truncate table ${this.tableName}`;\n  }\n\n  forUpdate() {\n    // this doesn't work exacltly as it should, one should also mention index while locking\n    // https://stackoverflow.com/a/9818448/360060\n    return 'with (UPDLOCK)';\n  }\n\n  forShare() {\n    // http://www.sqlteam.com/article/introduction-to-locking-in-sql-server\n    return 'with (HOLDLOCK)';\n  } // Compiles a `columnInfo` query.\n\n\n  columnInfo() {\n    const column = this.single.columnInfo;\n    let schema = this.single.schema; // The user may have specified a custom wrapIdentifier function in the config. We\n    // need to run the identifiers through that function, but not format them as\n    // identifiers otherwise.\n\n    const table = this.client.customWrapIdentifier(this.single.table, identity);\n\n    if (schema) {\n      schema = this.client.customWrapIdentifier(schema, identity);\n    }\n\n    let sql = `select [COLUMN_NAME], [COLUMN_DEFAULT], [DATA_TYPE], [CHARACTER_MAXIMUM_LENGTH], [IS_NULLABLE] from information_schema.columns where table_name = ? and table_catalog = ?`;\n    const bindings = [table, this.client.database()];\n\n    if (schema) {\n      sql += ' and table_schema = ?';\n      bindings.push(schema);\n    } else {\n      sql += ` and table_schema = 'dbo'`;\n    }\n\n    return {\n      sql,\n      bindings: bindings,\n\n      output(resp) {\n        const out = resp.reduce((columns, val) => {\n          columns[val[0].value] = {\n            defaultValue: val[1].value,\n            type: val[2].value,\n            maxLength: val[3].value,\n            nullable: val[4].value === 'YES'\n          };\n          return columns;\n        }, {});\n        return column && out[column] || out;\n      }\n\n    };\n  }\n\n  top() {\n    const noLimit = !this.single.limit && this.single.limit !== 0;\n    const noOffset = !this.single.offset;\n    if (noLimit || !noOffset) return '';\n    return `top (${this.client.parameter(this.single.limit, this.builder, this.bindingsHolder)})`;\n  }\n\n  limit() {\n    return '';\n  }\n\n  offset() {\n    const noLimit = !this.single.limit && this.single.limit !== 0;\n    const noOffset = !this.single.offset;\n    if (noOffset) return '';\n    let offset = `offset ${noOffset ? '0' : this.client.parameter(this.single.offset, this.builder, this.bindingsHolder)} rows`;\n\n    if (!noLimit) {\n      offset += ` fetch next ${this.client.parameter(this.single.limit, this.builder, this.bindingsHolder)} rows only`;\n    }\n\n    return offset;\n  }\n\n} // Set the QueryBuilder & QueryCompiler on the client object,\n// in case anyone wants to modify things to suit their own purposes.\n\n\nmodule.exports = QueryCompiler_MSSQL;","map":{"version":3,"sources":["/home/rosiane/back/node_modules/knex/lib/dialects/mssql/query/mssql-querycompiler.js"],"names":["QueryCompiler","require","compact","identity","isEmpty","components","QueryCompiler_MSSQL","constructor","client","builder","formatter","onConflict","single","Error","_emptyInsertValue","select","sql","with","statements","map","component","join","insert","options","includeTriggerModifications","insertWithTriggers","standardInsert","insertValues","returning","_buildTempTable","tableName","returningSql","_returning","Array","isArray","length","_buildReturningSelect","insertData","_prepInsert","columns","columnize","i","values","parameterize","valueForUndefined","bindingsHolder","update","updateWithTriggers","standardUpdate","top","withSQL","updates","_prepUpdate","where","order","declaredTemp","del","deleteWithTriggers","standardDelete","wheres","distinctClause","onlyUnions","hints","_hintComments","grouped","stmt","distinct","distinctOn","value","type","push","aggregate","aggregateRaw","analytic","method","withTrigger","columnizeWithPrefix","selections","truncate","forUpdate","forShare","columnInfo","column","schema","table","customWrapIdentifier","bindings","database","output","resp","out","reduce","val","defaultValue","maxLength","nullable","noLimit","limit","noOffset","offset","parameter","module","exports"],"mappings":"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","sourcesContent":["// MSSQL Query Compiler\n// ------\nconst QueryCompiler = require('../../../query/querycompiler');\n\nconst compact = require('lodash/compact');\nconst identity = require('lodash/identity');\nconst isEmpty = require('lodash/isEmpty');\n\nconst components = [\n  'columns',\n  'join',\n  'lock',\n  'where',\n  'union',\n  'group',\n  'having',\n  'order',\n  'limit',\n  'offset',\n];\n\nclass QueryCompiler_MSSQL extends QueryCompiler {\n  constructor(client, builder, formatter) {\n    super(client, builder, formatter);\n\n    const { onConflict } = this.single;\n    if (onConflict) {\n      throw new Error('.onConflict() is not supported for mssql.');\n    }\n\n    this._emptyInsertValue = 'default values';\n  }\n\n  select() {\n    const sql = this.with();\n    const statements = components.map((component) => this[component](this));\n    return sql + compact(statements).join(' ');\n  }\n\n  //#region Insert\n  // Compiles an \"insert\" query, allowing for multiple\n  // inserts using a single query statement.\n  insert() {\n    if (\n      this.single.options &&\n      this.single.options.includeTriggerModifications\n    ) {\n      return this.insertWithTriggers();\n    } else {\n      return this.standardInsert();\n    }\n  }\n\n  insertWithTriggers() {\n    const insertValues = this.single.insert || [];\n    const { returning } = this.single;\n    let sql =\n      this.with() +\n      `${this._buildTempTable(returning)}insert into ${this.tableName} `;\n    const returningSql = returning\n      ? this._returning('insert', returning, true) + ' '\n      : '';\n\n    if (Array.isArray(insertValues)) {\n      if (insertValues.length === 0) {\n        return '';\n      }\n    } else if (typeof insertValues === 'object' && isEmpty(insertValues)) {\n      return {\n        sql:\n          sql +\n          returningSql +\n          this._emptyInsertValue +\n          this._buildReturningSelect(returning),\n        returning,\n      };\n    }\n\n    const insertData = this._prepInsert(insertValues);\n    if (typeof insertData === 'string') {\n      sql += insertData;\n    } else {\n      if (insertData.columns.length) {\n        sql += `(${this.formatter.columnize(insertData.columns)}`;\n        sql += `) ${returningSql}values (`;\n        let i = -1;\n        while (++i < insertData.values.length) {\n          if (i !== 0) sql += '), (';\n          sql += this.client.parameterize(\n            insertData.values[i],\n            this.client.valueForUndefined,\n            this.builder,\n            this.bindingsHolder\n          );\n        }\n        sql += ')';\n      } else if (insertValues.length === 1 && insertValues[0]) {\n        sql += returningSql + this._emptyInsertValue;\n      } else {\n        sql = '';\n      }\n    }\n\n    if (returning) {\n      sql += this._buildReturningSelect(returning);\n    }\n\n    return {\n      sql,\n      returning,\n    };\n  }\n\n  standardInsert() {\n    const insertValues = this.single.insert || [];\n    let sql = this.with() + `insert into ${this.tableName} `;\n    const { returning } = this.single;\n    const returningSql = returning\n      ? this._returning('insert', returning) + ' '\n      : '';\n\n    if (Array.isArray(insertValues)) {\n      if (insertValues.length === 0) {\n        return '';\n      }\n    } else if (typeof insertValues === 'object' && isEmpty(insertValues)) {\n      return {\n        sql: sql + returningSql + this._emptyInsertValue,\n        returning,\n      };\n    }\n\n    const insertData = this._prepInsert(insertValues);\n    if (typeof insertData === 'string') {\n      sql += insertData;\n    } else {\n      if (insertData.columns.length) {\n        sql += `(${this.formatter.columnize(insertData.columns)}`;\n        sql += `) ${returningSql}values (`;\n        let i = -1;\n        while (++i < insertData.values.length) {\n          if (i !== 0) sql += '), (';\n          sql += this.client.parameterize(\n            insertData.values[i],\n            this.client.valueForUndefined,\n            this.builder,\n            this.bindingsHolder\n          );\n        }\n        sql += ')';\n      } else if (insertValues.length === 1 && insertValues[0]) {\n        sql += returningSql + this._emptyInsertValue;\n      } else {\n        sql = '';\n      }\n    }\n\n    return {\n      sql,\n      returning,\n    };\n  }\n  //#endregion\n\n  //#region Update\n  // Compiles an `update` query, allowing for a return value.\n  update() {\n    if (\n      this.single.options &&\n      this.single.options.includeTriggerModifications\n    ) {\n      return this.updateWithTriggers();\n    } else {\n      return this.standardUpdate();\n    }\n  }\n\n  updateWithTriggers() {\n    const top = this.top();\n    const withSQL = this.with();\n    const updates = this._prepUpdate(this.single.update);\n    const join = this.join();\n    const where = this.where();\n    const order = this.order();\n    const { returning } = this.single;\n    const declaredTemp = this._buildTempTable(returning);\n    return {\n      sql:\n        withSQL +\n        declaredTemp +\n        `update ${top ? top + ' ' : ''}${this.tableName}` +\n        ' set ' +\n        updates.join(', ') +\n        (returning ? ` ${this._returning('update', returning, true)}` : '') +\n        (join ? ` from ${this.tableName} ${join}` : '') +\n        (where ? ` ${where}` : '') +\n        (order ? ` ${order}` : '') +\n        (!returning\n          ? this._returning('rowcount', '@@rowcount')\n          : this._buildReturningSelect(returning)),\n      returning: returning || '@@rowcount',\n    };\n  }\n\n  standardUpdate() {\n    const top = this.top();\n    const withSQL = this.with();\n    const updates = this._prepUpdate(this.single.update);\n    const join = this.join();\n    const where = this.where();\n    const order = this.order();\n    const { returning } = this.single;\n    return {\n      sql:\n        withSQL +\n        `update ${top ? top + ' ' : ''}${this.tableName}` +\n        ' set ' +\n        updates.join(', ') +\n        (returning ? ` ${this._returning('update', returning)}` : '') +\n        (join ? ` from ${this.tableName} ${join}` : '') +\n        (where ? ` ${where}` : '') +\n        (order ? ` ${order}` : '') +\n        (!returning ? this._returning('rowcount', '@@rowcount') : ''),\n      returning: returning || '@@rowcount',\n    };\n  }\n  //#endregion\n\n  //#region Delete\n  // Compiles a `delete` query.\n  del() {\n    if (\n      this.single.options &&\n      this.single.options.includeTriggerModifications\n    ) {\n      return this.deleteWithTriggers();\n    } else {\n      return this.standardDelete();\n    }\n  }\n\n  deleteWithTriggers() {\n    // Make sure tableName is processed by the formatter first.\n    const withSQL = this.with();\n    const { tableName } = this;\n    const wheres = this.where();\n    const { returning } = this.single;\n    return {\n      sql:\n        withSQL +\n        `${this._buildTempTable(returning)}delete from ${tableName}` +\n        (returning ? ` ${this._returning('del', returning, true)}` : '') +\n        (wheres ? ` ${wheres}` : '') +\n        (!returning\n          ? this._returning('rowcount', '@@rowcount')\n          : this._buildReturningSelect(returning)),\n      returning: returning || '@@rowcount',\n    };\n  }\n\n  standardDelete() {\n    // Make sure tableName is processed by the formatter first.\n    const withSQL = this.with();\n    const { tableName } = this;\n    const wheres = this.where();\n    const { returning } = this.single;\n    return {\n      sql:\n        withSQL +\n        `delete from ${tableName}` +\n        (returning ? ` ${this._returning('del', returning)}` : '') +\n        (wheres ? ` ${wheres}` : '') +\n        (!returning ? this._returning('rowcount', '@@rowcount') : ''),\n      returning: returning || '@@rowcount',\n    };\n  }\n  //#endregion\n\n  // Compiles the columns in the query, specifying if an item was distinct.\n  columns() {\n    let distinctClause = '';\n    if (this.onlyUnions()) return '';\n    const top = this.top();\n    const hints = this._hintComments();\n    const columns = this.grouped.columns || [];\n    let i = -1,\n      sql = [];\n    if (columns) {\n      while (++i < columns.length) {\n        const stmt = columns[i];\n        if (stmt.distinct) distinctClause = 'distinct ';\n        if (stmt.distinctOn) {\n          distinctClause = this.distinctOn(stmt.value);\n          continue;\n        }\n        if (stmt.type === 'aggregate') {\n          sql.push(...this.aggregate(stmt));\n        } else if (stmt.type === 'aggregateRaw') {\n          sql.push(this.aggregateRaw(stmt));\n        } else if (stmt.type === 'analytic') {\n          sql.push(this.analytic(stmt));\n        } else if (stmt.value && stmt.value.length > 0) {\n          sql.push(this.formatter.columnize(stmt.value));\n        }\n      }\n    }\n    if (sql.length === 0) sql = ['*'];\n\n    return (\n      `select ${hints}${distinctClause}` +\n      (top ? top + ' ' : '') +\n      sql.join(', ') +\n      (this.tableName ? ` from ${this.tableName}` : '')\n    );\n  }\n\n  _returning(method, value, withTrigger) {\n    switch (method) {\n      case 'update':\n      case 'insert':\n        return value\n          ? `output ${this.formatter.columnizeWithPrefix('inserted.', value)}${\n              withTrigger ? ' into #out' : ''\n            }`\n          : '';\n      case 'del':\n        return value\n          ? `output ${this.formatter.columnizeWithPrefix('deleted.', value)}${\n              withTrigger ? ' into #out' : ''\n            }`\n          : '';\n      case 'rowcount':\n        return value ? ';select @@rowcount' : '';\n    }\n  }\n\n  _buildTempTable(values) {\n    // If value is nothing then return an empty string\n    if (values && values.length > 0) {\n      let selections = '';\n\n      // Build values that will be returned from this procedure\n      if (Array.isArray(values)) {\n        selections = values\n          .map((value) => `[t].${this.formatter.columnize(value)}`)\n          .join(',');\n      } else {\n        selections = `[t].${this.formatter.columnize(values)}`;\n      }\n\n      // Force #out to be correctly populated with the correct column structure.\n      let sql = `select top(0) ${selections} into #out `;\n      sql += `from ${this.tableName} as t `;\n      sql += `left join ${this.tableName} on 0=1;`;\n\n      return sql;\n    }\n\n    return '';\n  }\n\n  _buildReturningSelect(values) {\n    // If value is nothing then return an empty string\n    if (values && values.length > 0) {\n      let selections = '';\n\n      // Build columns to return\n      if (Array.isArray(values)) {\n        selections = values\n          .map((value) => `${this.formatter.columnize(value)}`)\n          .join(',');\n      } else {\n        selections = this.formatter.columnize(values);\n      }\n\n      // Get the returned values\n      let sql = `; select ${selections} from #out; `;\n      // Drop the temp table to prevent memory leaks\n      sql += `drop table #out;`;\n\n      return sql;\n    }\n\n    return '';\n  }\n\n  // Compiles a `truncate` query.\n  truncate() {\n    return `truncate table ${this.tableName}`;\n  }\n\n  forUpdate() {\n    // this doesn't work exacltly as it should, one should also mention index while locking\n    // https://stackoverflow.com/a/9818448/360060\n    return 'with (UPDLOCK)';\n  }\n\n  forShare() {\n    // http://www.sqlteam.com/article/introduction-to-locking-in-sql-server\n    return 'with (HOLDLOCK)';\n  }\n\n  // Compiles a `columnInfo` query.\n  columnInfo() {\n    const column = this.single.columnInfo;\n    let schema = this.single.schema;\n\n    // The user may have specified a custom wrapIdentifier function in the config. We\n    // need to run the identifiers through that function, but not format them as\n    // identifiers otherwise.\n    const table = this.client.customWrapIdentifier(this.single.table, identity);\n\n    if (schema) {\n      schema = this.client.customWrapIdentifier(schema, identity);\n    }\n\n    let sql = `select [COLUMN_NAME], [COLUMN_DEFAULT], [DATA_TYPE], [CHARACTER_MAXIMUM_LENGTH], [IS_NULLABLE] from information_schema.columns where table_name = ? and table_catalog = ?`;\n    const bindings = [table, this.client.database()];\n\n    if (schema) {\n      sql += ' and table_schema = ?';\n      bindings.push(schema);\n    } else {\n      sql += ` and table_schema = 'dbo'`;\n    }\n\n    return {\n      sql,\n      bindings: bindings,\n      output(resp) {\n        const out = resp.reduce((columns, val) => {\n          columns[val[0].value] = {\n            defaultValue: val[1].value,\n            type: val[2].value,\n            maxLength: val[3].value,\n            nullable: val[4].value === 'YES',\n          };\n          return columns;\n        }, {});\n        return (column && out[column]) || out;\n      },\n    };\n  }\n\n  top() {\n    const noLimit = !this.single.limit && this.single.limit !== 0;\n    const noOffset = !this.single.offset;\n    if (noLimit || !noOffset) return '';\n    return `top (${this.client.parameter(\n      this.single.limit,\n      this.builder,\n      this.bindingsHolder\n    )})`;\n  }\n\n  limit() {\n    return '';\n  }\n\n  offset() {\n    const noLimit = !this.single.limit && this.single.limit !== 0;\n    const noOffset = !this.single.offset;\n    if (noOffset) return '';\n    let offset = `offset ${\n      noOffset\n        ? '0'\n        : this.client.parameter(\n            this.single.offset,\n            this.builder,\n            this.bindingsHolder\n          )\n    } rows`;\n    if (!noLimit) {\n      offset += ` fetch next ${this.client.parameter(\n        this.single.limit,\n        this.builder,\n        this.bindingsHolder\n      )} rows only`;\n    }\n    return offset;\n  }\n}\n\n// Set the QueryBuilder & QueryCompiler on the client object,\n// in case anyone wants to modify things to suit their own purposes.\nmodule.exports = QueryCompiler_MSSQL;\n"]},"metadata":{},"sourceType":"script"}