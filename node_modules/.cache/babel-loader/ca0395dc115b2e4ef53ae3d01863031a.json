{"ast":null,"code":"// Transaction\n// -------\nconst {\n  EventEmitter\n} = require('events');\n\nconst Debug = require('debug');\n\nconst uniqueId = require('lodash/uniqueId');\n\nconst {\n  callbackify\n} = require('util');\n\nconst makeKnex = require('../knex-builder/make-knex');\n\nconst {\n  timeout,\n  KnexTimeoutError\n} = require('../util/timeout');\n\nconst finallyMixin = require('../util/finally-mixin');\n\nconst debug = Debug('knex:tx'); // FYI: This is defined as a function instead of a constant so that\n//      each Transactor can have its own copy of the default config.\n//      This will minimize the impact of bugs that might be introduced\n//      if a Transactor ever mutates its config.\n\nfunction DEFAULT_CONFIG() {\n  return {\n    userParams: {},\n    doNotRejectOnRollback: true\n  };\n} // These aren't supported in sqlite3 which is serialized already so it's as\n// safe as reasonable, except for a special read_uncommitted pragma\n\n\nconst validIsolationLevels = [// Doesn't really work in postgres, it treats it as read committed\n'read uncommitted', 'read committed', 'snapshot', // snapshot and repeatable read are basically the same, most \"repeatable\n// read\" implementations are actually \"snapshot\" also known as Multi Version\n// Concurrency Control (MVCC). Mssql's repeatable read doesn't stop\n// repeated reads for inserts as it uses a pessimistic locking system so\n// you should probably use 'snapshot' to stop read skew.\n'repeatable read', // mysql pretends to have serializable, but it is not\n'serializable']; // Acts as a facade for a Promise, keeping the internal state\n// and managing any child transactions.\n\nclass Transaction extends EventEmitter {\n  constructor(client, container, config = DEFAULT_CONFIG(), outerTx = null) {\n    super();\n    this.userParams = config.userParams;\n    this.doNotRejectOnRollback = config.doNotRejectOnRollback;\n    const txid = this.txid = uniqueId('trx');\n    this.client = client;\n    this.logger = client.logger;\n    this.outerTx = outerTx;\n    this.trxClient = undefined;\n    this._completed = false;\n    this._debug = client.config && client.config.debug;\n\n    if (config.isolationLevel) {\n      this.setIsolationLevel(config.isolationLevel);\n    }\n\n    debug('%s: Starting %s transaction', txid, outerTx ? 'nested' : 'top level'); // `this` can potentially serve as an `outerTx` for another\n    // Transaction.  So, go ahead and establish `_lastChild` now.\n\n    this._lastChild = Promise.resolve();\n\n    const _previousSibling = outerTx ? outerTx._lastChild : Promise.resolve(); // FYI: As you will see in a moment, this Promise will be used to construct\n    //      2 separate Promise Chains.  This ensures that each Promise Chain\n    //      can establish its error-handling semantics without interfering\n    //      with the other Promise Chain.\n\n\n    const basePromise = _previousSibling.then(() => this._evaluateContainer(config, container)); // FYI: This is the Promise Chain for EXTERNAL use.  It ensures that the\n    //      caller must handle any exceptions that result from `basePromise`.\n\n\n    this._promise = basePromise.then(x => x);\n\n    if (outerTx) {\n      // FYI: This is the Promise Chain for INTERNAL use.  It serves as a signal\n      //      for when the next sibling should begin its execution.  Therefore,\n      //      exceptions are caught and ignored.\n      outerTx._lastChild = basePromise.catch(() => {});\n    }\n  }\n\n  isCompleted() {\n    return this._completed || this.outerTx && this.outerTx.isCompleted() || false;\n  }\n\n  begin(conn) {\n    const runIsolationLevelQuery = this.isolationLevel ? this.query(conn, `SET TRANSACTION ISOLATION LEVEL ${this.isolationLevel};`) : Promise.resolve();\n    return runIsolationLevelQuery.then(() => this.query(conn, 'BEGIN;'));\n  }\n\n  savepoint(conn) {\n    return this.query(conn, `SAVEPOINT ${this.txid};`);\n  }\n\n  commit(conn, value) {\n    return this.query(conn, 'COMMIT;', 1, value);\n  }\n\n  release(conn, value) {\n    return this.query(conn, `RELEASE SAVEPOINT ${this.txid};`, 1, value);\n  }\n\n  setIsolationLevel(isolationLevel) {\n    if (!validIsolationLevels.includes(isolationLevel)) {\n      throw new Error(`Invalid isolationLevel, supported isolation levels are: ${JSON.stringify(validIsolationLevels)}`);\n    }\n\n    this.isolationLevel = isolationLevel;\n    return this;\n  }\n\n  rollback(conn, error) {\n    return timeout(this.query(conn, 'ROLLBACK', 2, error), 5000).catch(err => {\n      if (!(err instanceof KnexTimeoutError)) {\n        return Promise.reject(err);\n      }\n\n      this._rejecter(error);\n    });\n  }\n\n  rollbackTo(conn, error) {\n    return timeout(this.query(conn, `ROLLBACK TO SAVEPOINT ${this.txid}`, 2, error), 5000).catch(err => {\n      if (!(err instanceof KnexTimeoutError)) {\n        return Promise.reject(err);\n      }\n\n      this._rejecter(error);\n    });\n  }\n\n  query(conn, sql, status, value) {\n    const q = this.trxClient.query(conn, sql).catch(err => {\n      status = 2;\n      value = err;\n      this._completed = true;\n      debug('%s error running transaction query', this.txid);\n    }).then(res => {\n      if (status === 1) {\n        this._resolver(value);\n      }\n\n      if (status === 2) {\n        if (value === undefined) {\n          if (this.doNotRejectOnRollback && /^ROLLBACK\\b/i.test(sql)) {\n            this._resolver();\n\n            return;\n          }\n\n          value = new Error(`Transaction rejected with non-error: ${value}`);\n        }\n\n        this._rejecter(value);\n      }\n\n      return res;\n    });\n\n    if (status === 1 || status === 2) {\n      this._completed = true;\n    }\n\n    return q;\n  }\n\n  debug(enabled) {\n    this._debug = arguments.length ? enabled : true;\n    return this;\n  }\n\n  async _evaluateContainer(config, container) {\n    return this.acquireConnection(config, connection => {\n      const trxClient = this.trxClient = makeTxClient(this, this.client, connection);\n      const init = this.client.transacting ? this.savepoint(connection) : this.begin(connection);\n      const executionPromise = new Promise((resolver, rejecter) => {\n        this._resolver = resolver;\n        this._rejecter = rejecter;\n      });\n      init.then(() => {\n        return makeTransactor(this, connection, trxClient);\n      }).then(transactor => {\n        transactor.executionPromise = executionPromise; // If we've returned a \"thenable\" from the transaction container, assume\n        // the rollback and commit are chained to this object's success / failure.\n        // Directly thrown errors are treated as automatic rollbacks.\n\n        let result;\n\n        try {\n          result = container(transactor);\n        } catch (err) {\n          result = Promise.reject(err);\n        }\n\n        if (result && result.then && typeof result.then === 'function') {\n          result.then(val => {\n            return transactor.commit(val);\n          }).catch(err => {\n            return transactor.rollback(err);\n          });\n        }\n\n        return null;\n      }).catch(e => {\n        return this._rejecter(e);\n      });\n      return executionPromise;\n    });\n  } // Acquire a connection and create a disposer - either using the one passed\n  // via config or getting one off the client. The disposer will be called once\n  // the original promise is marked completed.\n\n\n  async acquireConnection(config, cb) {\n    const configConnection = config && config.connection;\n    const connection = configConnection || (await this.client.acquireConnection());\n\n    try {\n      connection.__knexTxId = this.txid;\n      return await cb(connection);\n    } finally {\n      if (!configConnection) {\n        debug('%s: releasing connection', this.txid);\n        this.client.releaseConnection(connection);\n      } else {\n        debug('%s: not releasing external connection', this.txid);\n      }\n    }\n  }\n\n  then(onResolve, onReject) {\n    return this._promise.then(onResolve, onReject);\n  }\n\n  catch(onReject) {\n    return this._promise.catch(onReject);\n  }\n\n  asCallback(cb) {\n    callbackify(() => this._promise)(cb);\n    return this._promise;\n  }\n\n}\n\nfinallyMixin(Transaction.prototype); // The transactor is a full featured knex object, with a \"commit\", a \"rollback\"\n// and a \"savepoint\" function. The \"savepoint\" is just sugar for creating a new\n// transaction. If the rollback is run inside a savepoint, it rolls back to the\n// last savepoint - otherwise it rolls back the transaction.\n\nfunction makeTransactor(trx, connection, trxClient) {\n  const transactor = makeKnex(trxClient);\n\n  transactor.context.withUserParams = () => {\n    throw new Error('Cannot set user params on a transaction - it can only inherit params from main knex instance');\n  };\n\n  transactor.isTransaction = true;\n  transactor.userParams = trx.userParams || {};\n\n  transactor.context.transaction = function (container, options) {\n    if (!options) {\n      options = {\n        doNotRejectOnRollback: true\n      };\n    } else if (options.doNotRejectOnRollback === undefined) {\n      options.doNotRejectOnRollback = true;\n    }\n\n    return this._transaction(container, options, trx);\n  };\n\n  transactor.savepoint = function (container, options) {\n    return transactor.transaction(container, options);\n  };\n\n  if (trx.client.transacting) {\n    transactor.commit = value => trx.release(connection, value);\n\n    transactor.rollback = error => trx.rollbackTo(connection, error);\n  } else {\n    transactor.commit = value => trx.commit(connection, value);\n\n    transactor.rollback = error => trx.rollback(connection, error);\n  }\n\n  transactor.isCompleted = () => trx.isCompleted();\n\n  return transactor;\n} // We need to make a client object which always acquires the same\n// connection and does not release back into the pool.\n\n\nfunction makeTxClient(trx, client, connection) {\n  const trxClient = Object.create(client.constructor.prototype);\n  trxClient.version = client.version;\n  trxClient.config = client.config;\n  trxClient.driver = client.driver;\n  trxClient.connectionSettings = client.connectionSettings;\n  trxClient.transacting = true;\n  trxClient.valueForUndefined = client.valueForUndefined;\n  trxClient.logger = client.logger;\n  trxClient.on('start', function (arg) {\n    trx.emit('start', arg);\n    client.emit('start', arg);\n  });\n  trxClient.on('query', function (arg) {\n    trx.emit('query', arg);\n    client.emit('query', arg);\n  });\n  trxClient.on('query-error', function (err, obj) {\n    trx.emit('query-error', err, obj);\n    client.emit('query-error', err, obj);\n  });\n  trxClient.on('query-response', function (response, obj, builder) {\n    trx.emit('query-response', response, obj, builder);\n    client.emit('query-response', response, obj, builder);\n  });\n  const _query = trxClient.query;\n\n  trxClient.query = function (conn, obj) {\n    const completed = trx.isCompleted();\n    return new Promise(function (resolve, reject) {\n      try {\n        if (conn !== connection) throw new Error('Invalid connection for transaction query.');\n        if (completed) completedError(trx, obj);\n        resolve(_query.call(trxClient, conn, obj));\n      } catch (e) {\n        reject(e);\n      }\n    });\n  };\n\n  const _stream = trxClient.stream;\n\n  trxClient.stream = function (conn, obj, stream, options) {\n    const completed = trx.isCompleted();\n    return new Promise(function (resolve, reject) {\n      try {\n        if (conn !== connection) throw new Error('Invalid connection for transaction query.');\n        if (completed) completedError(trx, obj);\n        resolve(_stream.call(trxClient, conn, obj, stream, options));\n      } catch (e) {\n        reject(e);\n      }\n    });\n  };\n\n  trxClient.acquireConnection = function () {\n    return Promise.resolve(connection);\n  };\n\n  trxClient.releaseConnection = function () {\n    return Promise.resolve();\n  };\n\n  return trxClient;\n}\n\nfunction completedError(trx, obj) {\n  const sql = typeof obj === 'string' ? obj : obj && obj.sql;\n  debug('%s: Transaction completed: %s', trx.txid, sql);\n  throw new Error('Transaction query already complete, run with DEBUG=knex:tx for more info');\n}\n\nmodule.exports = Transaction;","map":{"version":3,"sources":["/home/rosiane/Projeto-completo/back/node_modules/knex/lib/execution/transaction.js"],"names":["EventEmitter","require","Debug","uniqueId","callbackify","makeKnex","timeout","KnexTimeoutError","finallyMixin","debug","DEFAULT_CONFIG","userParams","doNotRejectOnRollback","validIsolationLevels","Transaction","constructor","client","container","config","outerTx","txid","logger","trxClient","undefined","_completed","_debug","isolationLevel","setIsolationLevel","_lastChild","Promise","resolve","_previousSibling","basePromise","then","_evaluateContainer","_promise","x","catch","isCompleted","begin","conn","runIsolationLevelQuery","query","savepoint","commit","value","release","includes","Error","JSON","stringify","rollback","error","err","reject","_rejecter","rollbackTo","sql","status","q","res","_resolver","test","enabled","arguments","length","acquireConnection","connection","makeTxClient","init","transacting","executionPromise","resolver","rejecter","makeTransactor","transactor","result","val","e","cb","configConnection","__knexTxId","releaseConnection","onResolve","onReject","asCallback","prototype","trx","context","withUserParams","isTransaction","transaction","options","_transaction","Object","create","version","driver","connectionSettings","valueForUndefined","on","arg","emit","obj","response","builder","_query","completed","completedError","call","_stream","stream","module","exports"],"mappings":"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","sourcesContent":["// Transaction\n// -------\nconst { EventEmitter } = require('events');\nconst Debug = require('debug');\nconst uniqueId = require('lodash/uniqueId');\nconst { callbackify } = require('util');\n\nconst makeKnex = require('../knex-builder/make-knex');\nconst { timeout, KnexTimeoutError } = require('../util/timeout');\nconst finallyMixin = require('../util/finally-mixin');\n\nconst debug = Debug('knex:tx');\n\n// FYI: This is defined as a function instead of a constant so that\n//      each Transactor can have its own copy of the default config.\n//      This will minimize the impact of bugs that might be introduced\n//      if a Transactor ever mutates its config.\nfunction DEFAULT_CONFIG() {\n  return {\n    userParams: {},\n    doNotRejectOnRollback: true,\n  };\n}\n// These aren't supported in sqlite3 which is serialized already so it's as\n// safe as reasonable, except for a special read_uncommitted pragma\nconst validIsolationLevels = [\n  // Doesn't really work in postgres, it treats it as read committed\n  'read uncommitted',\n  'read committed',\n  'snapshot',\n  // snapshot and repeatable read are basically the same, most \"repeatable\n  // read\" implementations are actually \"snapshot\" also known as Multi Version\n  // Concurrency Control (MVCC). Mssql's repeatable read doesn't stop\n  // repeated reads for inserts as it uses a pessimistic locking system so\n  // you should probably use 'snapshot' to stop read skew.\n  'repeatable read',\n  // mysql pretends to have serializable, but it is not\n  'serializable',\n];\n\n// Acts as a facade for a Promise, keeping the internal state\n// and managing any child transactions.\nclass Transaction extends EventEmitter {\n  constructor(client, container, config = DEFAULT_CONFIG(), outerTx = null) {\n    super();\n    this.userParams = config.userParams;\n    this.doNotRejectOnRollback = config.doNotRejectOnRollback;\n\n    const txid = (this.txid = uniqueId('trx'));\n\n    this.client = client;\n    this.logger = client.logger;\n    this.outerTx = outerTx;\n    this.trxClient = undefined;\n    this._completed = false;\n    this._debug = client.config && client.config.debug;\n\n    if (config.isolationLevel) {\n      this.setIsolationLevel(config.isolationLevel);\n    }\n\n    debug(\n      '%s: Starting %s transaction',\n      txid,\n      outerTx ? 'nested' : 'top level'\n    );\n\n    // `this` can potentially serve as an `outerTx` for another\n    // Transaction.  So, go ahead and establish `_lastChild` now.\n    this._lastChild = Promise.resolve();\n\n    const _previousSibling = outerTx ? outerTx._lastChild : Promise.resolve();\n\n    // FYI: As you will see in a moment, this Promise will be used to construct\n    //      2 separate Promise Chains.  This ensures that each Promise Chain\n    //      can establish its error-handling semantics without interfering\n    //      with the other Promise Chain.\n    const basePromise = _previousSibling.then(() =>\n      this._evaluateContainer(config, container)\n    );\n\n    // FYI: This is the Promise Chain for EXTERNAL use.  It ensures that the\n    //      caller must handle any exceptions that result from `basePromise`.\n    this._promise = basePromise.then((x) => x);\n\n    if (outerTx) {\n      // FYI: This is the Promise Chain for INTERNAL use.  It serves as a signal\n      //      for when the next sibling should begin its execution.  Therefore,\n      //      exceptions are caught and ignored.\n      outerTx._lastChild = basePromise.catch(() => {});\n    }\n  }\n\n  isCompleted() {\n    return (\n      this._completed || (this.outerTx && this.outerTx.isCompleted()) || false\n    );\n  }\n\n  begin(conn) {\n    const runIsolationLevelQuery = this.isolationLevel\n      ? this.query(\n          conn,\n          `SET TRANSACTION ISOLATION LEVEL ${this.isolationLevel};`\n        )\n      : Promise.resolve();\n    return runIsolationLevelQuery.then(() => this.query(conn, 'BEGIN;'));\n  }\n\n  savepoint(conn) {\n    return this.query(conn, `SAVEPOINT ${this.txid};`);\n  }\n\n  commit(conn, value) {\n    return this.query(conn, 'COMMIT;', 1, value);\n  }\n\n  release(conn, value) {\n    return this.query(conn, `RELEASE SAVEPOINT ${this.txid};`, 1, value);\n  }\n\n  setIsolationLevel(isolationLevel) {\n    if (!validIsolationLevels.includes(isolationLevel)) {\n      throw new Error(\n        `Invalid isolationLevel, supported isolation levels are: ${JSON.stringify(\n          validIsolationLevels\n        )}`\n      );\n    }\n    this.isolationLevel = isolationLevel;\n    return this;\n  }\n\n  rollback(conn, error) {\n    return timeout(this.query(conn, 'ROLLBACK', 2, error), 5000).catch(\n      (err) => {\n        if (!(err instanceof KnexTimeoutError)) {\n          return Promise.reject(err);\n        }\n        this._rejecter(error);\n      }\n    );\n  }\n\n  rollbackTo(conn, error) {\n    return timeout(\n      this.query(conn, `ROLLBACK TO SAVEPOINT ${this.txid}`, 2, error),\n      5000\n    ).catch((err) => {\n      if (!(err instanceof KnexTimeoutError)) {\n        return Promise.reject(err);\n      }\n      this._rejecter(error);\n    });\n  }\n\n  query(conn, sql, status, value) {\n    const q = this.trxClient\n      .query(conn, sql)\n      .catch((err) => {\n        status = 2;\n        value = err;\n        this._completed = true;\n        debug('%s error running transaction query', this.txid);\n      })\n      .then((res) => {\n        if (status === 1) {\n          this._resolver(value);\n        }\n        if (status === 2) {\n          if (value === undefined) {\n            if (this.doNotRejectOnRollback && /^ROLLBACK\\b/i.test(sql)) {\n              this._resolver();\n              return;\n            }\n\n            value = new Error(`Transaction rejected with non-error: ${value}`);\n          }\n          this._rejecter(value);\n        }\n        return res;\n      });\n    if (status === 1 || status === 2) {\n      this._completed = true;\n    }\n    return q;\n  }\n\n  debug(enabled) {\n    this._debug = arguments.length ? enabled : true;\n    return this;\n  }\n\n  async _evaluateContainer(config, container) {\n    return this.acquireConnection(config, (connection) => {\n      const trxClient = (this.trxClient = makeTxClient(\n        this,\n        this.client,\n        connection\n      ));\n      const init = this.client.transacting\n        ? this.savepoint(connection)\n        : this.begin(connection);\n      const executionPromise = new Promise((resolver, rejecter) => {\n        this._resolver = resolver;\n        this._rejecter = rejecter;\n      });\n\n      init\n        .then(() => {\n          return makeTransactor(this, connection, trxClient);\n        })\n        .then((transactor) => {\n          transactor.executionPromise = executionPromise;\n\n          // If we've returned a \"thenable\" from the transaction container, assume\n          // the rollback and commit are chained to this object's success / failure.\n          // Directly thrown errors are treated as automatic rollbacks.\n          let result;\n          try {\n            result = container(transactor);\n          } catch (err) {\n            result = Promise.reject(err);\n          }\n          if (result && result.then && typeof result.then === 'function') {\n            result\n              .then((val) => {\n                return transactor.commit(val);\n              })\n              .catch((err) => {\n                return transactor.rollback(err);\n              });\n          }\n          return null;\n        })\n        .catch((e) => {\n          return this._rejecter(e);\n        });\n\n      return executionPromise;\n    });\n  }\n\n  // Acquire a connection and create a disposer - either using the one passed\n  // via config or getting one off the client. The disposer will be called once\n  // the original promise is marked completed.\n  async acquireConnection(config, cb) {\n    const configConnection = config && config.connection;\n    const connection =\n      configConnection || (await this.client.acquireConnection());\n\n    try {\n      connection.__knexTxId = this.txid;\n      return await cb(connection);\n    } finally {\n      if (!configConnection) {\n        debug('%s: releasing connection', this.txid);\n        this.client.releaseConnection(connection);\n      } else {\n        debug('%s: not releasing external connection', this.txid);\n      }\n    }\n  }\n\n  then(onResolve, onReject) {\n    return this._promise.then(onResolve, onReject);\n  }\n\n  catch(onReject) {\n    return this._promise.catch(onReject);\n  }\n\n  asCallback(cb) {\n    callbackify(() => this._promise)(cb);\n    return this._promise;\n  }\n}\nfinallyMixin(Transaction.prototype);\n\n// The transactor is a full featured knex object, with a \"commit\", a \"rollback\"\n// and a \"savepoint\" function. The \"savepoint\" is just sugar for creating a new\n// transaction. If the rollback is run inside a savepoint, it rolls back to the\n// last savepoint - otherwise it rolls back the transaction.\nfunction makeTransactor(trx, connection, trxClient) {\n  const transactor = makeKnex(trxClient);\n\n  transactor.context.withUserParams = () => {\n    throw new Error(\n      'Cannot set user params on a transaction - it can only inherit params from main knex instance'\n    );\n  };\n\n  transactor.isTransaction = true;\n  transactor.userParams = trx.userParams || {};\n\n  transactor.context.transaction = function (container, options) {\n    if (!options) {\n      options = { doNotRejectOnRollback: true };\n    } else if (options.doNotRejectOnRollback === undefined) {\n      options.doNotRejectOnRollback = true;\n    }\n\n    return this._transaction(container, options, trx);\n  };\n\n  transactor.savepoint = function (container, options) {\n    return transactor.transaction(container, options);\n  };\n\n  if (trx.client.transacting) {\n    transactor.commit = (value) => trx.release(connection, value);\n    transactor.rollback = (error) => trx.rollbackTo(connection, error);\n  } else {\n    transactor.commit = (value) => trx.commit(connection, value);\n    transactor.rollback = (error) => trx.rollback(connection, error);\n  }\n\n  transactor.isCompleted = () => trx.isCompleted();\n\n  return transactor;\n}\n\n// We need to make a client object which always acquires the same\n// connection and does not release back into the pool.\nfunction makeTxClient(trx, client, connection) {\n  const trxClient = Object.create(client.constructor.prototype);\n  trxClient.version = client.version;\n  trxClient.config = client.config;\n  trxClient.driver = client.driver;\n  trxClient.connectionSettings = client.connectionSettings;\n  trxClient.transacting = true;\n  trxClient.valueForUndefined = client.valueForUndefined;\n  trxClient.logger = client.logger;\n\n  trxClient.on('start', function (arg) {\n    trx.emit('start', arg);\n    client.emit('start', arg);\n  });\n\n  trxClient.on('query', function (arg) {\n    trx.emit('query', arg);\n    client.emit('query', arg);\n  });\n\n  trxClient.on('query-error', function (err, obj) {\n    trx.emit('query-error', err, obj);\n    client.emit('query-error', err, obj);\n  });\n\n  trxClient.on('query-response', function (response, obj, builder) {\n    trx.emit('query-response', response, obj, builder);\n    client.emit('query-response', response, obj, builder);\n  });\n\n  const _query = trxClient.query;\n  trxClient.query = function (conn, obj) {\n    const completed = trx.isCompleted();\n    return new Promise(function (resolve, reject) {\n      try {\n        if (conn !== connection)\n          throw new Error('Invalid connection for transaction query.');\n        if (completed) completedError(trx, obj);\n        resolve(_query.call(trxClient, conn, obj));\n      } catch (e) {\n        reject(e);\n      }\n    });\n  };\n  const _stream = trxClient.stream;\n  trxClient.stream = function (conn, obj, stream, options) {\n    const completed = trx.isCompleted();\n    return new Promise(function (resolve, reject) {\n      try {\n        if (conn !== connection)\n          throw new Error('Invalid connection for transaction query.');\n        if (completed) completedError(trx, obj);\n        resolve(_stream.call(trxClient, conn, obj, stream, options));\n      } catch (e) {\n        reject(e);\n      }\n    });\n  };\n  trxClient.acquireConnection = function () {\n    return Promise.resolve(connection);\n  };\n  trxClient.releaseConnection = function () {\n    return Promise.resolve();\n  };\n\n  return trxClient;\n}\n\nfunction completedError(trx, obj) {\n  const sql = typeof obj === 'string' ? obj : obj && obj.sql;\n  debug('%s: Transaction completed: %s', trx.txid, sql);\n  throw new Error(\n    'Transaction query already complete, run with DEBUG=knex:tx for more info'\n  );\n}\n\nmodule.exports = Transaction;\n"]},"metadata":{},"sourceType":"script"}