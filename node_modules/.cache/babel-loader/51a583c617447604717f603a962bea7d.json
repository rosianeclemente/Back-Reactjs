{"ast":null,"code":"// Builder\n// -------\nconst assert = require('assert');\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst assign = require('lodash/assign');\n\nconst clone = require('lodash/clone');\n\nconst each = require('lodash/each');\n\nconst isEmpty = require('lodash/isEmpty');\n\nconst isPlainObject = require('lodash/isPlainObject');\n\nconst last = require('lodash/last');\n\nconst reject = require('lodash/reject');\n\nconst tail = require('lodash/tail');\n\nconst toArray = require('lodash/toArray');\n\nconst {\n  addQueryContext,\n  normalizeArr\n} = require('../util/helpers');\n\nconst JoinClause = require('./joinclause');\n\nconst Analytic = require('./analytic');\n\nconst saveAsyncStack = require('../util/save-async-stack');\n\nconst {\n  isBoolean,\n  isNumber,\n  isObject,\n  isString,\n  isFunction\n} = require('../util/is');\n\nconst {\n  lockMode,\n  waitMode\n} = require('./constants');\n\nconst {\n  augmentWithBuilderInterface\n} = require('../builder-interface-augmenter');\n\nconst SELECT_COMMANDS = new Set(['pluck', 'first', 'select']);\nconst CLEARABLE_STATEMENTS = new Set(['with', 'select', 'columns', 'hintComments', 'where', 'union', 'join', 'group', 'order', 'having', 'limit', 'offset', 'counter', 'counters']);\nconst LOCK_MODES = new Set([lockMode.forShare, lockMode.forUpdate]); // Typically called from `knex.builder`,\n// start a new query building chain.\n\nclass Builder extends EventEmitter {\n  constructor(client) {\n    super();\n    this.client = client;\n    this.and = this;\n    this._single = {};\n    this._statements = [];\n    this._method = 'select';\n\n    if (client.config) {\n      saveAsyncStack(this, 5);\n      this._debug = client.config.debug;\n    } // Internal flags used in the builder.\n\n\n    this._joinFlag = 'inner';\n    this._boolFlag = 'and';\n    this._notFlag = false;\n    this._asColumnFlag = false;\n  }\n\n  toString() {\n    return this.toQuery();\n  } // Convert the current query \"toSQL\"\n\n\n  toSQL(method, tz) {\n    return this.client.queryCompiler(this).toSQL(method || this._method, tz);\n  } // Create a shallow clone of the current query builder.\n\n\n  clone() {\n    const cloned = new this.constructor(this.client);\n    cloned._method = this._method;\n    cloned._single = clone(this._single);\n    cloned._statements = clone(this._statements);\n    cloned._debug = this._debug; // `_option` is assigned by the `Interface` mixin.\n\n    if (this._options !== undefined) {\n      cloned._options = clone(this._options);\n    }\n\n    if (this._queryContext !== undefined) {\n      cloned._queryContext = clone(this._queryContext);\n    }\n\n    if (this._connection !== undefined) {\n      cloned._connection = this._connection;\n    }\n\n    return cloned;\n  }\n\n  timeout(ms, {\n    cancel\n  } = {}) {\n    if (isNumber(ms) && ms > 0) {\n      this._timeout = ms;\n\n      if (cancel) {\n        this.client.assertCanCancelQuery();\n        this._cancelOnTimeout = true;\n      }\n    }\n\n    return this;\n  } // With\n  // ------\n\n\n  with(alias, statement) {\n    validateWithArgs(alias, statement, 'with');\n    return this.withWrapped(alias, statement);\n  } // Helper for compiling any advanced `with` queries.\n\n\n  withWrapped(alias, query) {\n    this._statements.push({\n      grouping: 'with',\n      type: 'withWrapped',\n      alias: alias,\n      value: query\n    });\n\n    return this;\n  } // With Recursive\n  // ------\n\n\n  withRecursive(alias, statement) {\n    validateWithArgs(alias, statement, 'withRecursive');\n    return this.withRecursiveWrapped(alias, statement);\n  } // Helper for compiling any advanced `withRecursive` queries.\n\n\n  withRecursiveWrapped(alias, query) {\n    this.withWrapped(alias, query);\n    this._statements[this._statements.length - 1].recursive = true;\n    return this;\n  } // Select\n  // ------\n  // Adds a column or columns to the list of \"columns\"\n  // being selected on the query.\n\n\n  columns(column) {\n    if (!column && column !== 0) return this;\n\n    this._statements.push({\n      grouping: 'columns',\n      value: normalizeArr(...arguments)\n    });\n\n    return this;\n  } // Allow for a sub-select to be explicitly aliased as a column,\n  // without needing to compile the query in a where.\n\n\n  as(column) {\n    this._single.as = column;\n    return this;\n  } // Adds a single hint or an array of hits to the list of \"hintComments\" on the query.\n\n\n  hintComment(hints) {\n    hints = Array.isArray(hints) ? hints : [hints];\n\n    if (hints.some(hint => !isString(hint))) {\n      throw new Error('Hint comment must be a string');\n    }\n\n    if (hints.some(hint => hint.includes('/*') || hint.includes('*/'))) {\n      throw new Error('Hint comment cannot include \"/*\" or \"*/\"');\n    }\n\n    if (hints.some(hint => hint.includes('?'))) {\n      throw new Error('Hint comment cannot include \"?\"');\n    }\n\n    this._statements.push({\n      grouping: 'hintComments',\n      value: hints\n    });\n\n    return this;\n  } // Prepends the `schemaName` on `tableName` defined by `.table` and `.join`.\n\n\n  withSchema(schemaName) {\n    this._single.schema = schemaName;\n    return this;\n  } // Sets the `tableName` on the query.\n  // Alias to \"from\" for select and \"into\" for insert statements\n  // e.g. builder.insert({a: value}).into('tableName')\n  // `options`: options object containing keys:\n  //   - `only`: whether the query should use SQL's ONLY to not return\n  //           inheriting table data. Defaults to false.\n\n\n  table(tableName, options = {}) {\n    this._single.table = tableName;\n    this._single.only = options.only === true;\n    return this;\n  } // Adds a `distinct` clause to the query.\n\n\n  distinct(...args) {\n    this._statements.push({\n      grouping: 'columns',\n      value: normalizeArr(...args),\n      distinct: true\n    });\n\n    return this;\n  }\n\n  distinctOn(...args) {\n    if (isEmpty(args)) {\n      throw new Error('distinctOn requires at least on argument');\n    }\n\n    this._statements.push({\n      grouping: 'columns',\n      value: normalizeArr(...args),\n      distinctOn: true\n    });\n\n    return this;\n  } // Adds a join clause to the query, allowing for advanced joins\n  // with an anonymous function as the second argument.\n  // function(table, first, operator, second)\n\n\n  join(table, first, ...args) {\n    let join;\n    const schema = table instanceof Builder || typeof table === 'function' ? undefined : this._single.schema;\n\n    const joinType = this._joinType();\n\n    if (typeof first === 'function') {\n      join = new JoinClause(table, joinType, schema);\n      first.call(join, join);\n    } else if (joinType === 'raw') {\n      join = new JoinClause(this.client.raw(table, first), 'raw');\n    } else {\n      join = new JoinClause(table, joinType, schema);\n\n      if (first) {\n        join.on(first, ...args);\n      }\n    }\n\n    this._statements.push(join);\n\n    return this;\n  } // JOIN blocks:\n\n\n  innerJoin(...args) {\n    return this._joinType('inner').join(...args);\n  }\n\n  leftJoin(...args) {\n    return this._joinType('left').join(...args);\n  }\n\n  leftOuterJoin(...args) {\n    return this._joinType('left outer').join(...args);\n  }\n\n  rightJoin(...args) {\n    return this._joinType('right').join(...args);\n  }\n\n  rightOuterJoin(...args) {\n    return this._joinType('right outer').join(...args);\n  }\n\n  outerJoin(...args) {\n    return this._joinType('outer').join(...args);\n  }\n\n  fullOuterJoin(...args) {\n    return this._joinType('full outer').join(...args);\n  }\n\n  crossJoin(...args) {\n    return this._joinType('cross').join(...args);\n  }\n\n  joinRaw(...args) {\n    return this._joinType('raw').join(...args);\n  } // Where modifiers:\n\n\n  get or() {\n    return this._bool('or');\n  }\n\n  get not() {\n    return this._not(true);\n  } // The where function can be used in several ways:\n  // The most basic is `where(key, value)`, which expands to\n  // where key = value.\n\n\n  where(column, operator, value) {\n    const argsLength = arguments.length; // Support \"where true || where false\"\n\n    if (column === false || column === true) {\n      return this.where(1, '=', column ? 1 : 0);\n    } // Check if the column is a function, in which case it's\n    // a where statement wrapped in parens.\n\n\n    if (typeof column === 'function') {\n      return this.whereWrapped(column);\n    } // Allows `where({id: 2})` syntax.\n\n\n    if (isObject(column) && !column.isRawInstance) return this._objectWhere(column); // Allow a raw statement to be passed along to the query.\n\n    if (column && column.isRawInstance && argsLength === 1) return this.whereRaw(column); // Enable the where('key', value) syntax, only when there\n    // are explicitly two arguments passed, so it's not possible to\n    // do where('key', '!=') and have that turn into where key != null\n\n    if (argsLength === 2) {\n      value = operator;\n      operator = '='; // If the value is null, and it's a two argument query,\n      // we assume we're going for a `whereNull`.\n\n      if (value === null) {\n        return this.whereNull(column);\n      }\n    } // lower case the operator for comparison purposes\n\n\n    const checkOperator = `${operator}`.toLowerCase().trim(); // If there are 3 arguments, check whether 'in' is one of them.\n\n    if (argsLength === 3) {\n      if (checkOperator === 'in' || checkOperator === 'not in') {\n        return this._not(checkOperator === 'not in').whereIn(column, value);\n      }\n\n      if (checkOperator === 'between' || checkOperator === 'not between') {\n        return this._not(checkOperator === 'not between').whereBetween(column, value);\n      }\n    } // If the value is still null, check whether they're meaning\n    // where value is null\n\n\n    if (value === null) {\n      // Check for .where(key, 'is', null) or .where(key, 'is not', 'null');\n      if (checkOperator === 'is' || checkOperator === 'is not') {\n        return this._not(checkOperator === 'is not').whereNull(column);\n      }\n    } // Push onto the where statement stack.\n\n\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereBasic',\n      column,\n      operator,\n      value,\n      not: this._not(),\n      bool: this._bool(),\n      asColumn: this._asColumnFlag\n    });\n\n    return this;\n  }\n\n  whereColumn(...args) {\n    this._asColumnFlag = true;\n    this.where(...args);\n    this._asColumnFlag = false;\n    return this;\n  } // Adds an `or where` clause to the query.\n\n\n  orWhere(column, ...args) {\n    this._bool('or');\n\n    const obj = column;\n\n    if (isObject(obj) && !obj.isRawInstance) {\n      return this.whereWrapped(function () {\n        for (const key in obj) {\n          this.andWhere(key, obj[key]);\n        }\n      });\n    }\n\n    return this.where(column, ...args);\n  }\n\n  orWhereColumn(column, ...args) {\n    this._bool('or');\n\n    const obj = column;\n\n    if (isObject(obj) && !obj.isRawInstance) {\n      return this.whereWrapped(function () {\n        for (const key in obj) {\n          this.andWhereColumn(key, '=', obj[key]);\n        }\n      });\n    }\n\n    return this.whereColumn(column, ...args);\n  } // Adds an `not where` clause to the query.\n\n\n  whereNot(column, ...args) {\n    if (args.length >= 1) {\n      if (args[0] === 'in' || args[0] === 'between') {\n        this.client.logger.warn('whereNot is not suitable for \"in\" and \"between\" type subqueries. You should use \"not in\" and \"not between\" instead.');\n      }\n    }\n\n    return this._not(true).where(column, ...args);\n  }\n\n  whereNotColumn(...args) {\n    return this._not(true).whereColumn(...args);\n  } // Adds an `or not where` clause to the query.\n\n\n  orWhereNot(...args) {\n    return this._bool('or').whereNot(...args);\n  }\n\n  orWhereNotColumn(...args) {\n    return this._bool('or').whereNotColumn(...args);\n  } // Processes an object literal provided in a \"where\" clause.\n\n\n  _objectWhere(obj) {\n    const boolVal = this._bool();\n\n    const notVal = this._not() ? 'Not' : '';\n\n    for (const key in obj) {\n      this[boolVal + 'Where' + notVal](key, obj[key]);\n    }\n\n    return this;\n  } // Adds a raw `where` clause to the query.\n\n\n  whereRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereRaw',\n      value: raw,\n      not: this._not(),\n      bool: this._bool()\n    });\n\n    return this;\n  }\n\n  orWhereRaw(sql, bindings) {\n    return this._bool('or').whereRaw(sql, bindings);\n  } // Helper for compiling any advanced `where` queries.\n\n\n  whereWrapped(callback) {\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereWrapped',\n      value: callback,\n      not: this._not(),\n      bool: this._bool()\n    });\n\n    return this;\n  } // Adds a `where exists` clause to the query.\n\n\n  whereExists(callback) {\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereExists',\n      value: callback,\n      not: this._not(),\n      bool: this._bool()\n    });\n\n    return this;\n  } // Adds an `or where exists` clause to the query.\n\n\n  orWhereExists(callback) {\n    return this._bool('or').whereExists(callback);\n  } // Adds a `where not exists` clause to the query.\n\n\n  whereNotExists(callback) {\n    return this._not(true).whereExists(callback);\n  } // Adds a `or where not exists` clause to the query.\n\n\n  orWhereNotExists(callback) {\n    return this._bool('or').whereNotExists(callback);\n  } // Adds a `where in` clause to the query.\n\n\n  whereIn(column, values) {\n    if (Array.isArray(values) && isEmpty(values)) return this.where(this._not());\n\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereIn',\n      column,\n      value: values,\n      not: this._not(),\n      bool: this._bool()\n    });\n\n    return this;\n  } // Adds a `or where in` clause to the query.\n\n\n  orWhereIn(column, values) {\n    return this._bool('or').whereIn(column, values);\n  } // Adds a `where not in` clause to the query.\n\n\n  whereNotIn(column, values) {\n    return this._not(true).whereIn(column, values);\n  } // Adds a `or where not in` clause to the query.\n\n\n  orWhereNotIn(column, values) {\n    return this._bool('or')._not(true).whereIn(column, values);\n  } // Adds a `where null` clause to the query.\n\n\n  whereNull(column) {\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereNull',\n      column,\n      not: this._not(),\n      bool: this._bool()\n    });\n\n    return this;\n  } // Adds a `or where null` clause to the query.\n\n\n  orWhereNull(column) {\n    return this._bool('or').whereNull(column);\n  } // Adds a `where not null` clause to the query.\n\n\n  whereNotNull(column) {\n    return this._not(true).whereNull(column);\n  } // Adds a `or where not null` clause to the query.\n\n\n  orWhereNotNull(column) {\n    return this._bool('or').whereNotNull(column);\n  } // Adds a `where between` clause to the query.\n\n\n  whereBetween(column, values) {\n    assert(Array.isArray(values), 'The second argument to whereBetween must be an array.');\n    assert(values.length === 2, 'You must specify 2 values for the whereBetween clause');\n\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereBetween',\n      column,\n      value: values,\n      not: this._not(),\n      bool: this._bool()\n    });\n\n    return this;\n  } // Adds a `where not between` clause to the query.\n\n\n  whereNotBetween(column, values) {\n    return this._not(true).whereBetween(column, values);\n  } // Adds a `or where between` clause to the query.\n\n\n  orWhereBetween(column, values) {\n    return this._bool('or').whereBetween(column, values);\n  } // Adds a `or where not between` clause to the query.\n\n\n  orWhereNotBetween(column, values) {\n    return this._bool('or').whereNotBetween(column, values);\n  } // Adds a `group by` clause to the query.\n\n\n  groupBy(item) {\n    if (item && item.isRawInstance) {\n      return this.groupByRaw.apply(this, arguments);\n    }\n\n    this._statements.push({\n      grouping: 'group',\n      type: 'groupByBasic',\n      value: normalizeArr(...arguments)\n    });\n\n    return this;\n  } // Adds a raw `group by` clause to the query.\n\n\n  groupByRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n\n    this._statements.push({\n      grouping: 'group',\n      type: 'groupByRaw',\n      value: raw\n    });\n\n    return this;\n  } // Adds a `order by` clause to the query.\n\n\n  orderBy(column, direction) {\n    if (Array.isArray(column)) {\n      return this._orderByArray(column);\n    }\n\n    this._statements.push({\n      grouping: 'order',\n      type: 'orderByBasic',\n      value: column,\n      direction\n    });\n\n    return this;\n  } // Adds a `order by` with multiple columns to the query.\n\n\n  _orderByArray(columnDefs) {\n    for (let i = 0; i < columnDefs.length; i++) {\n      const columnInfo = columnDefs[i];\n\n      if (isObject(columnInfo)) {\n        this._statements.push({\n          grouping: 'order',\n          type: 'orderByBasic',\n          value: columnInfo['column'],\n          direction: columnInfo['order']\n        });\n      } else if (isString(columnInfo)) {\n        this._statements.push({\n          grouping: 'order',\n          type: 'orderByBasic',\n          value: columnInfo\n        });\n      }\n    }\n\n    return this;\n  } // Add a raw `order by` clause to the query.\n\n\n  orderByRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n\n    this._statements.push({\n      grouping: 'order',\n      type: 'orderByRaw',\n      value: raw\n    });\n\n    return this;\n  }\n\n  _union(clause, args) {\n    let callbacks = args[0];\n    let wrap = args[1];\n\n    if (args.length === 1 || args.length === 2 && isBoolean(wrap)) {\n      if (!Array.isArray(callbacks)) {\n        callbacks = [callbacks];\n      }\n\n      for (let i = 0, l = callbacks.length; i < l; i++) {\n        this._statements.push({\n          grouping: 'union',\n          clause: clause,\n          value: callbacks[i],\n          wrap: wrap || false\n        });\n      }\n    } else {\n      callbacks = toArray(args).slice(0, args.length - 1);\n      wrap = args[args.length - 1];\n\n      if (!isBoolean(wrap)) {\n        callbacks.push(wrap);\n        wrap = false;\n      }\n\n      this._union(clause, [callbacks, wrap]);\n    }\n\n    return this;\n  } // Add a union statement to the query.\n\n\n  union(...args) {\n    return this._union('union', args);\n  } // Adds a union all statement to the query.\n\n\n  unionAll(...args) {\n    return this._union('union all', args);\n  } // Adds an intersect statement to the query\n\n\n  intersect(callbacks, wrap) {\n    if (arguments.length === 1 || arguments.length === 2 && isBoolean(wrap)) {\n      if (!Array.isArray(callbacks)) {\n        callbacks = [callbacks];\n      }\n\n      for (let i = 0, l = callbacks.length; i < l; i++) {\n        this._statements.push({\n          grouping: 'union',\n          clause: 'intersect',\n          value: callbacks[i],\n          wrap: wrap || false\n        });\n      }\n    } else {\n      callbacks = toArray(arguments).slice(0, arguments.length - 1);\n      wrap = arguments[arguments.length - 1];\n\n      if (!isBoolean(wrap)) {\n        callbacks.push(wrap);\n        wrap = false;\n      }\n\n      this.intersect(callbacks, wrap);\n    }\n\n    return this;\n  } // Adds a `having` clause to the query.\n\n\n  having(column, operator, value) {\n    if (column.isRawInstance && arguments.length === 1) {\n      return this.havingRaw(column);\n    } // Check if the column is a function, in which case it's\n    // a having statement wrapped in parens.\n\n\n    if (typeof column === 'function') {\n      return this.havingWrapped(column);\n    }\n\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingBasic',\n      column,\n      operator,\n      value,\n      bool: this._bool(),\n      not: this._not()\n    });\n\n    return this;\n  }\n\n  orHaving(column, ...args) {\n    this._bool('or');\n\n    const obj = column;\n\n    if (isObject(obj) && !obj.isRawInstance) {\n      return this.havingWrapped(function () {\n        for (const key in obj) {\n          this.andHaving(key, obj[key]);\n        }\n      });\n    }\n\n    return this.having(column, ...args);\n  } // Helper for compiling any advanced `having` queries.\n\n\n  havingWrapped(callback) {\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingWrapped',\n      value: callback,\n      bool: this._bool(),\n      not: this._not()\n    });\n\n    return this;\n  }\n\n  havingNull(column) {\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingNull',\n      column,\n      not: this._not(),\n      bool: this._bool()\n    });\n\n    return this;\n  }\n\n  orHavingNull(callback) {\n    return this._bool('or').havingNull(callback);\n  }\n\n  havingNotNull(callback) {\n    return this._not(true).havingNull(callback);\n  }\n\n  orHavingNotNull(callback) {\n    return this._not(true)._bool('or').havingNull(callback);\n  }\n\n  havingExists(callback) {\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingExists',\n      value: callback,\n      not: this._not(),\n      bool: this._bool()\n    });\n\n    return this;\n  }\n\n  orHavingExists(callback) {\n    return this._bool('or').havingExists(callback);\n  }\n\n  havingNotExists(callback) {\n    return this._not(true).havingExists(callback);\n  }\n\n  orHavingNotExists(callback) {\n    return this._not(true)._bool('or').havingExists(callback);\n  }\n\n  havingBetween(column, values) {\n    assert(Array.isArray(values), 'The second argument to havingBetween must be an array.');\n    assert(values.length === 2, 'You must specify 2 values for the havingBetween clause');\n\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingBetween',\n      column,\n      value: values,\n      not: this._not(),\n      bool: this._bool()\n    });\n\n    return this;\n  }\n\n  orHavingBetween(column, values) {\n    return this._bool('or').havingBetween(column, values);\n  }\n\n  havingNotBetween(column, values) {\n    return this._not(true).havingBetween(column, values);\n  }\n\n  orHavingNotBetween(column, values) {\n    return this._not(true)._bool('or').havingBetween(column, values);\n  }\n\n  havingIn(column, values) {\n    if (Array.isArray(values) && isEmpty(values)) return this.where(this._not());\n\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingIn',\n      column,\n      value: values,\n      not: this._not(),\n      bool: this._bool()\n    });\n\n    return this;\n  } // Adds a `or where in` clause to the query.\n\n\n  orHavingIn(column, values) {\n    return this._bool('or').havingIn(column, values);\n  } // Adds a `where not in` clause to the query.\n\n\n  havingNotIn(column, values) {\n    return this._not(true).havingIn(column, values);\n  } // Adds a `or where not in` clause to the query.\n\n\n  orHavingNotIn(column, values) {\n    return this._bool('or')._not(true).havingIn(column, values);\n  } // Adds a raw `having` clause to the query.\n\n\n  havingRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingRaw',\n      value: raw,\n      bool: this._bool(),\n      not: this._not()\n    });\n\n    return this;\n  }\n\n  orHavingRaw(sql, bindings) {\n    return this._bool('or').havingRaw(sql, bindings);\n  } // Only allow a single \"offset\" to be set for the current query.\n\n\n  offset(value) {\n    if (value == null || value.isRawInstance || value instanceof Builder) {\n      // Builder for backward compatibility\n      this._single.offset = value;\n    } else {\n      const val = parseInt(value, 10);\n\n      if (isNaN(val)) {\n        this.client.logger.warn('A valid integer must be provided to offset');\n      } else if (val < 0) {\n        throw new Error(`A non-negative integer must be provided to offset.`);\n      } else {\n        this._single.offset = val;\n      }\n    }\n\n    return this;\n  } // Only allow a single \"limit\" to be set for the current query.\n\n\n  limit(value) {\n    const val = parseInt(value, 10);\n\n    if (isNaN(val)) {\n      this.client.logger.warn('A valid integer must be provided to limit');\n    } else {\n      this._single.limit = val;\n    }\n\n    return this;\n  } // Retrieve the \"count\" result of the query.\n\n\n  count(column, options) {\n    return this._aggregate('count', column || '*', options);\n  } // Retrieve the minimum value of a given column.\n\n\n  min(column, options) {\n    return this._aggregate('min', column, options);\n  } // Retrieve the maximum value of a given column.\n\n\n  max(column, options) {\n    return this._aggregate('max', column, options);\n  } // Retrieve the sum of the values of a given column.\n\n\n  sum(column, options) {\n    return this._aggregate('sum', column, options);\n  } // Retrieve the average of the values of a given column.\n\n\n  avg(column, options) {\n    return this._aggregate('avg', column, options);\n  } // Retrieve the \"count\" of the distinct results of the query.\n\n\n  countDistinct(...columns) {\n    let options;\n\n    if (columns.length > 1 && isPlainObject(last(columns))) {\n      [options] = columns.splice(columns.length - 1, 1);\n    }\n\n    if (!columns.length) {\n      columns = '*';\n    } else if (columns.length === 1) {\n      columns = columns[0];\n    }\n\n    return this._aggregate('count', columns, { ...options,\n      distinct: true\n    });\n  } // Retrieve the sum of the distinct values of a given column.\n\n\n  sumDistinct(column, options) {\n    return this._aggregate('sum', column, { ...options,\n      distinct: true\n    });\n  } // Retrieve the vg of the distinct results of the query.\n\n\n  avgDistinct(column, options) {\n    return this._aggregate('avg', column, { ...options,\n      distinct: true\n    });\n  } // Increments a column's value by the specified amount.\n\n\n  increment(column, amount = 1) {\n    if (isObject(column)) {\n      for (const key in column) {\n        this._counter(key, column[key]);\n      }\n\n      return this;\n    }\n\n    return this._counter(column, amount);\n  } // Decrements a column's value by the specified amount.\n\n\n  decrement(column, amount = 1) {\n    if (isObject(column)) {\n      for (const key in column) {\n        this._counter(key, -column[key]);\n      }\n\n      return this;\n    }\n\n    return this._counter(column, -amount);\n  } // Clears increments/decrements\n\n\n  clearCounters() {\n    this._single.counter = {};\n    return this;\n  } // Sets the values for a `select` query, informing that only the first\n  // row should be returned (limit 1).\n\n\n  first(...args) {\n    if (this._method && this._method !== 'select') {\n      throw new Error(`Cannot chain .first() on \"${this._method}\" query`);\n    }\n\n    this.select(normalizeArr(...args));\n    this._method = 'first';\n    this.limit(1);\n    return this;\n  } // Use existing connection to execute the query\n  // Same value that client.acquireConnection() for an according client returns should be passed\n\n\n  connection(_connection) {\n    this._connection = _connection;\n    return this;\n  } // Pluck a column from a query.\n\n\n  pluck(column) {\n    if (this._method && this._method !== 'select') {\n      throw new Error(`Cannot chain .pluck() on \"${this._method}\" query`);\n    }\n\n    this._method = 'pluck';\n    this._single.pluck = column;\n\n    this._statements.push({\n      grouping: 'columns',\n      type: 'pluck',\n      value: column\n    });\n\n    return this;\n  } // Deprecated. Remove everything from select clause\n\n\n  clearSelect() {\n    this._clearGrouping('columns');\n\n    return this;\n  } // Deprecated. Remove everything from where clause\n\n\n  clearWhere() {\n    this._clearGrouping('where');\n\n    return this;\n  } // Deprecated. Remove everything from group clause\n\n\n  clearGroup() {\n    this._clearGrouping('group');\n\n    return this;\n  } // Deprecated. Remove everything from order clause\n\n\n  clearOrder() {\n    this._clearGrouping('order');\n\n    return this;\n  } // Deprecated. Remove everything from having clause\n\n\n  clearHaving() {\n    this._clearGrouping('having');\n\n    return this;\n  } // Remove everything from statement clause\n\n\n  clear(statement) {\n    if (!CLEARABLE_STATEMENTS.has(statement)) throw new Error(`Knex Error: unknown statement '${statement}'`);\n    if (statement.startsWith('counter')) return this.clearCounters();\n\n    if (statement === 'select') {\n      statement = 'columns';\n    }\n\n    this._clearGrouping(statement);\n\n    return this;\n  } // Insert & Update\n  // ------\n  // Sets the values for an `insert` query.\n\n\n  insert(values, returning, options) {\n    this._method = 'insert';\n    if (!isEmpty(returning)) this.returning(returning, options);\n    this._single.insert = values;\n    return this;\n  } // Sets the values for an `update`, allowing for both\n  // `.update(key, value, [returning])` and `.update(obj, [returning])` syntaxes.\n\n\n  update(values, returning, options) {\n    let ret;\n    const obj = this._single.update || {};\n    this._method = 'update';\n\n    if (isString(values)) {\n      obj[values] = returning;\n\n      if (arguments.length > 2) {\n        ret = arguments[2];\n      }\n    } else {\n      const keys = Object.keys(values);\n\n      if (this._single.update) {\n        this.client.logger.warn('Update called multiple times with objects.');\n      }\n\n      let i = -1;\n\n      while (++i < keys.length) {\n        obj[keys[i]] = values[keys[i]];\n      }\n\n      ret = arguments[1];\n    }\n\n    if (!isEmpty(ret)) this.returning(ret, options);\n    this._single.update = obj;\n    return this;\n  } // Sets the returning value for the query.\n\n\n  returning(returning, options) {\n    this._single.returning = returning;\n    this._single.options = options;\n    return this;\n  }\n\n  onConflict(columns) {\n    if (typeof columns === 'string') {\n      columns = [columns];\n    }\n\n    return new OnConflictBuilder(this, columns || true);\n  } // Delete\n  // ------\n  // Executes a delete statement on the query;\n\n\n  delete(ret, options) {\n    this._method = 'del';\n    if (!isEmpty(ret)) this.returning(ret, options);\n    return this;\n  } // Truncates a table, ends the query chain.\n\n\n  truncate(tableName) {\n    this._method = 'truncate';\n\n    if (tableName) {\n      this._single.table = tableName;\n    }\n\n    return this;\n  } // Retrieves columns for the table specified by `knex(tableName)`\n\n\n  columnInfo(column) {\n    this._method = 'columnInfo';\n    this._single.columnInfo = column;\n    return this;\n  } // Set a lock for update constraint.\n\n\n  forUpdate(...tables) {\n    this._single.lock = lockMode.forUpdate;\n    this._single.lockTables = tables;\n    return this;\n  } // Set a lock for share constraint.\n\n\n  forShare(...tables) {\n    this._single.lock = lockMode.forShare;\n    this._single.lockTables = tables;\n    return this;\n  } // Skips locked rows when using a lock constraint.\n\n\n  skipLocked() {\n    if (!this._isSelectQuery()) {\n      throw new Error(`Cannot chain .skipLocked() on \"${this._method}\" query!`);\n    }\n\n    if (!this._hasLockMode()) {\n      throw new Error('.skipLocked() can only be used after a call to .forShare() or .forUpdate()!');\n    }\n\n    if (this._single.waitMode === waitMode.noWait) {\n      throw new Error('.skipLocked() cannot be used together with .noWait()!');\n    }\n\n    this._single.waitMode = waitMode.skipLocked;\n    return this;\n  } // Causes error when acessing a locked row instead of waiting for it to be released.\n\n\n  noWait() {\n    if (!this._isSelectQuery()) {\n      throw new Error(`Cannot chain .noWait() on \"${this._method}\" query!`);\n    }\n\n    if (!this._hasLockMode()) {\n      throw new Error('.noWait() can only be used after a call to .forShare() or .forUpdate()!');\n    }\n\n    if (this._single.waitMode === waitMode.skipLocked) {\n      throw new Error('.noWait() cannot be used together with .skipLocked()!');\n    }\n\n    this._single.waitMode = waitMode.noWait;\n    return this;\n  } // Takes a JS object of methods to call and calls them\n\n\n  fromJS(obj) {\n    each(obj, (val, key) => {\n      if (typeof this[key] !== 'function') {\n        this.client.logger.warn(`Knex Error: unknown key ${key}`);\n      }\n\n      if (Array.isArray(val)) {\n        this[key].apply(this, val);\n      } else {\n        this[key](val);\n      }\n    });\n    return this;\n  } // Passes query to provided callback function, useful for e.g. composing\n  // domain-specific helpers\n\n\n  modify(callback) {\n    callback.apply(this, [this].concat(tail(arguments)));\n    return this;\n  }\n\n  _analytic(alias, second, third) {\n    let analytic;\n    const {\n      schema\n    } = this._single;\n\n    const method = this._analyticMethod();\n\n    alias = typeof alias === 'string' ? alias : null;\n    assert(typeof second === 'function' || second.isRawInstance || Array.isArray(second) || typeof second === 'string', `The second argument to an analytic function must be either a function, a raw,\n       an array of string or a single string.`);\n\n    if (third) {\n      assert(Array.isArray(third) || typeof third === 'string', 'The third argument to an analytic function must be either a string or an array of string.');\n    }\n\n    if (isFunction(second)) {\n      analytic = new Analytic(method, schema, alias);\n      second.call(analytic, analytic);\n    } else if (second.isRawInstance) {\n      const raw = second;\n      analytic = {\n        grouping: 'columns',\n        type: 'analytic',\n        method: method,\n        raw: raw,\n        alias: alias\n      };\n    } else {\n      const order = typeof second === 'string' ? [second] : second;\n      let partitions = third || [];\n      partitions = typeof partitions === 'string' ? [partitions] : partitions;\n      analytic = {\n        grouping: 'columns',\n        type: 'analytic',\n        method: method,\n        order: order,\n        alias: alias,\n        partitions: partitions\n      };\n    }\n\n    this._statements.push(analytic);\n\n    return this;\n  }\n\n  rank(...args) {\n    return this._analyticMethod('rank')._analytic(...args);\n  }\n\n  denseRank(...args) {\n    return this._analyticMethod('dense_rank')._analytic(...args);\n  }\n\n  rowNumber(...args) {\n    return this._analyticMethod('row_number')._analytic(...args);\n  } // ----------------------------------------------------------------------\n  // Helper for the incrementing/decrementing queries.\n\n\n  _counter(column, amount) {\n    amount = parseFloat(amount);\n    this._method = 'update';\n    this._single.counter = this._single.counter || {};\n    this._single.counter[column] = amount;\n    return this;\n  } // Helper to get or set the \"boolFlag\" value.\n\n\n  _bool(val) {\n    if (arguments.length === 1) {\n      this._boolFlag = val;\n      return this;\n    }\n\n    const ret = this._boolFlag;\n    this._boolFlag = 'and';\n    return ret;\n  } // Helper to get or set the \"notFlag\" value.\n\n\n  _not(val) {\n    if (arguments.length === 1) {\n      this._notFlag = val;\n      return this;\n    }\n\n    const ret = this._notFlag;\n    this._notFlag = false;\n    return ret;\n  } // Helper to get or set the \"joinFlag\" value.\n\n\n  _joinType(val) {\n    if (arguments.length === 1) {\n      this._joinFlag = val;\n      return this;\n    }\n\n    const ret = this._joinFlag || 'inner';\n    this._joinFlag = 'inner';\n    return ret;\n  }\n\n  _analyticMethod(val) {\n    if (arguments.length === 1) {\n      this._analyticFlag = val;\n      return this;\n    }\n\n    return this._analyticFlag || 'row_number';\n  } // Helper for compiling any aggregate queries.\n\n\n  _aggregate(method, column, options = {}) {\n    this._statements.push({\n      grouping: 'columns',\n      type: column.isRawInstance ? 'aggregateRaw' : 'aggregate',\n      method,\n      value: column,\n      aggregateDistinct: options.distinct || false,\n      alias: options.as\n    });\n\n    return this;\n  } // Helper function for clearing or reseting a grouping type from the builder\n\n\n  _clearGrouping(grouping) {\n    if (grouping in this._single) {\n      this._single[grouping] = undefined;\n    } else {\n      this._statements = reject(this._statements, {\n        grouping\n      });\n    }\n  } // Helper function that checks if the builder will emit a select query\n\n\n  _isSelectQuery() {\n    return SELECT_COMMANDS.has(this._method);\n  } // Helper function that checks if the query has a lock mode set\n\n\n  _hasLockMode() {\n    return LOCK_MODES.has(this._single.lock);\n  }\n\n}\n\nconst validateWithArgs = function (alias, statement, method) {\n  if (typeof alias !== 'string') {\n    throw new Error(`${method}() first argument must be a string`);\n  }\n\n  if (typeof statement === 'function' || statement instanceof Builder || statement && statement.isRawInstance) {\n    return;\n  }\n\n  throw new Error(`${method}() second argument must be a function / QueryBuilder or a raw`);\n};\n\nBuilder.prototype.select = Builder.prototype.columns;\nBuilder.prototype.column = Builder.prototype.columns;\nBuilder.prototype.andWhereNot = Builder.prototype.whereNot;\nBuilder.prototype.andWhereNotColumn = Builder.prototype.whereNotColumn;\nBuilder.prototype.andWhere = Builder.prototype.where;\nBuilder.prototype.andWhereColumn = Builder.prototype.whereColumn;\nBuilder.prototype.andWhereRaw = Builder.prototype.whereRaw;\nBuilder.prototype.andWhereBetween = Builder.prototype.whereBetween;\nBuilder.prototype.andWhereNotBetween = Builder.prototype.whereNotBetween;\nBuilder.prototype.andHaving = Builder.prototype.having;\nBuilder.prototype.andHavingIn = Builder.prototype.havingIn;\nBuilder.prototype.andHavingNotIn = Builder.prototype.havingNotIn;\nBuilder.prototype.andHavingNull = Builder.prototype.havingNull;\nBuilder.prototype.andHavingNotNull = Builder.prototype.havingNotNull;\nBuilder.prototype.andHavingExists = Builder.prototype.havingExists;\nBuilder.prototype.andHavingNotExists = Builder.prototype.havingNotExists;\nBuilder.prototype.andHavingBetween = Builder.prototype.havingBetween;\nBuilder.prototype.andHavingNotBetween = Builder.prototype.havingNotBetween;\nBuilder.prototype.from = Builder.prototype.table;\nBuilder.prototype.into = Builder.prototype.table;\nBuilder.prototype.del = Builder.prototype.delete; // Attach all of the top level promise methods that should be chainable.\n\naugmentWithBuilderInterface(Builder);\naddQueryContext(Builder);\n\nBuilder.extend = (methodName, fn) => {\n  if (Object.prototype.hasOwnProperty.call(Builder.prototype, methodName)) {\n    throw new Error(`Can't extend QueryBuilder with existing method ('${methodName}').`);\n  }\n\n  assign(Builder.prototype, {\n    [methodName]: fn\n  });\n}; // Sub-builder for onConflict clauses\n\n\nclass OnConflictBuilder {\n  constructor(builder, columns) {\n    this.builder = builder;\n    this._columns = columns;\n  } // Sets insert query to ignore conflicts\n\n\n  ignore() {\n    this.builder._single.onConflict = this._columns;\n    this.builder._single.ignore = true;\n    return this.builder;\n  } // Sets insert query to update on conflict\n\n\n  merge(updates) {\n    this.builder._single.onConflict = this._columns;\n    this.builder._single.merge = {\n      updates\n    };\n    return this.builder;\n  } // Prevent\n\n\n  then() {\n    throw new Error('Incomplete onConflict clause. .onConflict() must be directly followed by either .merge() or .ignore()');\n  }\n\n}\n\nmodule.exports = Builder;","map":{"version":3,"sources":["/home/rosiane/back/node_modules/knex/lib/query/querybuilder.js"],"names":["assert","require","EventEmitter","assign","clone","each","isEmpty","isPlainObject","last","reject","tail","toArray","addQueryContext","normalizeArr","JoinClause","Analytic","saveAsyncStack","isBoolean","isNumber","isObject","isString","isFunction","lockMode","waitMode","augmentWithBuilderInterface","SELECT_COMMANDS","Set","CLEARABLE_STATEMENTS","LOCK_MODES","forShare","forUpdate","Builder","constructor","client","and","_single","_statements","_method","config","_debug","debug","_joinFlag","_boolFlag","_notFlag","_asColumnFlag","toString","toQuery","toSQL","method","tz","queryCompiler","cloned","_options","undefined","_queryContext","_connection","timeout","ms","cancel","_timeout","assertCanCancelQuery","_cancelOnTimeout","with","alias","statement","validateWithArgs","withWrapped","query","push","grouping","type","value","withRecursive","withRecursiveWrapped","length","recursive","columns","column","arguments","as","hintComment","hints","Array","isArray","some","hint","Error","includes","withSchema","schemaName","schema","table","tableName","options","only","distinct","args","distinctOn","join","first","joinType","_joinType","call","raw","on","innerJoin","leftJoin","leftOuterJoin","rightJoin","rightOuterJoin","outerJoin","fullOuterJoin","crossJoin","joinRaw","or","_bool","not","_not","where","operator","argsLength","whereWrapped","isRawInstance","_objectWhere","whereRaw","whereNull","checkOperator","toLowerCase","trim","whereIn","whereBetween","bool","asColumn","whereColumn","orWhere","obj","key","andWhere","orWhereColumn","andWhereColumn","whereNot","logger","warn","whereNotColumn","orWhereNot","orWhereNotColumn","boolVal","notVal","sql","bindings","orWhereRaw","callback","whereExists","orWhereExists","whereNotExists","orWhereNotExists","values","orWhereIn","whereNotIn","orWhereNotIn","orWhereNull","whereNotNull","orWhereNotNull","whereNotBetween","orWhereBetween","orWhereNotBetween","groupBy","item","groupByRaw","apply","orderBy","direction","_orderByArray","columnDefs","i","columnInfo","orderByRaw","_union","clause","callbacks","wrap","l","slice","union","unionAll","intersect","having","havingRaw","havingWrapped","orHaving","andHaving","havingNull","orHavingNull","havingNotNull","orHavingNotNull","havingExists","orHavingExists","havingNotExists","orHavingNotExists","havingBetween","orHavingBetween","havingNotBetween","orHavingNotBetween","havingIn","orHavingIn","havingNotIn","orHavingNotIn","orHavingRaw","offset","val","parseInt","isNaN","limit","count","_aggregate","min","max","sum","avg","countDistinct","splice","sumDistinct","avgDistinct","increment","amount","_counter","decrement","clearCounters","counter","select","connection","pluck","clearSelect","_clearGrouping","clearWhere","clearGroup","clearOrder","clearHaving","clear","has","startsWith","insert","returning","update","ret","keys","Object","onConflict","OnConflictBuilder","delete","truncate","tables","lock","lockTables","skipLocked","_isSelectQuery","_hasLockMode","noWait","fromJS","modify","concat","_analytic","second","third","analytic","_analyticMethod","order","partitions","rank","denseRank","rowNumber","parseFloat","_analyticFlag","aggregateDistinct","prototype","andWhereNot","andWhereNotColumn","andWhereRaw","andWhereBetween","andWhereNotBetween","andHavingIn","andHavingNotIn","andHavingNull","andHavingNotNull","andHavingExists","andHavingNotExists","andHavingBetween","andHavingNotBetween","from","into","del","extend","methodName","fn","hasOwnProperty","builder","_columns","ignore","merge","updates","then","module","exports"],"mappings":"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","sourcesContent":["// Builder\n// -------\nconst assert = require('assert');\nconst { EventEmitter } = require('events');\nconst assign = require('lodash/assign');\nconst clone = require('lodash/clone');\nconst each = require('lodash/each');\nconst isEmpty = require('lodash/isEmpty');\nconst isPlainObject = require('lodash/isPlainObject');\nconst last = require('lodash/last');\nconst reject = require('lodash/reject');\nconst tail = require('lodash/tail');\nconst toArray = require('lodash/toArray');\n\nconst { addQueryContext, normalizeArr } = require('../util/helpers');\nconst JoinClause = require('./joinclause');\nconst Analytic = require('./analytic');\nconst saveAsyncStack = require('../util/save-async-stack');\nconst {\n  isBoolean,\n  isNumber,\n  isObject,\n  isString,\n  isFunction,\n} = require('../util/is');\n\nconst { lockMode, waitMode } = require('./constants');\nconst {\n  augmentWithBuilderInterface,\n} = require('../builder-interface-augmenter');\n\nconst SELECT_COMMANDS = new Set(['pluck', 'first', 'select']);\nconst CLEARABLE_STATEMENTS = new Set([\n  'with',\n  'select',\n  'columns',\n  'hintComments',\n  'where',\n  'union',\n  'join',\n  'group',\n  'order',\n  'having',\n  'limit',\n  'offset',\n  'counter',\n  'counters',\n]);\nconst LOCK_MODES = new Set([lockMode.forShare, lockMode.forUpdate]);\n\n// Typically called from `knex.builder`,\n// start a new query building chain.\nclass Builder extends EventEmitter {\n  constructor(client) {\n    super();\n    this.client = client;\n    this.and = this;\n    this._single = {};\n    this._statements = [];\n    this._method = 'select';\n    if (client.config) {\n      saveAsyncStack(this, 5);\n      this._debug = client.config.debug;\n    }\n    // Internal flags used in the builder.\n    this._joinFlag = 'inner';\n    this._boolFlag = 'and';\n    this._notFlag = false;\n    this._asColumnFlag = false;\n  }\n\n  toString() {\n    return this.toQuery();\n  }\n\n  // Convert the current query \"toSQL\"\n  toSQL(method, tz) {\n    return this.client.queryCompiler(this).toSQL(method || this._method, tz);\n  }\n\n  // Create a shallow clone of the current query builder.\n  clone() {\n    const cloned = new this.constructor(this.client);\n    cloned._method = this._method;\n    cloned._single = clone(this._single);\n    cloned._statements = clone(this._statements);\n    cloned._debug = this._debug;\n\n    // `_option` is assigned by the `Interface` mixin.\n    if (this._options !== undefined) {\n      cloned._options = clone(this._options);\n    }\n    if (this._queryContext !== undefined) {\n      cloned._queryContext = clone(this._queryContext);\n    }\n    if (this._connection !== undefined) {\n      cloned._connection = this._connection;\n    }\n\n    return cloned;\n  }\n\n  timeout(ms, { cancel } = {}) {\n    if (isNumber(ms) && ms > 0) {\n      this._timeout = ms;\n      if (cancel) {\n        this.client.assertCanCancelQuery();\n        this._cancelOnTimeout = true;\n      }\n    }\n    return this;\n  }\n\n  // With\n  // ------\n\n  with(alias, statement) {\n    validateWithArgs(alias, statement, 'with');\n    return this.withWrapped(alias, statement);\n  }\n\n  // Helper for compiling any advanced `with` queries.\n  withWrapped(alias, query) {\n    this._statements.push({\n      grouping: 'with',\n      type: 'withWrapped',\n      alias: alias,\n      value: query,\n    });\n    return this;\n  }\n\n  // With Recursive\n  // ------\n\n  withRecursive(alias, statement) {\n    validateWithArgs(alias, statement, 'withRecursive');\n    return this.withRecursiveWrapped(alias, statement);\n  }\n\n  // Helper for compiling any advanced `withRecursive` queries.\n  withRecursiveWrapped(alias, query) {\n    this.withWrapped(alias, query);\n    this._statements[this._statements.length - 1].recursive = true;\n    return this;\n  }\n\n  // Select\n  // ------\n\n  // Adds a column or columns to the list of \"columns\"\n  // being selected on the query.\n  columns(column) {\n    if (!column && column !== 0) return this;\n    this._statements.push({\n      grouping: 'columns',\n      value: normalizeArr(...arguments),\n    });\n    return this;\n  }\n\n  // Allow for a sub-select to be explicitly aliased as a column,\n  // without needing to compile the query in a where.\n  as(column) {\n    this._single.as = column;\n    return this;\n  }\n\n  // Adds a single hint or an array of hits to the list of \"hintComments\" on the query.\n  hintComment(hints) {\n    hints = Array.isArray(hints) ? hints : [hints];\n    if (hints.some((hint) => !isString(hint))) {\n      throw new Error('Hint comment must be a string');\n    }\n    if (hints.some((hint) => hint.includes('/*') || hint.includes('*/'))) {\n      throw new Error('Hint comment cannot include \"/*\" or \"*/\"');\n    }\n    if (hints.some((hint) => hint.includes('?'))) {\n      throw new Error('Hint comment cannot include \"?\"');\n    }\n    this._statements.push({\n      grouping: 'hintComments',\n      value: hints,\n    });\n    return this;\n  }\n\n  // Prepends the `schemaName` on `tableName` defined by `.table` and `.join`.\n  withSchema(schemaName) {\n    this._single.schema = schemaName;\n    return this;\n  }\n\n  // Sets the `tableName` on the query.\n  // Alias to \"from\" for select and \"into\" for insert statements\n  // e.g. builder.insert({a: value}).into('tableName')\n  // `options`: options object containing keys:\n  //   - `only`: whether the query should use SQL's ONLY to not return\n  //           inheriting table data. Defaults to false.\n  table(tableName, options = {}) {\n    this._single.table = tableName;\n    this._single.only = options.only === true;\n    return this;\n  }\n\n  // Adds a `distinct` clause to the query.\n  distinct(...args) {\n    this._statements.push({\n      grouping: 'columns',\n      value: normalizeArr(...args),\n      distinct: true,\n    });\n    return this;\n  }\n\n  distinctOn(...args) {\n    if (isEmpty(args)) {\n      throw new Error('distinctOn requires at least on argument');\n    }\n    this._statements.push({\n      grouping: 'columns',\n      value: normalizeArr(...args),\n      distinctOn: true,\n    });\n    return this;\n  }\n\n  // Adds a join clause to the query, allowing for advanced joins\n  // with an anonymous function as the second argument.\n  // function(table, first, operator, second)\n  join(table, first, ...args) {\n    let join;\n    const schema =\n      table instanceof Builder || typeof table === 'function'\n        ? undefined\n        : this._single.schema;\n    const joinType = this._joinType();\n    if (typeof first === 'function') {\n      join = new JoinClause(table, joinType, schema);\n      first.call(join, join);\n    } else if (joinType === 'raw') {\n      join = new JoinClause(this.client.raw(table, first), 'raw');\n    } else {\n      join = new JoinClause(table, joinType, schema);\n      if (first) {\n        join.on(first, ...args);\n      }\n    }\n    this._statements.push(join);\n    return this;\n  }\n\n  // JOIN blocks:\n  innerJoin(...args) {\n    return this._joinType('inner').join(...args);\n  }\n\n  leftJoin(...args) {\n    return this._joinType('left').join(...args);\n  }\n\n  leftOuterJoin(...args) {\n    return this._joinType('left outer').join(...args);\n  }\n\n  rightJoin(...args) {\n    return this._joinType('right').join(...args);\n  }\n\n  rightOuterJoin(...args) {\n    return this._joinType('right outer').join(...args);\n  }\n\n  outerJoin(...args) {\n    return this._joinType('outer').join(...args);\n  }\n\n  fullOuterJoin(...args) {\n    return this._joinType('full outer').join(...args);\n  }\n\n  crossJoin(...args) {\n    return this._joinType('cross').join(...args);\n  }\n\n  joinRaw(...args) {\n    return this._joinType('raw').join(...args);\n  }\n\n  // Where modifiers:\n  get or() {\n    return this._bool('or');\n  }\n\n  get not() {\n    return this._not(true);\n  }\n\n  // The where function can be used in several ways:\n  // The most basic is `where(key, value)`, which expands to\n  // where key = value.\n  where(column, operator, value) {\n    const argsLength = arguments.length;\n\n    // Support \"where true || where false\"\n    if (column === false || column === true) {\n      return this.where(1, '=', column ? 1 : 0);\n    }\n\n    // Check if the column is a function, in which case it's\n    // a where statement wrapped in parens.\n    if (typeof column === 'function') {\n      return this.whereWrapped(column);\n    }\n\n    // Allows `where({id: 2})` syntax.\n    if (isObject(column) && !column.isRawInstance)\n      return this._objectWhere(column);\n\n    // Allow a raw statement to be passed along to the query.\n    if (column && column.isRawInstance && argsLength === 1)\n      return this.whereRaw(column);\n\n    // Enable the where('key', value) syntax, only when there\n    // are explicitly two arguments passed, so it's not possible to\n    // do where('key', '!=') and have that turn into where key != null\n    if (argsLength === 2) {\n      value = operator;\n      operator = '=';\n\n      // If the value is null, and it's a two argument query,\n      // we assume we're going for a `whereNull`.\n      if (value === null) {\n        return this.whereNull(column);\n      }\n    }\n\n    // lower case the operator for comparison purposes\n    const checkOperator = `${operator}`.toLowerCase().trim();\n\n    // If there are 3 arguments, check whether 'in' is one of them.\n    if (argsLength === 3) {\n      if (checkOperator === 'in' || checkOperator === 'not in') {\n        return this._not(checkOperator === 'not in').whereIn(column, value);\n      }\n      if (checkOperator === 'between' || checkOperator === 'not between') {\n        return this._not(checkOperator === 'not between').whereBetween(\n          column,\n          value\n        );\n      }\n    }\n\n    // If the value is still null, check whether they're meaning\n    // where value is null\n    if (value === null) {\n      // Check for .where(key, 'is', null) or .where(key, 'is not', 'null');\n      if (checkOperator === 'is' || checkOperator === 'is not') {\n        return this._not(checkOperator === 'is not').whereNull(column);\n      }\n    }\n\n    // Push onto the where statement stack.\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereBasic',\n      column,\n      operator,\n      value,\n      not: this._not(),\n      bool: this._bool(),\n      asColumn: this._asColumnFlag,\n    });\n    return this;\n  }\n\n  whereColumn(...args) {\n    this._asColumnFlag = true;\n    this.where(...args);\n    this._asColumnFlag = false;\n    return this;\n  }\n\n  // Adds an `or where` clause to the query.\n  orWhere(column, ...args) {\n    this._bool('or');\n    const obj = column;\n    if (isObject(obj) && !obj.isRawInstance) {\n      return this.whereWrapped(function () {\n        for (const key in obj) {\n          this.andWhere(key, obj[key]);\n        }\n      });\n    }\n    return this.where(column, ...args);\n  }\n\n  orWhereColumn(column, ...args) {\n    this._bool('or');\n    const obj = column;\n    if (isObject(obj) && !obj.isRawInstance) {\n      return this.whereWrapped(function () {\n        for (const key in obj) {\n          this.andWhereColumn(key, '=', obj[key]);\n        }\n      });\n    }\n    return this.whereColumn(column, ...args);\n  }\n\n  // Adds an `not where` clause to the query.\n  whereNot(column, ...args) {\n    if (args.length >= 1) {\n      if (args[0] === 'in' || args[0] === 'between') {\n        this.client.logger.warn(\n          'whereNot is not suitable for \"in\" and \"between\" type subqueries. You should use \"not in\" and \"not between\" instead.'\n        );\n      }\n    }\n    return this._not(true).where(column, ...args);\n  }\n\n  whereNotColumn(...args) {\n    return this._not(true).whereColumn(...args);\n  }\n\n  // Adds an `or not where` clause to the query.\n  orWhereNot(...args) {\n    return this._bool('or').whereNot(...args);\n  }\n\n  orWhereNotColumn(...args) {\n    return this._bool('or').whereNotColumn(...args);\n  }\n\n  // Processes an object literal provided in a \"where\" clause.\n  _objectWhere(obj) {\n    const boolVal = this._bool();\n    const notVal = this._not() ? 'Not' : '';\n    for (const key in obj) {\n      this[boolVal + 'Where' + notVal](key, obj[key]);\n    }\n    return this;\n  }\n\n  // Adds a raw `where` clause to the query.\n  whereRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereRaw',\n      value: raw,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  orWhereRaw(sql, bindings) {\n    return this._bool('or').whereRaw(sql, bindings);\n  }\n\n  // Helper for compiling any advanced `where` queries.\n  whereWrapped(callback) {\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereWrapped',\n      value: callback,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  // Adds a `where exists` clause to the query.\n  whereExists(callback) {\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereExists',\n      value: callback,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  // Adds an `or where exists` clause to the query.\n  orWhereExists(callback) {\n    return this._bool('or').whereExists(callback);\n  }\n\n  // Adds a `where not exists` clause to the query.\n  whereNotExists(callback) {\n    return this._not(true).whereExists(callback);\n  }\n\n  // Adds a `or where not exists` clause to the query.\n  orWhereNotExists(callback) {\n    return this._bool('or').whereNotExists(callback);\n  }\n\n  // Adds a `where in` clause to the query.\n  whereIn(column, values) {\n    if (Array.isArray(values) && isEmpty(values))\n      return this.where(this._not());\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereIn',\n      column,\n      value: values,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  // Adds a `or where in` clause to the query.\n  orWhereIn(column, values) {\n    return this._bool('or').whereIn(column, values);\n  }\n\n  // Adds a `where not in` clause to the query.\n  whereNotIn(column, values) {\n    return this._not(true).whereIn(column, values);\n  }\n\n  // Adds a `or where not in` clause to the query.\n  orWhereNotIn(column, values) {\n    return this._bool('or')._not(true).whereIn(column, values);\n  }\n\n  // Adds a `where null` clause to the query.\n  whereNull(column) {\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereNull',\n      column,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  // Adds a `or where null` clause to the query.\n  orWhereNull(column) {\n    return this._bool('or').whereNull(column);\n  }\n\n  // Adds a `where not null` clause to the query.\n  whereNotNull(column) {\n    return this._not(true).whereNull(column);\n  }\n\n  // Adds a `or where not null` clause to the query.\n  orWhereNotNull(column) {\n    return this._bool('or').whereNotNull(column);\n  }\n\n  // Adds a `where between` clause to the query.\n  whereBetween(column, values) {\n    assert(\n      Array.isArray(values),\n      'The second argument to whereBetween must be an array.'\n    );\n    assert(\n      values.length === 2,\n      'You must specify 2 values for the whereBetween clause'\n    );\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereBetween',\n      column,\n      value: values,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  // Adds a `where not between` clause to the query.\n  whereNotBetween(column, values) {\n    return this._not(true).whereBetween(column, values);\n  }\n\n  // Adds a `or where between` clause to the query.\n  orWhereBetween(column, values) {\n    return this._bool('or').whereBetween(column, values);\n  }\n\n  // Adds a `or where not between` clause to the query.\n  orWhereNotBetween(column, values) {\n    return this._bool('or').whereNotBetween(column, values);\n  }\n\n  // Adds a `group by` clause to the query.\n  groupBy(item) {\n    if (item && item.isRawInstance) {\n      return this.groupByRaw.apply(this, arguments);\n    }\n    this._statements.push({\n      grouping: 'group',\n      type: 'groupByBasic',\n      value: normalizeArr(...arguments),\n    });\n    return this;\n  }\n\n  // Adds a raw `group by` clause to the query.\n  groupByRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n    this._statements.push({\n      grouping: 'group',\n      type: 'groupByRaw',\n      value: raw,\n    });\n    return this;\n  }\n\n  // Adds a `order by` clause to the query.\n  orderBy(column, direction) {\n    if (Array.isArray(column)) {\n      return this._orderByArray(column);\n    }\n    this._statements.push({\n      grouping: 'order',\n      type: 'orderByBasic',\n      value: column,\n      direction,\n    });\n    return this;\n  }\n\n  // Adds a `order by` with multiple columns to the query.\n  _orderByArray(columnDefs) {\n    for (let i = 0; i < columnDefs.length; i++) {\n      const columnInfo = columnDefs[i];\n      if (isObject(columnInfo)) {\n        this._statements.push({\n          grouping: 'order',\n          type: 'orderByBasic',\n          value: columnInfo['column'],\n          direction: columnInfo['order'],\n        });\n      } else if (isString(columnInfo)) {\n        this._statements.push({\n          grouping: 'order',\n          type: 'orderByBasic',\n          value: columnInfo,\n        });\n      }\n    }\n    return this;\n  }\n\n  // Add a raw `order by` clause to the query.\n  orderByRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n    this._statements.push({\n      grouping: 'order',\n      type: 'orderByRaw',\n      value: raw,\n    });\n    return this;\n  }\n\n  _union(clause, args) {\n    let callbacks = args[0];\n    let wrap = args[1];\n    if (args.length === 1 || (args.length === 2 && isBoolean(wrap))) {\n      if (!Array.isArray(callbacks)) {\n        callbacks = [callbacks];\n      }\n      for (let i = 0, l = callbacks.length; i < l; i++) {\n        this._statements.push({\n          grouping: 'union',\n          clause: clause,\n          value: callbacks[i],\n          wrap: wrap || false,\n        });\n      }\n    } else {\n      callbacks = toArray(args).slice(0, args.length - 1);\n      wrap = args[args.length - 1];\n      if (!isBoolean(wrap)) {\n        callbacks.push(wrap);\n        wrap = false;\n      }\n      this._union(clause, [callbacks, wrap]);\n    }\n    return this;\n  }\n\n  // Add a union statement to the query.\n  union(...args) {\n    return this._union('union', args);\n  }\n\n  // Adds a union all statement to the query.\n  unionAll(...args) {\n    return this._union('union all', args);\n  }\n\n  // Adds an intersect statement to the query\n  intersect(callbacks, wrap) {\n    if (arguments.length === 1 || (arguments.length === 2 && isBoolean(wrap))) {\n      if (!Array.isArray(callbacks)) {\n        callbacks = [callbacks];\n      }\n      for (let i = 0, l = callbacks.length; i < l; i++) {\n        this._statements.push({\n          grouping: 'union',\n          clause: 'intersect',\n          value: callbacks[i],\n          wrap: wrap || false,\n        });\n      }\n    } else {\n      callbacks = toArray(arguments).slice(0, arguments.length - 1);\n      wrap = arguments[arguments.length - 1];\n      if (!isBoolean(wrap)) {\n        callbacks.push(wrap);\n        wrap = false;\n      }\n      this.intersect(callbacks, wrap);\n    }\n    return this;\n  }\n\n  // Adds a `having` clause to the query.\n  having(column, operator, value) {\n    if (column.isRawInstance && arguments.length === 1) {\n      return this.havingRaw(column);\n    }\n\n    // Check if the column is a function, in which case it's\n    // a having statement wrapped in parens.\n    if (typeof column === 'function') {\n      return this.havingWrapped(column);\n    }\n\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingBasic',\n      column,\n      operator,\n      value,\n      bool: this._bool(),\n      not: this._not(),\n    });\n    return this;\n  }\n\n  orHaving(column, ...args) {\n    this._bool('or');\n    const obj = column;\n    if (isObject(obj) && !obj.isRawInstance) {\n      return this.havingWrapped(function () {\n        for (const key in obj) {\n          this.andHaving(key, obj[key]);\n        }\n      });\n    }\n    return this.having(column, ...args);\n  }\n\n  // Helper for compiling any advanced `having` queries.\n  havingWrapped(callback) {\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingWrapped',\n      value: callback,\n      bool: this._bool(),\n      not: this._not(),\n    });\n    return this;\n  }\n\n  havingNull(column) {\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingNull',\n      column,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  orHavingNull(callback) {\n    return this._bool('or').havingNull(callback);\n  }\n\n  havingNotNull(callback) {\n    return this._not(true).havingNull(callback);\n  }\n\n  orHavingNotNull(callback) {\n    return this._not(true)._bool('or').havingNull(callback);\n  }\n\n  havingExists(callback) {\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingExists',\n      value: callback,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  orHavingExists(callback) {\n    return this._bool('or').havingExists(callback);\n  }\n\n  havingNotExists(callback) {\n    return this._not(true).havingExists(callback);\n  }\n\n  orHavingNotExists(callback) {\n    return this._not(true)._bool('or').havingExists(callback);\n  }\n\n  havingBetween(column, values) {\n    assert(\n      Array.isArray(values),\n      'The second argument to havingBetween must be an array.'\n    );\n    assert(\n      values.length === 2,\n      'You must specify 2 values for the havingBetween clause'\n    );\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingBetween',\n      column,\n      value: values,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  orHavingBetween(column, values) {\n    return this._bool('or').havingBetween(column, values);\n  }\n\n  havingNotBetween(column, values) {\n    return this._not(true).havingBetween(column, values);\n  }\n\n  orHavingNotBetween(column, values) {\n    return this._not(true)._bool('or').havingBetween(column, values);\n  }\n\n  havingIn(column, values) {\n    if (Array.isArray(values) && isEmpty(values))\n      return this.where(this._not());\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingIn',\n      column,\n      value: values,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  // Adds a `or where in` clause to the query.\n  orHavingIn(column, values) {\n    return this._bool('or').havingIn(column, values);\n  }\n\n  // Adds a `where not in` clause to the query.\n  havingNotIn(column, values) {\n    return this._not(true).havingIn(column, values);\n  }\n\n  // Adds a `or where not in` clause to the query.\n  orHavingNotIn(column, values) {\n    return this._bool('or')._not(true).havingIn(column, values);\n  }\n\n  // Adds a raw `having` clause to the query.\n  havingRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingRaw',\n      value: raw,\n      bool: this._bool(),\n      not: this._not(),\n    });\n    return this;\n  }\n\n  orHavingRaw(sql, bindings) {\n    return this._bool('or').havingRaw(sql, bindings);\n  }\n\n  // Only allow a single \"offset\" to be set for the current query.\n  offset(value) {\n    if (value == null || value.isRawInstance || value instanceof Builder) {\n      // Builder for backward compatibility\n      this._single.offset = value;\n    } else {\n      const val = parseInt(value, 10);\n      if (isNaN(val)) {\n        this.client.logger.warn('A valid integer must be provided to offset');\n      } else if (val < 0) {\n        throw new Error(`A non-negative integer must be provided to offset.`);\n      } else {\n        this._single.offset = val;\n      }\n    }\n    return this;\n  }\n\n  // Only allow a single \"limit\" to be set for the current query.\n  limit(value) {\n    const val = parseInt(value, 10);\n    if (isNaN(val)) {\n      this.client.logger.warn('A valid integer must be provided to limit');\n    } else {\n      this._single.limit = val;\n    }\n    return this;\n  }\n\n  // Retrieve the \"count\" result of the query.\n  count(column, options) {\n    return this._aggregate('count', column || '*', options);\n  }\n\n  // Retrieve the minimum value of a given column.\n  min(column, options) {\n    return this._aggregate('min', column, options);\n  }\n\n  // Retrieve the maximum value of a given column.\n  max(column, options) {\n    return this._aggregate('max', column, options);\n  }\n\n  // Retrieve the sum of the values of a given column.\n  sum(column, options) {\n    return this._aggregate('sum', column, options);\n  }\n\n  // Retrieve the average of the values of a given column.\n  avg(column, options) {\n    return this._aggregate('avg', column, options);\n  }\n\n  // Retrieve the \"count\" of the distinct results of the query.\n  countDistinct(...columns) {\n    let options;\n    if (columns.length > 1 && isPlainObject(last(columns))) {\n      [options] = columns.splice(columns.length - 1, 1);\n    }\n\n    if (!columns.length) {\n      columns = '*';\n    } else if (columns.length === 1) {\n      columns = columns[0];\n    }\n\n    return this._aggregate('count', columns, { ...options, distinct: true });\n  }\n\n  // Retrieve the sum of the distinct values of a given column.\n  sumDistinct(column, options) {\n    return this._aggregate('sum', column, { ...options, distinct: true });\n  }\n\n  // Retrieve the vg of the distinct results of the query.\n  avgDistinct(column, options) {\n    return this._aggregate('avg', column, { ...options, distinct: true });\n  }\n\n  // Increments a column's value by the specified amount.\n  increment(column, amount = 1) {\n    if (isObject(column)) {\n      for (const key in column) {\n        this._counter(key, column[key]);\n      }\n\n      return this;\n    }\n\n    return this._counter(column, amount);\n  }\n\n  // Decrements a column's value by the specified amount.\n  decrement(column, amount = 1) {\n    if (isObject(column)) {\n      for (const key in column) {\n        this._counter(key, -column[key]);\n      }\n\n      return this;\n    }\n\n    return this._counter(column, -amount);\n  }\n\n  // Clears increments/decrements\n  clearCounters() {\n    this._single.counter = {};\n    return this;\n  }\n\n  // Sets the values for a `select` query, informing that only the first\n  // row should be returned (limit 1).\n  first(...args) {\n    if (this._method && this._method !== 'select') {\n      throw new Error(`Cannot chain .first() on \"${this._method}\" query`);\n    }\n\n    this.select(normalizeArr(...args));\n    this._method = 'first';\n    this.limit(1);\n    return this;\n  }\n\n  // Use existing connection to execute the query\n  // Same value that client.acquireConnection() for an according client returns should be passed\n  connection(_connection) {\n    this._connection = _connection;\n    return this;\n  }\n\n  // Pluck a column from a query.\n  pluck(column) {\n    if (this._method && this._method !== 'select') {\n      throw new Error(`Cannot chain .pluck() on \"${this._method}\" query`);\n    }\n\n    this._method = 'pluck';\n    this._single.pluck = column;\n    this._statements.push({\n      grouping: 'columns',\n      type: 'pluck',\n      value: column,\n    });\n    return this;\n  }\n\n  // Deprecated. Remove everything from select clause\n  clearSelect() {\n    this._clearGrouping('columns');\n    return this;\n  }\n\n  // Deprecated. Remove everything from where clause\n  clearWhere() {\n    this._clearGrouping('where');\n    return this;\n  }\n\n  // Deprecated. Remove everything from group clause\n  clearGroup() {\n    this._clearGrouping('group');\n    return this;\n  }\n\n  // Deprecated. Remove everything from order clause\n  clearOrder() {\n    this._clearGrouping('order');\n    return this;\n  }\n\n  // Deprecated. Remove everything from having clause\n  clearHaving() {\n    this._clearGrouping('having');\n    return this;\n  }\n\n  // Remove everything from statement clause\n  clear(statement) {\n    if (!CLEARABLE_STATEMENTS.has(statement))\n      throw new Error(`Knex Error: unknown statement '${statement}'`);\n    if (statement.startsWith('counter')) return this.clearCounters();\n    if (statement === 'select') {\n      statement = 'columns';\n    }\n    this._clearGrouping(statement);\n    return this;\n  }\n\n  // Insert & Update\n  // ------\n\n  // Sets the values for an `insert` query.\n  insert(values, returning, options) {\n    this._method = 'insert';\n    if (!isEmpty(returning)) this.returning(returning, options);\n    this._single.insert = values;\n    return this;\n  }\n\n  // Sets the values for an `update`, allowing for both\n  // `.update(key, value, [returning])` and `.update(obj, [returning])` syntaxes.\n  update(values, returning, options) {\n    let ret;\n    const obj = this._single.update || {};\n    this._method = 'update';\n    if (isString(values)) {\n      obj[values] = returning;\n      if (arguments.length > 2) {\n        ret = arguments[2];\n      }\n    } else {\n      const keys = Object.keys(values);\n      if (this._single.update) {\n        this.client.logger.warn('Update called multiple times with objects.');\n      }\n      let i = -1;\n      while (++i < keys.length) {\n        obj[keys[i]] = values[keys[i]];\n      }\n      ret = arguments[1];\n    }\n    if (!isEmpty(ret)) this.returning(ret, options);\n    this._single.update = obj;\n    return this;\n  }\n\n  // Sets the returning value for the query.\n  returning(returning, options) {\n    this._single.returning = returning;\n    this._single.options = options;\n    return this;\n  }\n\n  onConflict(columns) {\n    if (typeof columns === 'string') {\n      columns = [columns];\n    }\n    return new OnConflictBuilder(this, columns || true);\n  }\n\n  // Delete\n  // ------\n\n  // Executes a delete statement on the query;\n  delete(ret, options) {\n    this._method = 'del';\n    if (!isEmpty(ret)) this.returning(ret, options);\n    return this;\n  }\n\n  // Truncates a table, ends the query chain.\n  truncate(tableName) {\n    this._method = 'truncate';\n    if (tableName) {\n      this._single.table = tableName;\n    }\n    return this;\n  }\n\n  // Retrieves columns for the table specified by `knex(tableName)`\n  columnInfo(column) {\n    this._method = 'columnInfo';\n    this._single.columnInfo = column;\n    return this;\n  }\n\n  // Set a lock for update constraint.\n  forUpdate(...tables) {\n    this._single.lock = lockMode.forUpdate;\n    this._single.lockTables = tables;\n    return this;\n  }\n\n  // Set a lock for share constraint.\n  forShare(...tables) {\n    this._single.lock = lockMode.forShare;\n    this._single.lockTables = tables;\n    return this;\n  }\n\n  // Skips locked rows when using a lock constraint.\n  skipLocked() {\n    if (!this._isSelectQuery()) {\n      throw new Error(`Cannot chain .skipLocked() on \"${this._method}\" query!`);\n    }\n    if (!this._hasLockMode()) {\n      throw new Error(\n        '.skipLocked() can only be used after a call to .forShare() or .forUpdate()!'\n      );\n    }\n    if (this._single.waitMode === waitMode.noWait) {\n      throw new Error('.skipLocked() cannot be used together with .noWait()!');\n    }\n    this._single.waitMode = waitMode.skipLocked;\n    return this;\n  }\n\n  // Causes error when acessing a locked row instead of waiting for it to be released.\n  noWait() {\n    if (!this._isSelectQuery()) {\n      throw new Error(`Cannot chain .noWait() on \"${this._method}\" query!`);\n    }\n    if (!this._hasLockMode()) {\n      throw new Error(\n        '.noWait() can only be used after a call to .forShare() or .forUpdate()!'\n      );\n    }\n    if (this._single.waitMode === waitMode.skipLocked) {\n      throw new Error('.noWait() cannot be used together with .skipLocked()!');\n    }\n    this._single.waitMode = waitMode.noWait;\n    return this;\n  }\n\n  // Takes a JS object of methods to call and calls them\n  fromJS(obj) {\n    each(obj, (val, key) => {\n      if (typeof this[key] !== 'function') {\n        this.client.logger.warn(`Knex Error: unknown key ${key}`);\n      }\n      if (Array.isArray(val)) {\n        this[key].apply(this, val);\n      } else {\n        this[key](val);\n      }\n    });\n    return this;\n  }\n\n  // Passes query to provided callback function, useful for e.g. composing\n  // domain-specific helpers\n  modify(callback) {\n    callback.apply(this, [this].concat(tail(arguments)));\n    return this;\n  }\n\n  _analytic(alias, second, third) {\n    let analytic;\n    const { schema } = this._single;\n    const method = this._analyticMethod();\n    alias = typeof alias === 'string' ? alias : null;\n\n    assert(\n      typeof second === 'function' ||\n        second.isRawInstance ||\n        Array.isArray(second) ||\n        typeof second === 'string',\n      `The second argument to an analytic function must be either a function, a raw,\n       an array of string or a single string.`\n    );\n\n    if (third) {\n      assert(\n        Array.isArray(third) || typeof third === 'string',\n        'The third argument to an analytic function must be either a string or an array of string.'\n      );\n    }\n\n    if (isFunction(second)) {\n      analytic = new Analytic(method, schema, alias);\n      second.call(analytic, analytic);\n    } else if (second.isRawInstance) {\n      const raw = second;\n      analytic = {\n        grouping: 'columns',\n        type: 'analytic',\n        method: method,\n        raw: raw,\n        alias: alias,\n      };\n    } else {\n      const order = typeof second === 'string' ? [second] : second;\n      let partitions = third || [];\n      partitions = typeof partitions === 'string' ? [partitions] : partitions;\n      analytic = {\n        grouping: 'columns',\n        type: 'analytic',\n        method: method,\n        order: order,\n        alias: alias,\n        partitions: partitions,\n      };\n    }\n    this._statements.push(analytic);\n    return this;\n  }\n\n  rank(...args) {\n    return this._analyticMethod('rank')._analytic(...args);\n  }\n\n  denseRank(...args) {\n    return this._analyticMethod('dense_rank')._analytic(...args);\n  }\n\n  rowNumber(...args) {\n    return this._analyticMethod('row_number')._analytic(...args);\n  }\n\n  // ----------------------------------------------------------------------\n\n  // Helper for the incrementing/decrementing queries.\n  _counter(column, amount) {\n    amount = parseFloat(amount);\n\n    this._method = 'update';\n\n    this._single.counter = this._single.counter || {};\n\n    this._single.counter[column] = amount;\n\n    return this;\n  }\n\n  // Helper to get or set the \"boolFlag\" value.\n  _bool(val) {\n    if (arguments.length === 1) {\n      this._boolFlag = val;\n      return this;\n    }\n    const ret = this._boolFlag;\n    this._boolFlag = 'and';\n    return ret;\n  }\n\n  // Helper to get or set the \"notFlag\" value.\n  _not(val) {\n    if (arguments.length === 1) {\n      this._notFlag = val;\n      return this;\n    }\n    const ret = this._notFlag;\n    this._notFlag = false;\n    return ret;\n  }\n\n  // Helper to get or set the \"joinFlag\" value.\n  _joinType(val) {\n    if (arguments.length === 1) {\n      this._joinFlag = val;\n      return this;\n    }\n    const ret = this._joinFlag || 'inner';\n    this._joinFlag = 'inner';\n    return ret;\n  }\n\n  _analyticMethod(val) {\n    if (arguments.length === 1) {\n      this._analyticFlag = val;\n      return this;\n    }\n    return this._analyticFlag || 'row_number';\n  }\n\n  // Helper for compiling any aggregate queries.\n  _aggregate(method, column, options = {}) {\n    this._statements.push({\n      grouping: 'columns',\n      type: column.isRawInstance ? 'aggregateRaw' : 'aggregate',\n      method,\n      value: column,\n      aggregateDistinct: options.distinct || false,\n      alias: options.as,\n    });\n    return this;\n  }\n\n  // Helper function for clearing or reseting a grouping type from the builder\n  _clearGrouping(grouping) {\n    if (grouping in this._single) {\n      this._single[grouping] = undefined;\n    } else {\n      this._statements = reject(this._statements, { grouping });\n    }\n  }\n\n  // Helper function that checks if the builder will emit a select query\n  _isSelectQuery() {\n    return SELECT_COMMANDS.has(this._method);\n  }\n\n  // Helper function that checks if the query has a lock mode set\n  _hasLockMode() {\n    return LOCK_MODES.has(this._single.lock);\n  }\n}\n\nconst validateWithArgs = function (alias, statement, method) {\n  if (typeof alias !== 'string') {\n    throw new Error(`${method}() first argument must be a string`);\n  }\n  if (\n    typeof statement === 'function' ||\n    statement instanceof Builder ||\n    (statement && statement.isRawInstance)\n  ) {\n    return;\n  }\n  throw new Error(\n    `${method}() second argument must be a function / QueryBuilder or a raw`\n  );\n};\n\nBuilder.prototype.select = Builder.prototype.columns;\nBuilder.prototype.column = Builder.prototype.columns;\nBuilder.prototype.andWhereNot = Builder.prototype.whereNot;\nBuilder.prototype.andWhereNotColumn = Builder.prototype.whereNotColumn;\nBuilder.prototype.andWhere = Builder.prototype.where;\nBuilder.prototype.andWhereColumn = Builder.prototype.whereColumn;\nBuilder.prototype.andWhereRaw = Builder.prototype.whereRaw;\nBuilder.prototype.andWhereBetween = Builder.prototype.whereBetween;\nBuilder.prototype.andWhereNotBetween = Builder.prototype.whereNotBetween;\nBuilder.prototype.andHaving = Builder.prototype.having;\nBuilder.prototype.andHavingIn = Builder.prototype.havingIn;\nBuilder.prototype.andHavingNotIn = Builder.prototype.havingNotIn;\nBuilder.prototype.andHavingNull = Builder.prototype.havingNull;\nBuilder.prototype.andHavingNotNull = Builder.prototype.havingNotNull;\nBuilder.prototype.andHavingExists = Builder.prototype.havingExists;\nBuilder.prototype.andHavingNotExists = Builder.prototype.havingNotExists;\nBuilder.prototype.andHavingBetween = Builder.prototype.havingBetween;\nBuilder.prototype.andHavingNotBetween = Builder.prototype.havingNotBetween;\nBuilder.prototype.from = Builder.prototype.table;\nBuilder.prototype.into = Builder.prototype.table;\nBuilder.prototype.del = Builder.prototype.delete;\n\n// Attach all of the top level promise methods that should be chainable.\naugmentWithBuilderInterface(Builder);\naddQueryContext(Builder);\n\nBuilder.extend = (methodName, fn) => {\n  if (Object.prototype.hasOwnProperty.call(Builder.prototype, methodName)) {\n    throw new Error(\n      `Can't extend QueryBuilder with existing method ('${methodName}').`\n    );\n  }\n\n  assign(Builder.prototype, { [methodName]: fn });\n};\n\n// Sub-builder for onConflict clauses\nclass OnConflictBuilder {\n  constructor(builder, columns) {\n    this.builder = builder;\n    this._columns = columns;\n  }\n\n  // Sets insert query to ignore conflicts\n  ignore() {\n    this.builder._single.onConflict = this._columns;\n    this.builder._single.ignore = true;\n    return this.builder;\n  }\n\n  // Sets insert query to update on conflict\n  merge(updates) {\n    this.builder._single.onConflict = this._columns;\n    this.builder._single.merge = { updates };\n    return this.builder;\n  }\n\n  // Prevent\n  then() {\n    throw new Error(\n      'Incomplete onConflict clause. .onConflict() must be directly followed by either .merge() or .ignore()'\n    );\n  }\n}\n\nmodule.exports = Builder;\n"]},"metadata":{},"sourceType":"script"}