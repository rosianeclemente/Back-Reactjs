{"ast":null,"code":"// SQLite3_DDL\n//\n// All of the SQLite3 specific DDL helpers for renaming/dropping\n// columns and changing datatypes.\n// -------\nconst find = require('lodash/find');\n\nconst fromPairs = require('lodash/fromPairs');\n\nconst isEmpty = require('lodash/isEmpty');\n\nconst negate = require('lodash/negate');\n\nconst omit = require('lodash/omit');\n\nconst identity = require('lodash/identity');\n\nconst {\n  nanonum\n} = require('../../../util/nanoid');\n\nconst {\n  COMMA_NO_PAREN_REGEX\n} = require('../../../constants');\n\nconst {\n  createNewTable,\n  copyAllData,\n  dropOriginal,\n  copyData,\n  renameTable,\n  getTableSql\n} = require('./internal/sqlite-ddl-operations');\n\nconst {\n  parseCreateTable,\n  parseCreateIndex\n} = require('./internal/parser');\n\nconst {\n  compileCreateTable,\n  compileCreateIndex\n} = require('./internal/compiler'); // So altering the schema in SQLite3 is a major pain.\n// We have our own object to deal with the renaming and altering the types\n// for sqlite3 things.\n\n\nclass SQLite3_DDL {\n  constructor(client, tableCompiler, pragma, connection) {\n    this.client = client;\n    this.tableCompiler = tableCompiler;\n    this.pragma = pragma;\n    this.tableNameRaw = this.tableCompiler.tableNameRaw;\n    this.alteredName = `_knex_temp_alter${nanonum(3)}`;\n    this.connection = connection;\n\n    this.formatter = value => this.client.customWrapIdentifier(value, identity);\n\n    this.wrap = value => this.client.wrapIdentifierImpl(value);\n  }\n\n  tableName() {\n    return this.formatter(this.tableNameRaw);\n  }\n\n  async getColumn(column) {\n    const currentCol = find(this.pragma, col => {\n      return this.client.wrapIdentifier(col.name).toLowerCase() === this.client.wrapIdentifier(column).toLowerCase();\n    });\n    if (!currentCol) throw new Error(`The column ${column} is not in the ${this.tableName()} table`);\n    return currentCol;\n  }\n\n  getTableSql() {\n    const tableName = this.tableName();\n    this.trx.disableProcessing();\n    return this.trx.raw(getTableSql(tableName)).then(result => {\n      this.trx.enableProcessing();\n      return {\n        createTable: result.filter(create => create.type === 'table')[0].sql,\n        createIndices: result.filter(create => create.type === 'index').map(create => create.sql)\n      };\n    });\n  }\n\n  renameTable() {\n    return this.trx.raw(renameTable(this.alteredName, this.tableName()));\n  }\n\n  dropOriginal() {\n    return this.trx.raw(dropOriginal(this.tableName()));\n  }\n\n  async copyData(iterator) {\n    const commands = await copyData(this.trx, iterator, this.tableName(), this.alteredName);\n\n    for (const command of commands) {\n      await this.trx.raw(command);\n    }\n  }\n\n  createNewTable(sql) {\n    return this.trx.raw(createNewTable(sql, this.tableName(), this.alteredName));\n  }\n\n  _doReplace(sql, from, to) {\n    const oneLineSql = sql.replace(/\\s+/g, ' ');\n    const matched = oneLineSql.match(/^CREATE TABLE\\s+(\\S+)\\s*\\((.*)\\)/);\n    const tableName = matched[1];\n    const defs = matched[2];\n\n    if (!defs) {\n      throw new Error('No column definitions in this statement!');\n    }\n\n    let parens = 0,\n        args = [],\n        ptr = 0;\n    let i = 0;\n    const x = defs.length;\n\n    for (i = 0; i < x; i++) {\n      switch (defs[i]) {\n        case '(':\n          parens++;\n          break;\n\n        case ')':\n          parens--;\n          break;\n\n        case ',':\n          if (parens === 0) {\n            args.push(defs.slice(ptr, i));\n            ptr = i + 1;\n          }\n\n          break;\n\n        case ' ':\n          if (ptr === i) {\n            ptr = i + 1;\n          }\n\n          break;\n      }\n    }\n\n    args.push(defs.slice(ptr, i));\n    const fromIdentifier = from.replace(/[`\"'[\\]]/g, '');\n    args = args.map(item => {\n      let split = item.trim().split(' '); // SQLite supports all quoting mechanisms prevalent in all major dialects of SQL\n      // and preserves the original quoting in sqlite_master.\n      //\n      // Also, identifiers are never case sensitive, not even when quoted.\n      //\n      // Ref: https://www.sqlite.org/lang_keywords.html\n\n      const fromMatchCandidates = [new RegExp(`\\`${fromIdentifier}\\``, 'i'), new RegExp(`\"${fromIdentifier}\"`, 'i'), new RegExp(`'${fromIdentifier}'`, 'i'), new RegExp(`\\\\[${fromIdentifier}\\\\]`, 'i')];\n\n      if (fromIdentifier.match(/^\\S+$/)) {\n        fromMatchCandidates.push(new RegExp(`\\\\b${fromIdentifier}\\\\b`, 'i'));\n      }\n\n      const doesMatchFromIdentifier = target => fromMatchCandidates.some(c => target.match(c));\n\n      const replaceFromIdentifier = target => fromMatchCandidates.reduce((result, candidate) => result.replace(candidate, to), target);\n\n      if (doesMatchFromIdentifier(split[0])) {\n        // column definition\n        if (to) {\n          split[0] = to;\n          return split.join(' ');\n        }\n\n        return ''; // for deletions\n      } // skip constraint name\n\n\n      const idx = /constraint/i.test(split[0]) ? 2 : 0; // primary key and unique constraints have one or more\n      // columns from this table listed between (); replace\n      // one if it matches\n\n      if (/primary|unique/i.test(split[idx])) {\n        const ret = item.replace(/\\(.*\\)/, replaceFromIdentifier); // If any member columns are dropped then uniqueness/pk constraint\n        // can not be retained\n\n        if (ret !== item && isEmpty(to)) return '';\n        return ret;\n      } // foreign keys have one or more columns from this table\n      // listed between (); replace one if it matches\n      // foreign keys also have a 'references' clause\n      // which may reference THIS table; if it does, replace\n      // column references in that too!\n\n\n      if (/foreign/.test(split[idx])) {\n        split = item.split(/ references /i); // the quoted column names save us from having to do anything\n        // other than a straight replace here\n\n        const replacedKeySpec = replaceFromIdentifier(split[0]);\n\n        if (split[0] !== replacedKeySpec) {\n          // If we are removing one or more columns of a foreign\n          // key, then we should not retain the key at all\n          if (isEmpty(to)) return '';else split[0] = replacedKeySpec;\n        }\n\n        if (split[1].slice(0, tableName.length) === tableName) {\n          // self-referential foreign key\n          const replacedKeyTargetSpec = split[1].replace(/\\(.*\\)/, replaceFromIdentifier);\n\n          if (split[1] !== replacedKeyTargetSpec) {\n            // If we are removing one or more columns of a foreign\n            // key, then we should not retain the key at all\n            if (isEmpty(to)) return '';else split[1] = replacedKeyTargetSpec;\n          }\n        }\n\n        return split.join(' references ');\n      }\n\n      return item;\n    });\n    args = args.filter(negate(isEmpty));\n\n    if (args.length === 0) {\n      throw new Error('Unable to drop last column from table');\n    }\n\n    return oneLineSql.replace(/\\(.*\\)/, () => `(${args.join(', ')})`).replace(/,\\s*([,)])/, '$1');\n  }\n\n  async alterColumn(columns) {\n    return this.client.transaction(async trx => {\n      this.trx = trx;\n      const {\n        createTable,\n        createIndices\n      } = await this.getTableSql();\n      const parsedTable = parseCreateTable(createTable);\n      parsedTable.columns = parsedTable.columns.map(column => {\n        const newColumnInfo = columns.find(c => c.name === column.name);\n\n        if (newColumnInfo) {\n          column.type = newColumnInfo.type;\n          column.constraints.default = newColumnInfo.defaultTo !== null ? {\n            name: null,\n            value: newColumnInfo.defaultTo,\n            expression: false\n          } : null;\n          column.constraints.notnull = newColumnInfo.notNull ? {\n            name: null,\n            conflict: null\n          } : null;\n          column.constraints.null = newColumnInfo.notNull ? null : column.constraints.null;\n        }\n\n        return column;\n      });\n      const newTable = compileCreateTable(parsedTable, this.wrap);\n      return this.alter(newTable, createIndices, row => {\n        return row;\n      });\n    }, {\n      connection: this.connection\n    });\n  }\n\n  async dropColumn(columns) {\n    return this.client.transaction(trx => {\n      this.trx = trx;\n      return Promise.all(columns.map(column => this.getColumn(column))).then(() => this.getTableSql()).then(({\n        createTable,\n        createIndices\n      }) => {\n        let newSql = createTable.slice();\n        columns.forEach(column => {\n          const a = this.client.wrapIdentifier(column);\n          newSql = this._doReplace(newSql, a, '');\n        });\n\n        if (createTable === newSql) {\n          throw new Error('Unable to find the column to change');\n        }\n\n        const mappedColumns = Object.keys(this.client.postProcessResponse(fromPairs(columns.map(column => [column, column]))));\n        const newIndices = [];\n\n        for (const createIndex of createIndices) {\n          const parsedIndex = parseCreateIndex(createIndex);\n          parsedIndex.columns = parsedIndex.columns.filter(newColumn => newColumn.expression || !columns.some(column => newColumn.name === this.formatter(column)));\n\n          if (parsedIndex.columns.length > 0) {\n            newIndices.push(compileCreateIndex(parsedIndex, this.wrap));\n          }\n        }\n\n        return this.alter(newSql, newIndices, row => omit(row, ...mappedColumns));\n      });\n    }, {\n      connection: this.connection\n    });\n  }\n\n  async dropForeign(columns, foreignKeyName) {\n    return this.client.transaction(async trx => {\n      this.trx = trx;\n      const {\n        createTable,\n        createIndices\n      } = await this.getTableSql();\n      const parsedTable = parseCreateTable(createTable);\n\n      if (!foreignKeyName) {\n        parsedTable.columns = parsedTable.columns.map(column => ({ ...column,\n          references: columns.includes(column.name) ? null : column.references\n        }));\n      }\n\n      parsedTable.constraints = parsedTable.constraints.filter(constraint => {\n        if (foreignKeyName) {\n          return constraint.name !== foreignKeyName;\n        }\n\n        return constraint.columns.some(column => columns.includes(column)) === false;\n      });\n      const newTable = compileCreateTable(parsedTable, this.wrap);\n      return this.alter(newTable, createIndices, row => {\n        return row;\n      });\n    }, {\n      connection: this.connection\n    });\n  }\n\n  async dropPrimary(constraintName) {\n    return this.client.transaction(async trx => {\n      this.trx = trx;\n      const {\n        createTable,\n        createIndices\n      } = await this.getTableSql();\n      const oneLineSql = createTable.replace(/\\s+/g, ' ');\n      const matched = oneLineSql.match(/^CREATE TABLE\\s+(\\S+)\\s*\\((.*)\\)/);\n      const defs = matched[2];\n\n      if (!defs) {\n        throw new Error('No column definitions in this statement!');\n      }\n\n      const updatedDefs = defs.split(COMMA_NO_PAREN_REGEX).map(line => line.trim()).filter(defLine => {\n        if (defLine.startsWith('constraint') === false && defLine.includes('primary key') === false) return true;\n\n        if (constraintName) {\n          if (defLine.includes(constraintName)) return false;\n          return true;\n        } else {\n          return true;\n        }\n      }).join(', ');\n      const newSql = oneLineSql.replace(defs, updatedDefs);\n      return this.alter(newSql, createIndices, row => {\n        return row;\n      });\n    }, {\n      connection: this.connection\n    });\n  }\n\n  async primary(columns, constraintName) {\n    return this.client.transaction(async trx => {\n      this.trx = trx;\n      const {\n        createTable,\n        createIndices\n      } = await this.getTableSql();\n      const oneLineSql = createTable.replace(/\\s+/g, ' ');\n      const matched = oneLineSql.match(/^CREATE TABLE\\s+(\\S+)\\s*\\((.*)\\)/);\n      const columnDefinitions = matched[2];\n\n      if (!columnDefinitions) {\n        throw new Error('No column definitions in this statement!');\n      }\n\n      const primaryKeyDef = `primary key(${columns.join(',')})`;\n      const constraintDef = constraintName ? `constraint ${constraintName} ${primaryKeyDef}` : primaryKeyDef;\n      const newColumnDefinitions = [...columnDefinitions.split(COMMA_NO_PAREN_REGEX).map(line => line.trim()).filter(line => line.startsWith('primary') === false).map(line => line.replace(/primary key/i, '')), constraintDef].join(', ');\n      const newSQL = oneLineSql.replace(columnDefinitions, newColumnDefinitions);\n      return this.alter(newSQL, createIndices, row => {\n        return row;\n      });\n    }, {\n      connection: this.connection\n    });\n  }\n\n  async foreign(foreignInfo) {\n    return this.client.transaction(async trx => {\n      this.trx = trx;\n      const {\n        createTable,\n        createIndices\n      } = await this.getTableSql();\n      const oneLineSql = createTable.replace(/\\s+/g, ' ');\n      const matched = oneLineSql.match(/^CREATE TABLE\\s+(\\S+)\\s*\\((.*)\\)/);\n      const columnDefinitions = matched[2];\n\n      if (!columnDefinitions) {\n        throw new Error('No column definitions in this statement!');\n      }\n\n      const newColumnDefinitions = columnDefinitions.split(COMMA_NO_PAREN_REGEX).map(line => line.trim());\n      let newForeignSQL = '';\n\n      if (foreignInfo.keyName) {\n        newForeignSQL += `CONSTRAINT ${foreignInfo.keyName}`;\n      }\n\n      newForeignSQL += ` FOREIGN KEY (${foreignInfo.column.join(', ')}) `;\n      newForeignSQL += ` REFERENCES ${foreignInfo.inTable} (${foreignInfo.references})`;\n\n      if (foreignInfo.onUpdate) {\n        newForeignSQL += ` ON UPDATE ${foreignInfo.onUpdate}`;\n      }\n\n      if (foreignInfo.onDelete) {\n        newForeignSQL += ` ON DELETE ${foreignInfo.onDelete}`;\n      }\n\n      newColumnDefinitions.push(newForeignSQL);\n      const newSQL = oneLineSql.replace(columnDefinitions, newColumnDefinitions.join(', '));\n      return await this.generateAlterCommands(newSQL, createIndices, row => {\n        return row;\n      });\n    }, {\n      connection: this.connection\n    });\n  }\n  /**\n   * @fixme\n   *\n   * There's a bunch of overlap between renameColumn/dropColumn/dropForeign/primary/foreign.\n   * It'll be helpful to refactor this file heavily to combine/optimize some of these calls\n   */\n\n\n  async alter(newSql, createIndices, mapRow) {\n    await this.createNewTable(newSql);\n    await this.copyData(mapRow);\n    await this.dropOriginal();\n    await this.renameTable();\n\n    for (const createIndex of createIndices) {\n      await this.trx.raw(createIndex);\n    }\n  }\n\n  async generateAlterCommands(newSql, createIndices, mapRow) {\n    const result = [];\n    result.push(createNewTable(newSql, this.tableName(), this.alteredName));\n    result.push(copyAllData(this.tableName(), this.alteredName));\n    result.push(dropOriginal(this.tableName()));\n    result.push(renameTable(this.alteredName, this.tableName()));\n\n    for (const createIndex of createIndices) {\n      result.push(createIndex);\n    }\n\n    return result;\n  }\n\n}\n\nmodule.exports = SQLite3_DDL;","map":{"version":3,"sources":["/home/rosiane/Projeto-completo/back/node_modules/knex/lib/dialects/sqlite3/schema/ddl.js"],"names":["find","require","fromPairs","isEmpty","negate","omit","identity","nanonum","COMMA_NO_PAREN_REGEX","createNewTable","copyAllData","dropOriginal","copyData","renameTable","getTableSql","parseCreateTable","parseCreateIndex","compileCreateTable","compileCreateIndex","SQLite3_DDL","constructor","client","tableCompiler","pragma","connection","tableNameRaw","alteredName","formatter","value","customWrapIdentifier","wrap","wrapIdentifierImpl","tableName","getColumn","column","currentCol","col","wrapIdentifier","name","toLowerCase","Error","trx","disableProcessing","raw","then","result","enableProcessing","createTable","filter","create","type","sql","createIndices","map","iterator","commands","command","_doReplace","from","to","oneLineSql","replace","matched","match","defs","parens","args","ptr","i","x","length","push","slice","fromIdentifier","item","split","trim","fromMatchCandidates","RegExp","doesMatchFromIdentifier","target","some","c","replaceFromIdentifier","reduce","candidate","join","idx","test","ret","replacedKeySpec","replacedKeyTargetSpec","alterColumn","columns","transaction","parsedTable","newColumnInfo","constraints","default","defaultTo","expression","notnull","notNull","conflict","null","newTable","alter","row","dropColumn","Promise","all","newSql","forEach","a","mappedColumns","Object","keys","postProcessResponse","newIndices","createIndex","parsedIndex","newColumn","dropForeign","foreignKeyName","references","includes","constraint","dropPrimary","constraintName","updatedDefs","line","defLine","startsWith","primary","columnDefinitions","primaryKeyDef","constraintDef","newColumnDefinitions","newSQL","foreign","foreignInfo","newForeignSQL","keyName","inTable","onUpdate","onDelete","generateAlterCommands","mapRow","module","exports"],"mappings":"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","sourcesContent":["// SQLite3_DDL\n//\n// All of the SQLite3 specific DDL helpers for renaming/dropping\n// columns and changing datatypes.\n// -------\n\nconst find = require('lodash/find');\nconst fromPairs = require('lodash/fromPairs');\nconst isEmpty = require('lodash/isEmpty');\nconst negate = require('lodash/negate');\nconst omit = require('lodash/omit');\nconst identity = require('lodash/identity');\nconst { nanonum } = require('../../../util/nanoid');\nconst { COMMA_NO_PAREN_REGEX } = require('../../../constants');\nconst {\n  createNewTable,\n  copyAllData,\n  dropOriginal,\n  copyData,\n  renameTable,\n  getTableSql,\n} = require('./internal/sqlite-ddl-operations');\nconst { parseCreateTable, parseCreateIndex } = require('./internal/parser');\nconst {\n  compileCreateTable,\n  compileCreateIndex,\n} = require('./internal/compiler');\n\n// So altering the schema in SQLite3 is a major pain.\n// We have our own object to deal with the renaming and altering the types\n// for sqlite3 things.\nclass SQLite3_DDL {\n  constructor(client, tableCompiler, pragma, connection) {\n    this.client = client;\n    this.tableCompiler = tableCompiler;\n    this.pragma = pragma;\n    this.tableNameRaw = this.tableCompiler.tableNameRaw;\n    this.alteredName = `_knex_temp_alter${nanonum(3)}`;\n    this.connection = connection;\n    this.formatter = (value) =>\n      this.client.customWrapIdentifier(value, identity);\n    this.wrap = (value) => this.client.wrapIdentifierImpl(value);\n  }\n\n  tableName() {\n    return this.formatter(this.tableNameRaw);\n  }\n\n  async getColumn(column) {\n    const currentCol = find(this.pragma, (col) => {\n      return (\n        this.client.wrapIdentifier(col.name).toLowerCase() ===\n        this.client.wrapIdentifier(column).toLowerCase()\n      );\n    });\n    if (!currentCol)\n      throw new Error(\n        `The column ${column} is not in the ${this.tableName()} table`\n      );\n    return currentCol;\n  }\n\n  getTableSql() {\n    const tableName = this.tableName();\n\n    this.trx.disableProcessing();\n    return this.trx.raw(getTableSql(tableName)).then((result) => {\n      this.trx.enableProcessing();\n      return {\n        createTable: result.filter((create) => create.type === 'table')[0].sql,\n        createIndices: result\n          .filter((create) => create.type === 'index')\n          .map((create) => create.sql),\n      };\n    });\n  }\n\n  renameTable() {\n    return this.trx.raw(renameTable(this.alteredName, this.tableName()));\n  }\n\n  dropOriginal() {\n    return this.trx.raw(dropOriginal(this.tableName()));\n  }\n\n  async copyData(iterator) {\n    const commands = await copyData(\n      this.trx,\n      iterator,\n      this.tableName(),\n      this.alteredName\n    );\n    for (const command of commands) {\n      await this.trx.raw(command);\n    }\n  }\n\n  createNewTable(sql) {\n    return this.trx.raw(\n      createNewTable(sql, this.tableName(), this.alteredName)\n    );\n  }\n\n  _doReplace(sql, from, to) {\n    const oneLineSql = sql.replace(/\\s+/g, ' ');\n    const matched = oneLineSql.match(/^CREATE TABLE\\s+(\\S+)\\s*\\((.*)\\)/);\n\n    const tableName = matched[1];\n    const defs = matched[2];\n\n    if (!defs) {\n      throw new Error('No column definitions in this statement!');\n    }\n\n    let parens = 0,\n      args = [],\n      ptr = 0;\n    let i = 0;\n    const x = defs.length;\n    for (i = 0; i < x; i++) {\n      switch (defs[i]) {\n        case '(':\n          parens++;\n          break;\n        case ')':\n          parens--;\n          break;\n        case ',':\n          if (parens === 0) {\n            args.push(defs.slice(ptr, i));\n            ptr = i + 1;\n          }\n          break;\n        case ' ':\n          if (ptr === i) {\n            ptr = i + 1;\n          }\n          break;\n      }\n    }\n    args.push(defs.slice(ptr, i));\n\n    const fromIdentifier = from.replace(/[`\"'[\\]]/g, '');\n\n    args = args.map((item) => {\n      let split = item.trim().split(' ');\n\n      // SQLite supports all quoting mechanisms prevalent in all major dialects of SQL\n      // and preserves the original quoting in sqlite_master.\n      //\n      // Also, identifiers are never case sensitive, not even when quoted.\n      //\n      // Ref: https://www.sqlite.org/lang_keywords.html\n      const fromMatchCandidates = [\n        new RegExp(`\\`${fromIdentifier}\\``, 'i'),\n        new RegExp(`\"${fromIdentifier}\"`, 'i'),\n        new RegExp(`'${fromIdentifier}'`, 'i'),\n        new RegExp(`\\\\[${fromIdentifier}\\\\]`, 'i'),\n      ];\n      if (fromIdentifier.match(/^\\S+$/)) {\n        fromMatchCandidates.push(new RegExp(`\\\\b${fromIdentifier}\\\\b`, 'i'));\n      }\n\n      const doesMatchFromIdentifier = (target) =>\n        fromMatchCandidates.some((c) => target.match(c));\n\n      const replaceFromIdentifier = (target) =>\n        fromMatchCandidates.reduce(\n          (result, candidate) => result.replace(candidate, to),\n          target\n        );\n\n      if (doesMatchFromIdentifier(split[0])) {\n        // column definition\n        if (to) {\n          split[0] = to;\n          return split.join(' ');\n        }\n        return ''; // for deletions\n      }\n\n      // skip constraint name\n      const idx = /constraint/i.test(split[0]) ? 2 : 0;\n\n      // primary key and unique constraints have one or more\n      // columns from this table listed between (); replace\n      // one if it matches\n      if (/primary|unique/i.test(split[idx])) {\n        const ret = item.replace(/\\(.*\\)/, replaceFromIdentifier);\n        // If any member columns are dropped then uniqueness/pk constraint\n        // can not be retained\n        if (ret !== item && isEmpty(to)) return '';\n        return ret;\n      }\n\n      // foreign keys have one or more columns from this table\n      // listed between (); replace one if it matches\n      // foreign keys also have a 'references' clause\n      // which may reference THIS table; if it does, replace\n      // column references in that too!\n      if (/foreign/.test(split[idx])) {\n        split = item.split(/ references /i);\n        // the quoted column names save us from having to do anything\n        // other than a straight replace here\n        const replacedKeySpec = replaceFromIdentifier(split[0]);\n\n        if (split[0] !== replacedKeySpec) {\n          // If we are removing one or more columns of a foreign\n          // key, then we should not retain the key at all\n          if (isEmpty(to)) return '';\n          else split[0] = replacedKeySpec;\n        }\n\n        if (split[1].slice(0, tableName.length) === tableName) {\n          // self-referential foreign key\n          const replacedKeyTargetSpec = split[1].replace(\n            /\\(.*\\)/,\n            replaceFromIdentifier\n          );\n          if (split[1] !== replacedKeyTargetSpec) {\n            // If we are removing one or more columns of a foreign\n            // key, then we should not retain the key at all\n            if (isEmpty(to)) return '';\n            else split[1] = replacedKeyTargetSpec;\n          }\n        }\n        return split.join(' references ');\n      }\n\n      return item;\n    });\n\n    args = args.filter(negate(isEmpty));\n\n    if (args.length === 0) {\n      throw new Error('Unable to drop last column from table');\n    }\n\n    return oneLineSql\n      .replace(/\\(.*\\)/, () => `(${args.join(', ')})`)\n      .replace(/,\\s*([,)])/, '$1');\n  }\n\n  async alterColumn(columns) {\n    return this.client.transaction(\n      async (trx) => {\n        this.trx = trx;\n\n        const { createTable, createIndices } = await this.getTableSql();\n\n        const parsedTable = parseCreateTable(createTable);\n\n        parsedTable.columns = parsedTable.columns.map((column) => {\n          const newColumnInfo = columns.find((c) => c.name === column.name);\n\n          if (newColumnInfo) {\n            column.type = newColumnInfo.type;\n\n            column.constraints.default =\n              newColumnInfo.defaultTo !== null\n                ? {\n                    name: null,\n                    value: newColumnInfo.defaultTo,\n                    expression: false,\n                  }\n                : null;\n\n            column.constraints.notnull = newColumnInfo.notNull\n              ? { name: null, conflict: null }\n              : null;\n\n            column.constraints.null = newColumnInfo.notNull\n              ? null\n              : column.constraints.null;\n          }\n\n          return column;\n        });\n\n        const newTable = compileCreateTable(parsedTable, this.wrap);\n\n        return this.alter(newTable, createIndices, (row) => {\n          return row;\n        });\n      },\n      { connection: this.connection }\n    );\n  }\n\n  async dropColumn(columns) {\n    return this.client.transaction(\n      (trx) => {\n        this.trx = trx;\n        return Promise.all(columns.map((column) => this.getColumn(column)))\n          .then(() => this.getTableSql())\n          .then(({ createTable, createIndices }) => {\n            let newSql = createTable.slice();\n            columns.forEach((column) => {\n              const a = this.client.wrapIdentifier(column);\n              newSql = this._doReplace(newSql, a, '');\n            });\n            if (createTable === newSql) {\n              throw new Error('Unable to find the column to change');\n            }\n            const mappedColumns = Object.keys(\n              this.client.postProcessResponse(\n                fromPairs(columns.map((column) => [column, column]))\n              )\n            );\n\n            const newIndices = [];\n            for (const createIndex of createIndices) {\n              const parsedIndex = parseCreateIndex(createIndex);\n\n              parsedIndex.columns = parsedIndex.columns.filter(\n                (newColumn) =>\n                  newColumn.expression ||\n                  !columns.some(\n                    (column) => newColumn.name === this.formatter(column)\n                  )\n              );\n\n              if (parsedIndex.columns.length > 0) {\n                newIndices.push(compileCreateIndex(parsedIndex, this.wrap));\n              }\n            }\n\n            return this.alter(newSql, newIndices, (row) =>\n              omit(row, ...mappedColumns)\n            );\n          });\n      },\n      { connection: this.connection }\n    );\n  }\n\n  async dropForeign(columns, foreignKeyName) {\n    return this.client.transaction(\n      async (trx) => {\n        this.trx = trx;\n\n        const { createTable, createIndices } = await this.getTableSql();\n\n        const parsedTable = parseCreateTable(createTable);\n\n        if (!foreignKeyName) {\n          parsedTable.columns = parsedTable.columns.map((column) => ({\n            ...column,\n            references: columns.includes(column.name)\n              ? null\n              : column.references,\n          }));\n        }\n\n        parsedTable.constraints = parsedTable.constraints.filter(\n          (constraint) => {\n            if (foreignKeyName) {\n              return constraint.name !== foreignKeyName;\n            }\n\n            return (\n              constraint.columns.some((column) => columns.includes(column)) ===\n              false\n            );\n          }\n        );\n\n        const newTable = compileCreateTable(parsedTable, this.wrap);\n\n        return this.alter(newTable, createIndices, (row) => {\n          return row;\n        });\n      },\n      { connection: this.connection }\n    );\n  }\n\n  async dropPrimary(constraintName) {\n    return this.client.transaction(\n      async (trx) => {\n        this.trx = trx;\n\n        const { createTable, createIndices } = await this.getTableSql();\n\n        const oneLineSql = createTable.replace(/\\s+/g, ' ');\n        const matched = oneLineSql.match(/^CREATE TABLE\\s+(\\S+)\\s*\\((.*)\\)/);\n\n        const defs = matched[2];\n\n        if (!defs) {\n          throw new Error('No column definitions in this statement!');\n        }\n\n        const updatedDefs = defs\n          .split(COMMA_NO_PAREN_REGEX)\n          .map((line) => line.trim())\n          .filter((defLine) => {\n            if (\n              defLine.startsWith('constraint') === false &&\n              defLine.includes('primary key') === false\n            )\n              return true;\n\n            if (constraintName) {\n              if (defLine.includes(constraintName)) return false;\n              return true;\n            } else {\n              return true;\n            }\n          })\n          .join(', ');\n\n        const newSql = oneLineSql.replace(defs, updatedDefs);\n\n        return this.alter(newSql, createIndices, (row) => {\n          return row;\n        });\n      },\n      { connection: this.connection }\n    );\n  }\n\n  async primary(columns, constraintName) {\n    return this.client.transaction(\n      async (trx) => {\n        this.trx = trx;\n\n        const { createTable, createIndices } = await this.getTableSql();\n\n        const oneLineSql = createTable.replace(/\\s+/g, ' ');\n        const matched = oneLineSql.match(/^CREATE TABLE\\s+(\\S+)\\s*\\((.*)\\)/);\n\n        const columnDefinitions = matched[2];\n\n        if (!columnDefinitions) {\n          throw new Error('No column definitions in this statement!');\n        }\n\n        const primaryKeyDef = `primary key(${columns.join(',')})`;\n        const constraintDef = constraintName\n          ? `constraint ${constraintName} ${primaryKeyDef}`\n          : primaryKeyDef;\n\n        const newColumnDefinitions = [\n          ...columnDefinitions\n            .split(COMMA_NO_PAREN_REGEX)\n            .map((line) => line.trim())\n            .filter((line) => line.startsWith('primary') === false)\n            .map((line) => line.replace(/primary key/i, '')),\n          constraintDef,\n        ].join(', ');\n\n        const newSQL = oneLineSql.replace(\n          columnDefinitions,\n          newColumnDefinitions\n        );\n\n        return this.alter(newSQL, createIndices, (row) => {\n          return row;\n        });\n      },\n      { connection: this.connection }\n    );\n  }\n\n  async foreign(foreignInfo) {\n    return this.client.transaction(\n      async (trx) => {\n        this.trx = trx;\n\n        const { createTable, createIndices } = await this.getTableSql();\n\n        const oneLineSql = createTable.replace(/\\s+/g, ' ');\n        const matched = oneLineSql.match(/^CREATE TABLE\\s+(\\S+)\\s*\\((.*)\\)/);\n\n        const columnDefinitions = matched[2];\n\n        if (!columnDefinitions) {\n          throw new Error('No column definitions in this statement!');\n        }\n\n        const newColumnDefinitions = columnDefinitions\n          .split(COMMA_NO_PAREN_REGEX)\n          .map((line) => line.trim());\n\n        let newForeignSQL = '';\n\n        if (foreignInfo.keyName) {\n          newForeignSQL += `CONSTRAINT ${foreignInfo.keyName}`;\n        }\n\n        newForeignSQL += ` FOREIGN KEY (${foreignInfo.column.join(', ')}) `;\n        newForeignSQL += ` REFERENCES ${foreignInfo.inTable} (${foreignInfo.references})`;\n\n        if (foreignInfo.onUpdate) {\n          newForeignSQL += ` ON UPDATE ${foreignInfo.onUpdate}`;\n        }\n\n        if (foreignInfo.onDelete) {\n          newForeignSQL += ` ON DELETE ${foreignInfo.onDelete}`;\n        }\n\n        newColumnDefinitions.push(newForeignSQL);\n\n        const newSQL = oneLineSql.replace(\n          columnDefinitions,\n          newColumnDefinitions.join(', ')\n        );\n\n        return await this.generateAlterCommands(\n          newSQL,\n          createIndices,\n          (row) => {\n            return row;\n          }\n        );\n      },\n      { connection: this.connection }\n    );\n  }\n\n  /**\n   * @fixme\n   *\n   * There's a bunch of overlap between renameColumn/dropColumn/dropForeign/primary/foreign.\n   * It'll be helpful to refactor this file heavily to combine/optimize some of these calls\n   */\n\n  async alter(newSql, createIndices, mapRow) {\n    await this.createNewTable(newSql);\n    await this.copyData(mapRow);\n    await this.dropOriginal();\n    await this.renameTable();\n\n    for (const createIndex of createIndices) {\n      await this.trx.raw(createIndex);\n    }\n  }\n\n  async generateAlterCommands(newSql, createIndices, mapRow) {\n    const result = [];\n\n    result.push(createNewTable(newSql, this.tableName(), this.alteredName));\n    result.push(copyAllData(this.tableName(), this.alteredName));\n    result.push(dropOriginal(this.tableName()));\n    result.push(renameTable(this.alteredName, this.tableName()));\n\n    for (const createIndex of createIndices) {\n      result.push(createIndex);\n    }\n\n    return result;\n  }\n}\n\nmodule.exports = SQLite3_DDL;\n"]},"metadata":{},"sourceType":"script"}