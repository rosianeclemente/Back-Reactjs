{"ast":null,"code":"const clone = require('lodash/clone');\n\nconst each = require('lodash/each');\n\nconst isEmpty = require('lodash/isEmpty');\n\nconst isPlainObject = require('lodash/isPlainObject');\n\nconst Oracle_Compiler = require('../../oracle/query/oracle-querycompiler');\n\nconst ReturningHelper = require('../utils').ReturningHelper;\n\nconst BlobHelper = require('../utils').BlobHelper;\n\nconst {\n  isString\n} = require('../../../util/is');\n\nclass Oracledb_Compiler extends Oracle_Compiler {\n  // Compiles an \"insert\" query, allowing for multiple\n  // inserts using a single query statement.\n  insert() {\n    const self = this;\n\n    const outBindPrep = this._prepOutbindings(this.single.insert, this.single.returning);\n\n    const outBinding = outBindPrep.outBinding;\n    const returning = outBindPrep.returning;\n    const insertValues = outBindPrep.values;\n\n    if (Array.isArray(insertValues) && insertValues.length === 1 && isEmpty(insertValues[0])) {\n      const returningFragment = this.single.returning ? ' (' + this.formatter.wrap(this.single.returning) + ')' : '';\n      return this._addReturningToSqlAndConvert('insert into ' + this.tableName + returningFragment + ' values (default)', outBinding[0], this.tableName, returning);\n    }\n\n    if (isEmpty(this.single.insert) && typeof this.single.insert !== 'function') {\n      return '';\n    }\n\n    const insertData = this._prepInsert(insertValues);\n\n    const sql = {};\n\n    if (isString(insertData)) {\n      return this._addReturningToSqlAndConvert('insert into ' + this.tableName + ' ' + insertData, outBinding[0], this.tableName, returning);\n    }\n\n    if (insertData.values.length === 1) {\n      return this._addReturningToSqlAndConvert('insert into ' + this.tableName + ' (' + this.formatter.columnize(insertData.columns) + ') values (' + this.client.parameterize(insertData.values[0], undefined, this.builder, this.bindingsHolder) + ')', outBinding[0], this.tableName, returning);\n    }\n\n    const insertDefaultsOnly = insertData.columns.length === 0;\n    sql.returning = returning;\n    sql.sql = 'begin ' + insertData.values.map(function (value, index) {\n      const parameterizedValues = !insertDefaultsOnly ? self.client.parameterize(value, self.client.valueForUndefined, self.builder, self.bindingsHolder) : '';\n      let subSql = 'insert into ' + self.tableName;\n\n      if (insertDefaultsOnly) {\n        // No columns given so only the default value\n        subSql += ' (' + self.formatter.wrap(self.single.returning) + ') values (default)';\n      } else {\n        subSql += ' (' + self.formatter.columnize(insertData.columns) + ') values (' + parameterizedValues + ')';\n      }\n\n      let returningClause = '';\n      let intoClause = ''; // ToDo review if this code is still needed or could be dropped\n      // eslint-disable-next-line no-unused-vars\n\n      let usingClause = '';\n      let outClause = '';\n      each(value, function (val) {\n        if (!(val instanceof BlobHelper)) {\n          usingClause += ' ?,';\n        }\n      }); // eslint-disable-next-line no-unused-vars\n\n      usingClause = usingClause.slice(0, -1); // Build returning and into clauses\n\n      outBinding[index].forEach(function (ret) {\n        const columnName = ret.columnName || ret;\n        returningClause += self.formatter.wrap(columnName) + ',';\n        intoClause += ' ?,';\n        outClause += ' out ?,'; // Add Helpers to bindings\n\n        if (ret instanceof BlobHelper) {\n          return self.formatter.bindings.push(ret);\n        }\n\n        self.formatter.bindings.push(new ReturningHelper(columnName));\n      }); // Strip last comma\n\n      returningClause = returningClause.slice(0, -1);\n      intoClause = intoClause.slice(0, -1);\n      outClause = outClause.slice(0, -1);\n\n      if (returningClause && intoClause) {\n        subSql += ' returning ' + returningClause + ' into' + intoClause;\n      } // Pre bind position because subSql is an execute immediate parameter\n      // later position binding will only convert the ? params\n\n\n      subSql = self.formatter.client.positionBindings(subSql);\n      const parameterizedValuesWithoutDefaultAndBlob = parameterizedValues.replace('DEFAULT, ', '').replace(', DEFAULT', '').replace('EMPTY_BLOB(), ', '').replace(', EMPTY_BLOB()', '');\n      return \"execute immediate '\" + subSql.replace(/'/g, \"''\") + (parameterizedValuesWithoutDefaultAndBlob || value ? \"' using \" : '') + parameterizedValuesWithoutDefaultAndBlob + (parameterizedValuesWithoutDefaultAndBlob && outClause ? ',' : '') + outClause + ';';\n    }).join(' ') + 'end;';\n    sql.outBinding = outBinding;\n\n    if (returning[0] === '*') {\n      // Generate select statement with special order by\n      // to keep the order because 'in (..)' may change the order\n      sql.returningSql = function () {\n        return 'select * from ' + self.tableName + ' where ROWID in (' + this.outBinding.map(function (v, i) {\n          return ':' + (i + 1);\n        }).join(', ') + ')' + ' order by case ROWID ' + this.outBinding.map(function (v, i) {\n          return 'when CHARTOROWID(:' + (i + 1) + ') then ' + i;\n        }).join(' ') + ' end';\n      };\n    }\n\n    return sql;\n  }\n\n  _addReturningToSqlAndConvert(sql, outBinding, tableName, returning) {\n    const self = this;\n    const res = {\n      sql: sql\n    };\n\n    if (!outBinding) {\n      return res;\n    }\n\n    const returningValues = Array.isArray(outBinding) ? outBinding : [outBinding];\n    let returningClause = '';\n    let intoClause = ''; // Build returning and into clauses\n\n    returningValues.forEach(function (ret) {\n      const columnName = ret.columnName || ret;\n      returningClause += self.formatter.wrap(columnName) + ',';\n      intoClause += '?,'; // Add Helpers to bindings\n\n      if (ret instanceof BlobHelper) {\n        return self.formatter.bindings.push(ret);\n      }\n\n      self.formatter.bindings.push(new ReturningHelper(columnName));\n    });\n    res.sql = sql; // Strip last comma\n\n    returningClause = returningClause.slice(0, -1);\n    intoClause = intoClause.slice(0, -1);\n\n    if (returningClause && intoClause) {\n      res.sql += ' returning ' + returningClause + ' into ' + intoClause;\n    }\n\n    res.outBinding = [outBinding];\n\n    if (returning[0] === '*') {\n      res.returningSql = function () {\n        return 'select * from ' + self.tableName + ' where ROWID = :1';\n      };\n    }\n\n    res.returning = returning;\n    return res;\n  }\n\n  _prepOutbindings(paramValues, paramReturning) {\n    const result = {};\n    let params = paramValues || [];\n    let returning = paramReturning || [];\n\n    if (!Array.isArray(params) && isPlainObject(paramValues)) {\n      params = [params];\n    } // Always wrap returning argument in array\n\n\n    if (returning && !Array.isArray(returning)) {\n      returning = [returning];\n    }\n\n    const outBinding = []; // Handle Buffer value as Blob\n\n    each(params, function (values, index) {\n      if (returning[0] === '*') {\n        outBinding[index] = ['ROWID'];\n      } else {\n        outBinding[index] = clone(returning);\n      }\n\n      each(values, function (value, key) {\n        if (value instanceof Buffer) {\n          values[key] = new BlobHelper(key, value); // Delete blob duplicate in returning\n\n          const blobIndex = outBinding[index].indexOf(key);\n\n          if (blobIndex >= 0) {\n            outBinding[index].splice(blobIndex, 1);\n            values[key].returning = true;\n          }\n\n          outBinding[index].push(values[key]);\n        }\n\n        if (value === undefined) {\n          delete params[index][key];\n        }\n      });\n    });\n    result.returning = returning;\n    result.outBinding = outBinding;\n    result.values = params;\n    return result;\n  }\n\n  update() {\n    const self = this;\n    const sql = {};\n\n    const outBindPrep = this._prepOutbindings(this.single.update || this.single.counter, this.single.returning);\n\n    const outBinding = outBindPrep.outBinding;\n    const returning = outBindPrep.returning;\n\n    const updates = this._prepUpdate(this.single.update);\n\n    const where = this.where();\n    let returningClause = '';\n    let intoClause = '';\n\n    if (isEmpty(updates) && typeof this.single.update !== 'function') {\n      return '';\n    } // Build returning and into clauses\n\n\n    outBinding.forEach(function (out) {\n      out.forEach(function (ret) {\n        const columnName = ret.columnName || ret;\n        returningClause += self.formatter.wrap(columnName) + ',';\n        intoClause += ' ?,'; // Add Helpers to bindings\n\n        if (ret instanceof BlobHelper) {\n          return self.formatter.bindings.push(ret);\n        }\n\n        self.formatter.bindings.push(new ReturningHelper(columnName));\n      });\n    }); // Strip last comma\n\n    returningClause = returningClause.slice(0, -1);\n    intoClause = intoClause.slice(0, -1);\n    sql.outBinding = outBinding;\n    sql.returning = returning;\n    sql.sql = 'update ' + this.tableName + ' set ' + updates.join(', ') + (where ? ' ' + where : '');\n\n    if (outBinding.length && !isEmpty(outBinding[0])) {\n      sql.sql += ' returning ' + returningClause + ' into' + intoClause;\n    }\n\n    if (returning[0] === '*') {\n      sql.returningSql = function () {\n        let sql = 'select * from ' + self.tableName;\n        const modifiedRowsCount = this.rowsAffected.length || this.rowsAffected;\n        let returningSqlIn = ' where ROWID in (';\n        let returningSqlOrderBy = ') order by case ROWID '; // Needs special order by because in(...) change result order\n\n        for (let i = 0; i < modifiedRowsCount; i++) {\n          if (this.returning[0] === '*') {\n            returningSqlIn += ':' + (i + 1) + ', ';\n            returningSqlOrderBy += 'when CHARTOROWID(:' + (i + 1) + ') then ' + i + ' ';\n          }\n        }\n\n        if (this.returning[0] === '*') {\n          this.returning = this.returning.slice(0, -1);\n          returningSqlIn = returningSqlIn.slice(0, -2);\n          returningSqlOrderBy = returningSqlOrderBy.slice(0, -1);\n        }\n\n        return sql += returningSqlIn + returningSqlOrderBy + ' end';\n      };\n    }\n\n    return sql;\n  }\n\n}\n\nmodule.exports = Oracledb_Compiler;","map":{"version":3,"sources":["/home/rosiane/Projeto-completo/back/node_modules/knex/lib/dialects/oracledb/query/oracledb-querycompiler.js"],"names":["clone","require","each","isEmpty","isPlainObject","Oracle_Compiler","ReturningHelper","BlobHelper","isString","Oracledb_Compiler","insert","self","outBindPrep","_prepOutbindings","single","returning","outBinding","insertValues","values","Array","isArray","length","returningFragment","formatter","wrap","_addReturningToSqlAndConvert","tableName","insertData","_prepInsert","sql","columnize","columns","client","parameterize","undefined","builder","bindingsHolder","insertDefaultsOnly","map","value","index","parameterizedValues","valueForUndefined","subSql","returningClause","intoClause","usingClause","outClause","val","slice","forEach","ret","columnName","bindings","push","positionBindings","parameterizedValuesWithoutDefaultAndBlob","replace","join","returningSql","v","i","res","returningValues","paramValues","paramReturning","result","params","key","Buffer","blobIndex","indexOf","splice","update","counter","updates","_prepUpdate","where","out","modifiedRowsCount","rowsAffected","returningSqlIn","returningSqlOrderBy","module","exports"],"mappings":"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","sourcesContent":["const clone = require('lodash/clone');\nconst each = require('lodash/each');\nconst isEmpty = require('lodash/isEmpty');\nconst isPlainObject = require('lodash/isPlainObject');\nconst Oracle_Compiler = require('../../oracle/query/oracle-querycompiler');\nconst ReturningHelper = require('../utils').ReturningHelper;\nconst BlobHelper = require('../utils').BlobHelper;\nconst { isString } = require('../../../util/is');\n\nclass Oracledb_Compiler extends Oracle_Compiler {\n  // Compiles an \"insert\" query, allowing for multiple\n  // inserts using a single query statement.\n  insert() {\n    const self = this;\n    const outBindPrep = this._prepOutbindings(\n      this.single.insert,\n      this.single.returning\n    );\n    const outBinding = outBindPrep.outBinding;\n    const returning = outBindPrep.returning;\n    const insertValues = outBindPrep.values;\n\n    if (\n      Array.isArray(insertValues) &&\n      insertValues.length === 1 &&\n      isEmpty(insertValues[0])\n    ) {\n      const returningFragment = this.single.returning\n        ? ' (' + this.formatter.wrap(this.single.returning) + ')'\n        : '';\n\n      return this._addReturningToSqlAndConvert(\n        'insert into ' +\n          this.tableName +\n          returningFragment +\n          ' values (default)',\n        outBinding[0],\n        this.tableName,\n        returning\n      );\n    }\n\n    if (\n      isEmpty(this.single.insert) &&\n      typeof this.single.insert !== 'function'\n    ) {\n      return '';\n    }\n\n    const insertData = this._prepInsert(insertValues);\n\n    const sql = {};\n\n    if (isString(insertData)) {\n      return this._addReturningToSqlAndConvert(\n        'insert into ' + this.tableName + ' ' + insertData,\n        outBinding[0],\n        this.tableName,\n        returning\n      );\n    }\n\n    if (insertData.values.length === 1) {\n      return this._addReturningToSqlAndConvert(\n        'insert into ' +\n          this.tableName +\n          ' (' +\n          this.formatter.columnize(insertData.columns) +\n          ') values (' +\n          this.client.parameterize(\n            insertData.values[0],\n            undefined,\n            this.builder,\n            this.bindingsHolder\n          ) +\n          ')',\n        outBinding[0],\n        this.tableName,\n        returning\n      );\n    }\n\n    const insertDefaultsOnly = insertData.columns.length === 0;\n    sql.returning = returning;\n    sql.sql =\n      'begin ' +\n      insertData.values\n        .map(function (value, index) {\n          const parameterizedValues = !insertDefaultsOnly\n            ? self.client.parameterize(\n                value,\n                self.client.valueForUndefined,\n                self.builder,\n                self.bindingsHolder\n              )\n            : '';\n          let subSql = 'insert into ' + self.tableName;\n\n          if (insertDefaultsOnly) {\n            // No columns given so only the default value\n            subSql +=\n              ' (' +\n              self.formatter.wrap(self.single.returning) +\n              ') values (default)';\n          } else {\n            subSql +=\n              ' (' +\n              self.formatter.columnize(insertData.columns) +\n              ') values (' +\n              parameterizedValues +\n              ')';\n          }\n\n          let returningClause = '';\n          let intoClause = '';\n          // ToDo review if this code is still needed or could be dropped\n          // eslint-disable-next-line no-unused-vars\n          let usingClause = '';\n          let outClause = '';\n\n          each(value, function (val) {\n            if (!(val instanceof BlobHelper)) {\n              usingClause += ' ?,';\n            }\n          });\n          // eslint-disable-next-line no-unused-vars\n          usingClause = usingClause.slice(0, -1);\n\n          // Build returning and into clauses\n          outBinding[index].forEach(function (ret) {\n            const columnName = ret.columnName || ret;\n            returningClause += self.formatter.wrap(columnName) + ',';\n            intoClause += ' ?,';\n            outClause += ' out ?,';\n\n            // Add Helpers to bindings\n            if (ret instanceof BlobHelper) {\n              return self.formatter.bindings.push(ret);\n            }\n            self.formatter.bindings.push(new ReturningHelper(columnName));\n          });\n\n          // Strip last comma\n          returningClause = returningClause.slice(0, -1);\n          intoClause = intoClause.slice(0, -1);\n          outClause = outClause.slice(0, -1);\n\n          if (returningClause && intoClause) {\n            subSql += ' returning ' + returningClause + ' into' + intoClause;\n          }\n\n          // Pre bind position because subSql is an execute immediate parameter\n          // later position binding will only convert the ? params\n          subSql = self.formatter.client.positionBindings(subSql);\n          const parameterizedValuesWithoutDefaultAndBlob = parameterizedValues\n            .replace('DEFAULT, ', '')\n            .replace(', DEFAULT', '')\n            .replace('EMPTY_BLOB(), ', '')\n            .replace(', EMPTY_BLOB()', '');\n          return (\n            \"execute immediate '\" +\n            subSql.replace(/'/g, \"''\") +\n            (parameterizedValuesWithoutDefaultAndBlob || value\n              ? \"' using \"\n              : '') +\n            parameterizedValuesWithoutDefaultAndBlob +\n            (parameterizedValuesWithoutDefaultAndBlob && outClause ? ',' : '') +\n            outClause +\n            ';'\n          );\n        })\n        .join(' ') +\n      'end;';\n\n    sql.outBinding = outBinding;\n    if (returning[0] === '*') {\n      // Generate select statement with special order by\n      // to keep the order because 'in (..)' may change the order\n      sql.returningSql = function () {\n        return (\n          'select * from ' +\n          self.tableName +\n          ' where ROWID in (' +\n          this.outBinding\n            .map(function (v, i) {\n              return ':' + (i + 1);\n            })\n            .join(', ') +\n          ')' +\n          ' order by case ROWID ' +\n          this.outBinding\n            .map(function (v, i) {\n              return 'when CHARTOROWID(:' + (i + 1) + ') then ' + i;\n            })\n            .join(' ') +\n          ' end'\n        );\n      };\n    }\n\n    return sql;\n  }\n\n  _addReturningToSqlAndConvert(sql, outBinding, tableName, returning) {\n    const self = this;\n    const res = {\n      sql: sql,\n    };\n\n    if (!outBinding) {\n      return res;\n    }\n    const returningValues = Array.isArray(outBinding)\n      ? outBinding\n      : [outBinding];\n    let returningClause = '';\n    let intoClause = '';\n    // Build returning and into clauses\n    returningValues.forEach(function (ret) {\n      const columnName = ret.columnName || ret;\n      returningClause += self.formatter.wrap(columnName) + ',';\n      intoClause += '?,';\n\n      // Add Helpers to bindings\n      if (ret instanceof BlobHelper) {\n        return self.formatter.bindings.push(ret);\n      }\n      self.formatter.bindings.push(new ReturningHelper(columnName));\n    });\n    res.sql = sql;\n\n    // Strip last comma\n    returningClause = returningClause.slice(0, -1);\n    intoClause = intoClause.slice(0, -1);\n    if (returningClause && intoClause) {\n      res.sql += ' returning ' + returningClause + ' into ' + intoClause;\n    }\n    res.outBinding = [outBinding];\n    if (returning[0] === '*') {\n      res.returningSql = function () {\n        return 'select * from ' + self.tableName + ' where ROWID = :1';\n      };\n    }\n    res.returning = returning;\n\n    return res;\n  }\n\n  _prepOutbindings(paramValues, paramReturning) {\n    const result = {};\n    let params = paramValues || [];\n    let returning = paramReturning || [];\n    if (!Array.isArray(params) && isPlainObject(paramValues)) {\n      params = [params];\n    }\n    // Always wrap returning argument in array\n    if (returning && !Array.isArray(returning)) {\n      returning = [returning];\n    }\n\n    const outBinding = [];\n    // Handle Buffer value as Blob\n    each(params, function (values, index) {\n      if (returning[0] === '*') {\n        outBinding[index] = ['ROWID'];\n      } else {\n        outBinding[index] = clone(returning);\n      }\n      each(values, function (value, key) {\n        if (value instanceof Buffer) {\n          values[key] = new BlobHelper(key, value);\n\n          // Delete blob duplicate in returning\n          const blobIndex = outBinding[index].indexOf(key);\n          if (blobIndex >= 0) {\n            outBinding[index].splice(blobIndex, 1);\n            values[key].returning = true;\n          }\n          outBinding[index].push(values[key]);\n        }\n        if (value === undefined) {\n          delete params[index][key];\n        }\n      });\n    });\n    result.returning = returning;\n    result.outBinding = outBinding;\n    result.values = params;\n    return result;\n  }\n\n  update() {\n    const self = this;\n    const sql = {};\n    const outBindPrep = this._prepOutbindings(\n      this.single.update || this.single.counter,\n      this.single.returning\n    );\n    const outBinding = outBindPrep.outBinding;\n    const returning = outBindPrep.returning;\n\n    const updates = this._prepUpdate(this.single.update);\n    const where = this.where();\n\n    let returningClause = '';\n    let intoClause = '';\n\n    if (isEmpty(updates) && typeof this.single.update !== 'function') {\n      return '';\n    }\n\n    // Build returning and into clauses\n    outBinding.forEach(function (out) {\n      out.forEach(function (ret) {\n        const columnName = ret.columnName || ret;\n        returningClause += self.formatter.wrap(columnName) + ',';\n        intoClause += ' ?,';\n\n        // Add Helpers to bindings\n        if (ret instanceof BlobHelper) {\n          return self.formatter.bindings.push(ret);\n        }\n        self.formatter.bindings.push(new ReturningHelper(columnName));\n      });\n    });\n    // Strip last comma\n    returningClause = returningClause.slice(0, -1);\n    intoClause = intoClause.slice(0, -1);\n\n    sql.outBinding = outBinding;\n    sql.returning = returning;\n    sql.sql =\n      'update ' +\n      this.tableName +\n      ' set ' +\n      updates.join(', ') +\n      (where ? ' ' + where : '');\n    if (outBinding.length && !isEmpty(outBinding[0])) {\n      sql.sql += ' returning ' + returningClause + ' into' + intoClause;\n    }\n    if (returning[0] === '*') {\n      sql.returningSql = function () {\n        let sql = 'select * from ' + self.tableName;\n        const modifiedRowsCount = this.rowsAffected.length || this.rowsAffected;\n        let returningSqlIn = ' where ROWID in (';\n        let returningSqlOrderBy = ') order by case ROWID ';\n\n        // Needs special order by because in(...) change result order\n        for (let i = 0; i < modifiedRowsCount; i++) {\n          if (this.returning[0] === '*') {\n            returningSqlIn += ':' + (i + 1) + ', ';\n            returningSqlOrderBy +=\n              'when CHARTOROWID(:' + (i + 1) + ') then ' + i + ' ';\n          }\n        }\n        if (this.returning[0] === '*') {\n          this.returning = this.returning.slice(0, -1);\n          returningSqlIn = returningSqlIn.slice(0, -2);\n          returningSqlOrderBy = returningSqlOrderBy.slice(0, -1);\n        }\n        return (sql += returningSqlIn + returningSqlOrderBy + ' end');\n      };\n    }\n\n    return sql;\n  }\n}\n\nmodule.exports = Oracledb_Compiler;\n"]},"metadata":{},"sourceType":"script"}