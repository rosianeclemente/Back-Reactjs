{"ast":null,"code":"const fs = require('fs');\n\nconst flatten = require('lodash/flatten');\n\nconst os = require('os');\n\nconst path = require('path');\n\nconst {\n  promisify\n} = require('util'); // Promisify common fs functions.\n\n\nconst stat = promisify(fs.stat);\nconst readFile = promisify(fs.readFile);\nconst writeFile = promisify(fs.writeFile);\nconst readdir = promisify(fs.readdir);\nconst mkdir = promisify(fs.mkdir);\n\nfunction existsSync(path) {\n  try {\n    fs.accessSync(path);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * Creates a temporary directory and returns it path.\n *\n * @returns {Promise<string>}\n */\n\n\nfunction createTemp() {\n  return promisify(fs.mkdtemp)(`${os.tmpdir()}${path.sep}`);\n}\n/**\n * Ensures the given path exists.\n *  - If the path already exist, it's fine - it does nothing.\n *  - If the path doesn't exist, it will create it.\n *\n * @param {string} path\n * @returns {Promise}\n */\n\n\nfunction ensureDirectoryExists(dir) {\n  return stat(dir).catch(() => mkdir(dir, {\n    recursive: true\n  }));\n}\n/**\n * Read a directory,\n * sorting folders and files by alphabetically order.\n * Can be browsed recursively.\n *\n * @param {string} dir\n * The directory to analyse\n *\n * @param {boolean} recursive\n * Browse directory recursively\n *\n * @returns {Promise<[string]>}\n * All found files, concatenated to the current dir\n */\n\n\nasync function getFilepathsInFolder(dir, recursive = false) {\n  const pathsList = await readdir(dir);\n  return flatten(await Promise.all(pathsList.sort().map(async currentPath => {\n    const currentFile = path.resolve(dir, currentPath);\n    const statFile = await stat(currentFile);\n\n    if (statFile && statFile.isDirectory()) {\n      if (recursive) {\n        return await getFilepathsInFolder(currentFile, true);\n      }\n\n      return [];\n    }\n\n    return [currentFile];\n  })));\n}\n\nmodule.exports = {\n  existsSync,\n  stat,\n  readdir,\n  readFile,\n  writeFile,\n  createTemp,\n  ensureDirectoryExists,\n  getFilepathsInFolder\n};","map":{"version":3,"sources":["/home/rosiane/back/node_modules/knex/lib/migrations/util/fs.js"],"names":["fs","require","flatten","os","path","promisify","stat","readFile","writeFile","readdir","mkdir","existsSync","accessSync","e","createTemp","mkdtemp","tmpdir","sep","ensureDirectoryExists","dir","catch","recursive","getFilepathsInFolder","pathsList","Promise","all","sort","map","currentPath","currentFile","resolve","statFile","isDirectory","module","exports"],"mappings":"AAAA,MAAMA,EAAE,GAAGC,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,gBAAD,CAAvB;;AACA,MAAME,EAAE,GAAGF,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAMG,IAAI,GAAGH,OAAO,CAAC,MAAD,CAApB;;AACA,MAAM;AAAEI,EAAAA;AAAF,IAAgBJ,OAAO,CAAC,MAAD,CAA7B,C,CAEA;;;AACA,MAAMK,IAAI,GAAGD,SAAS,CAACL,EAAE,CAACM,IAAJ,CAAtB;AACA,MAAMC,QAAQ,GAAGF,SAAS,CAACL,EAAE,CAACO,QAAJ,CAA1B;AACA,MAAMC,SAAS,GAAGH,SAAS,CAACL,EAAE,CAACQ,SAAJ,CAA3B;AACA,MAAMC,OAAO,GAAGJ,SAAS,CAACL,EAAE,CAACS,OAAJ,CAAzB;AACA,MAAMC,KAAK,GAAGL,SAAS,CAACL,EAAE,CAACU,KAAJ,CAAvB;;AAEA,SAASC,UAAT,CAAoBP,IAApB,EAA0B;AACxB,MAAI;AACFJ,IAAAA,EAAE,CAACY,UAAH,CAAcR,IAAd;AACA,WAAO,IAAP;AACD,GAHD,CAGE,OAAOS,CAAP,EAAU;AACV,WAAO,KAAP;AACD;AACF;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASC,UAAT,GAAsB;AACpB,SAAOT,SAAS,CAACL,EAAE,CAACe,OAAJ,CAAT,CAAuB,GAAEZ,EAAE,CAACa,MAAH,EAAY,GAAEZ,IAAI,CAACa,GAAI,EAAhD,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,qBAAT,CAA+BC,GAA/B,EAAoC;AAClC,SAAOb,IAAI,CAACa,GAAD,CAAJ,CAAUC,KAAV,CAAgB,MAAMV,KAAK,CAACS,GAAD,EAAM;AAAEE,IAAAA,SAAS,EAAE;AAAb,GAAN,CAA3B,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,eAAeC,oBAAf,CAAoCH,GAApC,EAAyCE,SAAS,GAAG,KAArD,EAA4D;AAC1D,QAAME,SAAS,GAAG,MAAMd,OAAO,CAACU,GAAD,CAA/B;AACA,SAAOjB,OAAO,CACZ,MAAMsB,OAAO,CAACC,GAAR,CACJF,SAAS,CAACG,IAAV,GAAiBC,GAAjB,CAAqB,MAAOC,WAAP,IAAuB;AAC1C,UAAMC,WAAW,GAAGzB,IAAI,CAAC0B,OAAL,CAAaX,GAAb,EAAkBS,WAAlB,CAApB;AACA,UAAMG,QAAQ,GAAG,MAAMzB,IAAI,CAACuB,WAAD,CAA3B;;AACA,QAAIE,QAAQ,IAAIA,QAAQ,CAACC,WAAT,EAAhB,EAAwC;AACtC,UAAIX,SAAJ,EAAe;AACb,eAAO,MAAMC,oBAAoB,CAACO,WAAD,EAAc,IAAd,CAAjC;AACD;;AACD,aAAO,EAAP;AACD;;AACD,WAAO,CAACA,WAAD,CAAP;AACD,GAVD,CADI,CADM,CAAd;AAeD;;AAEDI,MAAM,CAACC,OAAP,GAAiB;AACfvB,EAAAA,UADe;AAEfL,EAAAA,IAFe;AAGfG,EAAAA,OAHe;AAIfF,EAAAA,QAJe;AAKfC,EAAAA,SALe;AAMfM,EAAAA,UANe;AAOfI,EAAAA,qBAPe;AAQfI,EAAAA;AARe,CAAjB","sourcesContent":["const fs = require('fs');\nconst flatten = require('lodash/flatten');\nconst os = require('os');\nconst path = require('path');\nconst { promisify } = require('util');\n\n// Promisify common fs functions.\nconst stat = promisify(fs.stat);\nconst readFile = promisify(fs.readFile);\nconst writeFile = promisify(fs.writeFile);\nconst readdir = promisify(fs.readdir);\nconst mkdir = promisify(fs.mkdir);\n\nfunction existsSync(path) {\n  try {\n    fs.accessSync(path);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Creates a temporary directory and returns it path.\n *\n * @returns {Promise<string>}\n */\nfunction createTemp() {\n  return promisify(fs.mkdtemp)(`${os.tmpdir()}${path.sep}`);\n}\n\n/**\n * Ensures the given path exists.\n *  - If the path already exist, it's fine - it does nothing.\n *  - If the path doesn't exist, it will create it.\n *\n * @param {string} path\n * @returns {Promise}\n */\nfunction ensureDirectoryExists(dir) {\n  return stat(dir).catch(() => mkdir(dir, { recursive: true }));\n}\n\n/**\n * Read a directory,\n * sorting folders and files by alphabetically order.\n * Can be browsed recursively.\n *\n * @param {string} dir\n * The directory to analyse\n *\n * @param {boolean} recursive\n * Browse directory recursively\n *\n * @returns {Promise<[string]>}\n * All found files, concatenated to the current dir\n */\nasync function getFilepathsInFolder(dir, recursive = false) {\n  const pathsList = await readdir(dir);\n  return flatten(\n    await Promise.all(\n      pathsList.sort().map(async (currentPath) => {\n        const currentFile = path.resolve(dir, currentPath);\n        const statFile = await stat(currentFile);\n        if (statFile && statFile.isDirectory()) {\n          if (recursive) {\n            return await getFilepathsInFolder(currentFile, true);\n          }\n          return [];\n        }\n        return [currentFile];\n      })\n    )\n  );\n}\n\nmodule.exports = {\n  existsSync,\n  stat,\n  readdir,\n  readFile,\n  writeFile,\n  createTemp,\n  ensureDirectoryExists,\n  getFilepathsInFolder,\n};\n"]},"metadata":{},"sourceType":"script"}