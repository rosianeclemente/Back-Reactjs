{"ast":null,"code":"/* eslint max-len:0 */\n// Oracle Query Builder & Compiler\n// ------\nconst compact = require('lodash/compact');\n\nconst identity = require('lodash/identity');\n\nconst isEmpty = require('lodash/isEmpty');\n\nconst isPlainObject = require('lodash/isPlainObject');\n\nconst reduce = require('lodash/reduce');\n\nconst QueryCompiler = require('../../../query/querycompiler');\n\nconst {\n  ReturningHelper\n} = require('../utils');\n\nconst {\n  isString\n} = require('../../../util/is');\n\nconst components = ['columns', 'join', 'where', 'union', 'group', 'having', 'order', 'lock']; // Query Compiler\n// -------\n// Set the \"Formatter\" to use for the queries,\n// ensuring that all parameterized values (even across sub-queries)\n// are properly built into the same query.\n\nclass QueryCompiler_Oracle extends QueryCompiler {\n  constructor(client, builder, formatter) {\n    super(client, builder, formatter);\n    const {\n      onConflict\n    } = this.single;\n\n    if (onConflict) {\n      throw new Error('.onConflict() is not supported for oracledb.');\n    } // Compiles the `select` statement, or nested sub-selects\n    // by calling each of the component compilers, trimming out\n    // the empties, and returning a generated query string.\n\n\n    this.first = this.select;\n  } // Compiles an \"insert\" query, allowing for multiple\n  // inserts using a single query statement.\n\n\n  insert() {\n    let insertValues = this.single.insert || [];\n    let {\n      returning\n    } = this.single;\n\n    if (!Array.isArray(insertValues) && isPlainObject(this.single.insert)) {\n      insertValues = [this.single.insert];\n    } // always wrap returning argument in array\n\n\n    if (returning && !Array.isArray(returning)) {\n      returning = [returning];\n    }\n\n    if (Array.isArray(insertValues) && insertValues.length === 1 && isEmpty(insertValues[0])) {\n      return this._addReturningToSqlAndConvert(`insert into ${this.tableName} (${this.formatter.wrap(this.single.returning)}) values (default)`, returning, this.tableName);\n    }\n\n    if (isEmpty(this.single.insert) && typeof this.single.insert !== 'function') {\n      return '';\n    }\n\n    const insertData = this._prepInsert(insertValues);\n\n    const sql = {};\n\n    if (isString(insertData)) {\n      return this._addReturningToSqlAndConvert(`insert into ${this.tableName} ${insertData}`, returning);\n    }\n\n    if (insertData.values.length === 1) {\n      return this._addReturningToSqlAndConvert(`insert into ${this.tableName} (${this.formatter.columnize(insertData.columns)}) values (${this.client.parameterize(insertData.values[0], undefined, this.builder, this.bindingsHolder)})`, returning, this.tableName);\n    }\n\n    const insertDefaultsOnly = insertData.columns.length === 0;\n    sql.sql = 'begin ' + insertData.values.map(value => {\n      let returningHelper;\n      const parameterizedValues = !insertDefaultsOnly ? this.client.parameterize(value, this.client.valueForUndefined, this.builder, this.bindingsHolder) : '';\n      const returningValues = Array.isArray(returning) ? returning : [returning];\n      let subSql = `insert into ${this.tableName} `;\n\n      if (returning) {\n        returningHelper = new ReturningHelper(returningValues.join(':'));\n        sql.outParams = (sql.outParams || []).concat(returningHelper);\n      }\n\n      if (insertDefaultsOnly) {\n        // no columns given so only the default value\n        subSql += `(${this.formatter.wrap(this.single.returning)}) values (default)`;\n      } else {\n        subSql += `(${this.formatter.columnize(insertData.columns)}) values (${parameterizedValues})`;\n      }\n\n      subSql += returning ? ` returning ROWID into ${this.client.parameter(returningHelper, this.builder, this.bindingsHolder)}` : ''; // pre bind position because subSql is an execute immediate parameter\n      // later position binding will only convert the ? params\n\n      subSql = this.formatter.client.positionBindings(subSql);\n      const parameterizedValuesWithoutDefault = parameterizedValues.replace('DEFAULT, ', '').replace(', DEFAULT', '');\n      return `execute immediate '${subSql.replace(/'/g, \"''\")}` + (parameterizedValuesWithoutDefault || returning ? \"' using \" : '') + parameterizedValuesWithoutDefault + (parameterizedValuesWithoutDefault && returning ? ', ' : '') + (returning ? 'out ?' : '') + ';';\n    }).join(' ') + 'end;';\n\n    if (returning) {\n      sql.returning = returning; // generate select statement with special order by to keep the order because 'in (..)' may change the order\n\n      sql.returningSql = `select ${this.formatter.columnize(returning)}` + ' from ' + this.tableName + ' where ROWID in (' + sql.outParams.map((v, i) => `:${i + 1}`).join(', ') + ')' + ' order by case ROWID ' + sql.outParams.map((v, i) => `when CHARTOROWID(:${i + 1}) then ${i}`).join(' ') + ' end';\n    }\n\n    return sql;\n  } // Update method, including joins, wheres, order & limits.\n\n\n  update() {\n    const updates = this._prepUpdate(this.single.update);\n\n    const where = this.where();\n    let {\n      returning\n    } = this.single;\n    const sql = `update ${this.tableName}` + ' set ' + updates.join(', ') + (where ? ` ${where}` : '');\n\n    if (!returning) {\n      return sql;\n    } // always wrap returning argument in array\n\n\n    if (!Array.isArray(returning)) {\n      returning = [returning];\n    }\n\n    return this._addReturningToSqlAndConvert(sql, returning, this.tableName);\n  } // Compiles a `truncate` query.\n\n\n  truncate() {\n    return `truncate table ${this.tableName}`;\n  }\n\n  forUpdate() {\n    return 'for update';\n  }\n\n  forShare() {\n    // lock for share is not directly supported by oracle\n    // use LOCK TABLE .. IN SHARE MODE; instead\n    this.client.logger.warn('lock for share is not supported by oracle dialect');\n    return '';\n  } // Compiles a `columnInfo` query.\n\n\n  columnInfo() {\n    const column = this.single.columnInfo; // The user may have specified a custom wrapIdentifier function in the config. We\n    // need to run the identifiers through that function, but not format them as\n    // identifiers otherwise.\n\n    const table = this.client.customWrapIdentifier(this.single.table, identity); // Node oracle drivers doesn't support LONG type (which is data_default type)\n\n    const sql = `select * from xmltable( '/ROWSET/ROW'\n      passing dbms_xmlgen.getXMLType('\n      select char_col_decl_length, column_name, data_type, data_default, nullable\n      from all_tab_columns where table_name = ''${table}'' ')\n      columns\n      CHAR_COL_DECL_LENGTH number, COLUMN_NAME varchar2(200), DATA_TYPE varchar2(106),\n      DATA_DEFAULT clob, NULLABLE varchar2(1))`;\n    return {\n      sql: sql,\n\n      output(resp) {\n        const out = reduce(resp, function (columns, val) {\n          columns[val.COLUMN_NAME] = {\n            type: val.DATA_TYPE,\n            defaultValue: val.DATA_DEFAULT,\n            maxLength: val.CHAR_COL_DECL_LENGTH,\n            nullable: val.NULLABLE === 'Y'\n          };\n          return columns;\n        }, {});\n        return column && out[column] || out;\n      }\n\n    };\n  }\n\n  select() {\n    let query = this.with();\n    const statements = components.map(component => {\n      return this[component]();\n    });\n    query += compact(statements).join(' ');\n    return this._surroundQueryWithLimitAndOffset(query);\n  }\n\n  aggregate(stmt) {\n    return this._aggregate(stmt, {\n      aliasSeparator: ' '\n    });\n  } // for single commands only\n\n\n  _addReturningToSqlAndConvert(sql, returning, tableName) {\n    const res = {\n      sql\n    };\n\n    if (!returning) {\n      return res;\n    }\n\n    const returningValues = Array.isArray(returning) ? returning : [returning];\n    const returningHelper = new ReturningHelper(returningValues.join(':'));\n    res.sql = sql + ' returning ROWID into ' + this.client.parameter(returningHelper, this.builder, this.bindingsHolder);\n    res.returningSql = `select ${this.formatter.columnize(returning)} from ${tableName} where ROWID = :1`;\n    res.outParams = [returningHelper];\n    res.returning = returning;\n    return res;\n  }\n\n  _surroundQueryWithLimitAndOffset(query) {\n    let {\n      limit\n    } = this.single;\n    const {\n      offset\n    } = this.single;\n    const hasLimit = limit || limit === 0 || limit === '0';\n    limit = +limit;\n    if (!hasLimit && !offset) return query;\n    query = query || '';\n\n    if (hasLimit && !offset) {\n      return `select * from (${query}) where rownum <= ${this.client.parameter(limit, this.builder, this.bindingsHolder)}`;\n    }\n\n    const endRow = +offset + (hasLimit ? limit : 10000000000000);\n    return 'select * from ' + '(select row_.*, ROWNUM rownum_ from (' + query + ') row_ ' + 'where rownum <= ' + this.client.parameter(endRow, this.builder, this.bindingsHolder) + ') ' + 'where rownum_ > ' + this.client.parameter(offset, this.builder, this.bindingsHolder);\n  }\n\n}\n\nmodule.exports = QueryCompiler_Oracle;","map":{"version":3,"sources":["/home/rosiane/back/node_modules/knex/lib/dialects/oracle/query/oracle-querycompiler.js"],"names":["compact","require","identity","isEmpty","isPlainObject","reduce","QueryCompiler","ReturningHelper","isString","components","QueryCompiler_Oracle","constructor","client","builder","formatter","onConflict","single","Error","first","select","insert","insertValues","returning","Array","isArray","length","_addReturningToSqlAndConvert","tableName","wrap","insertData","_prepInsert","sql","values","columnize","columns","parameterize","undefined","bindingsHolder","insertDefaultsOnly","map","value","returningHelper","parameterizedValues","valueForUndefined","returningValues","subSql","join","outParams","concat","parameter","positionBindings","parameterizedValuesWithoutDefault","replace","returningSql","v","i","update","updates","_prepUpdate","where","truncate","forUpdate","forShare","logger","warn","columnInfo","column","table","customWrapIdentifier","output","resp","out","val","COLUMN_NAME","type","DATA_TYPE","defaultValue","DATA_DEFAULT","maxLength","CHAR_COL_DECL_LENGTH","nullable","NULLABLE","query","with","statements","component","_surroundQueryWithLimitAndOffset","aggregate","stmt","_aggregate","aliasSeparator","res","limit","offset","hasLimit","endRow","module","exports"],"mappings":"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","sourcesContent":["/* eslint max-len:0 */\n\n// Oracle Query Builder & Compiler\n// ------\nconst compact = require('lodash/compact');\nconst identity = require('lodash/identity');\nconst isEmpty = require('lodash/isEmpty');\nconst isPlainObject = require('lodash/isPlainObject');\nconst reduce = require('lodash/reduce');\nconst QueryCompiler = require('../../../query/querycompiler');\nconst { ReturningHelper } = require('../utils');\nconst { isString } = require('../../../util/is');\n\nconst components = [\n  'columns',\n  'join',\n  'where',\n  'union',\n  'group',\n  'having',\n  'order',\n  'lock',\n];\n\n// Query Compiler\n// -------\n\n// Set the \"Formatter\" to use for the queries,\n// ensuring that all parameterized values (even across sub-queries)\n// are properly built into the same query.\nclass QueryCompiler_Oracle extends QueryCompiler {\n  constructor(client, builder, formatter) {\n    super(client, builder, formatter);\n\n    const { onConflict } = this.single;\n    if (onConflict) {\n      throw new Error('.onConflict() is not supported for oracledb.');\n    }\n\n    // Compiles the `select` statement, or nested sub-selects\n    // by calling each of the component compilers, trimming out\n    // the empties, and returning a generated query string.\n    this.first = this.select;\n  }\n\n  // Compiles an \"insert\" query, allowing for multiple\n  // inserts using a single query statement.\n  insert() {\n    let insertValues = this.single.insert || [];\n    let { returning } = this.single;\n\n    if (!Array.isArray(insertValues) && isPlainObject(this.single.insert)) {\n      insertValues = [this.single.insert];\n    }\n\n    // always wrap returning argument in array\n    if (returning && !Array.isArray(returning)) {\n      returning = [returning];\n    }\n\n    if (\n      Array.isArray(insertValues) &&\n      insertValues.length === 1 &&\n      isEmpty(insertValues[0])\n    ) {\n      return this._addReturningToSqlAndConvert(\n        `insert into ${this.tableName} (${this.formatter.wrap(\n          this.single.returning\n        )}) values (default)`,\n        returning,\n        this.tableName\n      );\n    }\n\n    if (\n      isEmpty(this.single.insert) &&\n      typeof this.single.insert !== 'function'\n    ) {\n      return '';\n    }\n\n    const insertData = this._prepInsert(insertValues);\n\n    const sql = {};\n\n    if (isString(insertData)) {\n      return this._addReturningToSqlAndConvert(\n        `insert into ${this.tableName} ${insertData}`,\n        returning\n      );\n    }\n\n    if (insertData.values.length === 1) {\n      return this._addReturningToSqlAndConvert(\n        `insert into ${this.tableName} (${this.formatter.columnize(\n          insertData.columns\n        )}) values (${this.client.parameterize(\n          insertData.values[0],\n          undefined,\n          this.builder,\n          this.bindingsHolder\n        )})`,\n        returning,\n        this.tableName\n      );\n    }\n\n    const insertDefaultsOnly = insertData.columns.length === 0;\n\n    sql.sql =\n      'begin ' +\n      insertData.values\n        .map((value) => {\n          let returningHelper;\n          const parameterizedValues = !insertDefaultsOnly\n            ? this.client.parameterize(\n                value,\n                this.client.valueForUndefined,\n                this.builder,\n                this.bindingsHolder\n              )\n            : '';\n          const returningValues = Array.isArray(returning)\n            ? returning\n            : [returning];\n          let subSql = `insert into ${this.tableName} `;\n\n          if (returning) {\n            returningHelper = new ReturningHelper(returningValues.join(':'));\n            sql.outParams = (sql.outParams || []).concat(returningHelper);\n          }\n\n          if (insertDefaultsOnly) {\n            // no columns given so only the default value\n            subSql += `(${this.formatter.wrap(\n              this.single.returning\n            )}) values (default)`;\n          } else {\n            subSql += `(${this.formatter.columnize(\n              insertData.columns\n            )}) values (${parameterizedValues})`;\n          }\n          subSql += returning\n            ? ` returning ROWID into ${this.client.parameter(\n                returningHelper,\n                this.builder,\n                this.bindingsHolder\n              )}`\n            : '';\n\n          // pre bind position because subSql is an execute immediate parameter\n          // later position binding will only convert the ? params\n\n          subSql = this.formatter.client.positionBindings(subSql);\n\n          const parameterizedValuesWithoutDefault = parameterizedValues\n            .replace('DEFAULT, ', '')\n            .replace(', DEFAULT', '');\n          return (\n            `execute immediate '${subSql.replace(/'/g, \"''\")}` +\n            (parameterizedValuesWithoutDefault || returning ? \"' using \" : '') +\n            parameterizedValuesWithoutDefault +\n            (parameterizedValuesWithoutDefault && returning ? ', ' : '') +\n            (returning ? 'out ?' : '') +\n            ';'\n          );\n        })\n        .join(' ') +\n      'end;';\n\n    if (returning) {\n      sql.returning = returning;\n      // generate select statement with special order by to keep the order because 'in (..)' may change the order\n      sql.returningSql =\n        `select ${this.formatter.columnize(returning)}` +\n        ' from ' +\n        this.tableName +\n        ' where ROWID in (' +\n        sql.outParams.map((v, i) => `:${i + 1}`).join(', ') +\n        ')' +\n        ' order by case ROWID ' +\n        sql.outParams\n          .map((v, i) => `when CHARTOROWID(:${i + 1}) then ${i}`)\n          .join(' ') +\n        ' end';\n    }\n\n    return sql;\n  }\n\n  // Update method, including joins, wheres, order & limits.\n  update() {\n    const updates = this._prepUpdate(this.single.update);\n    const where = this.where();\n    let { returning } = this.single;\n    const sql =\n      `update ${this.tableName}` +\n      ' set ' +\n      updates.join(', ') +\n      (where ? ` ${where}` : '');\n\n    if (!returning) {\n      return sql;\n    }\n\n    // always wrap returning argument in array\n    if (!Array.isArray(returning)) {\n      returning = [returning];\n    }\n\n    return this._addReturningToSqlAndConvert(sql, returning, this.tableName);\n  }\n\n  // Compiles a `truncate` query.\n  truncate() {\n    return `truncate table ${this.tableName}`;\n  }\n\n  forUpdate() {\n    return 'for update';\n  }\n\n  forShare() {\n    // lock for share is not directly supported by oracle\n    // use LOCK TABLE .. IN SHARE MODE; instead\n    this.client.logger.warn(\n      'lock for share is not supported by oracle dialect'\n    );\n    return '';\n  }\n\n  // Compiles a `columnInfo` query.\n  columnInfo() {\n    const column = this.single.columnInfo;\n\n    // The user may have specified a custom wrapIdentifier function in the config. We\n    // need to run the identifiers through that function, but not format them as\n    // identifiers otherwise.\n    const table = this.client.customWrapIdentifier(this.single.table, identity);\n\n    // Node oracle drivers doesn't support LONG type (which is data_default type)\n    const sql = `select * from xmltable( '/ROWSET/ROW'\n      passing dbms_xmlgen.getXMLType('\n      select char_col_decl_length, column_name, data_type, data_default, nullable\n      from all_tab_columns where table_name = ''${table}'' ')\n      columns\n      CHAR_COL_DECL_LENGTH number, COLUMN_NAME varchar2(200), DATA_TYPE varchar2(106),\n      DATA_DEFAULT clob, NULLABLE varchar2(1))`;\n\n    return {\n      sql: sql,\n      output(resp) {\n        const out = reduce(\n          resp,\n          function (columns, val) {\n            columns[val.COLUMN_NAME] = {\n              type: val.DATA_TYPE,\n              defaultValue: val.DATA_DEFAULT,\n              maxLength: val.CHAR_COL_DECL_LENGTH,\n              nullable: val.NULLABLE === 'Y',\n            };\n            return columns;\n          },\n          {}\n        );\n        return (column && out[column]) || out;\n      },\n    };\n  }\n\n  select() {\n    let query = this.with();\n    const statements = components.map((component) => {\n      return this[component]();\n    });\n    query += compact(statements).join(' ');\n    return this._surroundQueryWithLimitAndOffset(query);\n  }\n\n  aggregate(stmt) {\n    return this._aggregate(stmt, { aliasSeparator: ' ' });\n  }\n\n  // for single commands only\n  _addReturningToSqlAndConvert(sql, returning, tableName) {\n    const res = {\n      sql,\n    };\n\n    if (!returning) {\n      return res;\n    }\n\n    const returningValues = Array.isArray(returning) ? returning : [returning];\n    const returningHelper = new ReturningHelper(returningValues.join(':'));\n    res.sql =\n      sql +\n      ' returning ROWID into ' +\n      this.client.parameter(returningHelper, this.builder, this.bindingsHolder);\n    res.returningSql = `select ${this.formatter.columnize(\n      returning\n    )} from ${tableName} where ROWID = :1`;\n    res.outParams = [returningHelper];\n    res.returning = returning;\n    return res;\n  }\n\n  _surroundQueryWithLimitAndOffset(query) {\n    let { limit } = this.single;\n    const { offset } = this.single;\n    const hasLimit = limit || limit === 0 || limit === '0';\n    limit = +limit;\n\n    if (!hasLimit && !offset) return query;\n    query = query || '';\n\n    if (hasLimit && !offset) {\n      return `select * from (${query}) where rownum <= ${this.client.parameter(\n        limit,\n        this.builder,\n        this.bindingsHolder\n      )}`;\n    }\n\n    const endRow = +offset + (hasLimit ? limit : 10000000000000);\n\n    return (\n      'select * from ' +\n      '(select row_.*, ROWNUM rownum_ from (' +\n      query +\n      ') row_ ' +\n      'where rownum <= ' +\n      this.client.parameter(endRow, this.builder, this.bindingsHolder) +\n      ') ' +\n      'where rownum_ > ' +\n      this.client.parameter(offset, this.builder, this.bindingsHolder)\n    );\n  }\n}\n\nmodule.exports = QueryCompiler_Oracle;\n"]},"metadata":{},"sourceType":"script"}