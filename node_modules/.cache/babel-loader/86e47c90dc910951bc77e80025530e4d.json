{"ast":null,"code":"// Sequence parser combinator\nfunction s(sequence, post = v => v) {\n  return function ({\n    index = 0,\n    input\n  }) {\n    let position = index;\n    const ast = [];\n\n    for (const parser of sequence) {\n      const result = parser({\n        index: position,\n        input\n      });\n\n      if (result.success) {\n        position = result.index;\n        ast.push(result.ast);\n      } else {\n        return result;\n      }\n    }\n\n    return {\n      success: true,\n      ast: post(ast),\n      index: position,\n      input\n    };\n  };\n} // Alternative parser combinator\n\n\nfunction a(alternative, post = v => v) {\n  return function ({\n    index = 0,\n    input\n  }) {\n    for (const parser of alternative) {\n      const result = parser({\n        index,\n        input\n      });\n\n      if (result.success) {\n        return {\n          success: true,\n          ast: post(result.ast),\n          index: result.index,\n          input\n        };\n      }\n    }\n\n    return {\n      success: false,\n      ast: null,\n      index,\n      input\n    };\n  };\n} // Many parser combinator\n\n\nfunction m(many, post = v => v) {\n  return function ({\n    index = 0,\n    input\n  }) {\n    let result = {};\n    let position = index;\n    const ast = [];\n\n    do {\n      result = many({\n        index: position,\n        input\n      });\n\n      if (result.success) {\n        position = result.index;\n        ast.push(result.ast);\n      }\n    } while (result.success);\n\n    if (ast.length > 0) {\n      return {\n        success: true,\n        ast: post(ast),\n        index: position,\n        input\n      };\n    } else {\n      return {\n        success: false,\n        ast: null,\n        index: position,\n        input\n      };\n    }\n  };\n} // Optional parser combinator\n\n\nfunction o(optional, post = v => v) {\n  return function ({\n    index = 0,\n    input\n  }) {\n    const result = optional({\n      index,\n      input\n    });\n\n    if (result.success) {\n      return {\n        success: true,\n        ast: post(result.ast),\n        index: result.index,\n        input\n      };\n    } else {\n      return {\n        success: true,\n        ast: post(null),\n        index,\n        input\n      };\n    }\n  };\n} // Lookahead parser combinator\n\n\nfunction l(lookahead, post = v => v) {\n  return function ({\n    index = 0,\n    input\n  }) {\n    const result = lookahead.do({\n      index,\n      input\n    });\n\n    if (result.success) {\n      const resultNext = lookahead.next({\n        index: result.index,\n        input\n      });\n\n      if (resultNext.success) {\n        return {\n          success: true,\n          ast: post(result.ast),\n          index: result.index,\n          input\n        };\n      }\n    }\n\n    return {\n      success: false,\n      ast: null,\n      index,\n      input\n    };\n  };\n} // Negative parser combinator\n\n\nfunction n(negative, post = v => v) {\n  return function ({\n    index = 0,\n    input\n  }) {\n    const result = negative.do({\n      index,\n      input\n    });\n\n    if (result.success) {\n      const resultNot = negative.not({\n        index,\n        input\n      });\n\n      if (!resultNot.success) {\n        return {\n          success: true,\n          ast: post(result.ast),\n          index: result.index,\n          input\n        };\n      }\n    }\n\n    return {\n      success: false,\n      ast: null,\n      index,\n      input\n    };\n  };\n} // Token parser combinator\n\n\nfunction t(token, post = v => v.text) {\n  return function ({\n    index = 0,\n    input\n  }) {\n    const result = input[index];\n\n    if (result !== undefined && (token.type === undefined || token.type === result.type) && (token.text === undefined || token.text.toUpperCase() === result.text.toUpperCase())) {\n      return {\n        success: true,\n        ast: post(result),\n        index: index + 1,\n        input\n      };\n    } else {\n      return {\n        success: false,\n        ast: null,\n        index,\n        input\n      };\n    }\n  };\n} // Empty parser constant\n\n\nconst e = function ({\n  index = 0,\n  input\n}) {\n  return {\n    success: true,\n    ast: null,\n    index,\n    input\n  };\n}; // Finish parser constant\n\n\nconst f = function ({\n  index = 0,\n  input\n}) {\n  return {\n    success: index === input.length,\n    ast: null,\n    index,\n    input\n  };\n};\n\nmodule.exports = {\n  s,\n  a,\n  m,\n  o,\n  l,\n  n,\n  t,\n  e,\n  f\n};","map":{"version":3,"sources":["/home/rosiane/Projeto-completo/back/node_modules/knex/lib/dialects/sqlite3/schema/internal/parser-combinator.js"],"names":["s","sequence","post","v","index","input","position","ast","parser","result","success","push","a","alternative","m","many","length","o","optional","l","lookahead","do","resultNext","next","n","negative","resultNot","not","t","token","text","undefined","type","toUpperCase","e","f","module","exports"],"mappings":"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","sourcesContent":["// Sequence parser combinator\nfunction s(sequence, post = (v) => v) {\n  return function ({ index = 0, input }) {\n    let position = index;\n    const ast = [];\n\n    for (const parser of sequence) {\n      const result = parser({ index: position, input });\n\n      if (result.success) {\n        position = result.index;\n        ast.push(result.ast);\n      } else {\n        return result;\n      }\n    }\n\n    return { success: true, ast: post(ast), index: position, input };\n  };\n}\n\n// Alternative parser combinator\nfunction a(alternative, post = (v) => v) {\n  return function ({ index = 0, input }) {\n    for (const parser of alternative) {\n      const result = parser({ index, input });\n\n      if (result.success) {\n        return {\n          success: true,\n          ast: post(result.ast),\n          index: result.index,\n          input,\n        };\n      }\n    }\n\n    return { success: false, ast: null, index, input };\n  };\n}\n\n// Many parser combinator\nfunction m(many, post = (v) => v) {\n  return function ({ index = 0, input }) {\n    let result = {};\n    let position = index;\n    const ast = [];\n\n    do {\n      result = many({ index: position, input });\n\n      if (result.success) {\n        position = result.index;\n        ast.push(result.ast);\n      }\n    } while (result.success);\n\n    if (ast.length > 0) {\n      return { success: true, ast: post(ast), index: position, input };\n    } else {\n      return { success: false, ast: null, index: position, input };\n    }\n  };\n}\n\n// Optional parser combinator\nfunction o(optional, post = (v) => v) {\n  return function ({ index = 0, input }) {\n    const result = optional({ index, input });\n\n    if (result.success) {\n      return {\n        success: true,\n        ast: post(result.ast),\n        index: result.index,\n        input,\n      };\n    } else {\n      return { success: true, ast: post(null), index, input };\n    }\n  };\n}\n\n// Lookahead parser combinator\nfunction l(lookahead, post = (v) => v) {\n  return function ({ index = 0, input }) {\n    const result = lookahead.do({ index, input });\n\n    if (result.success) {\n      const resultNext = lookahead.next({ index: result.index, input });\n\n      if (resultNext.success) {\n        return {\n          success: true,\n          ast: post(result.ast),\n          index: result.index,\n          input,\n        };\n      }\n    }\n\n    return { success: false, ast: null, index, input };\n  };\n}\n\n// Negative parser combinator\nfunction n(negative, post = (v) => v) {\n  return function ({ index = 0, input }) {\n    const result = negative.do({ index, input });\n\n    if (result.success) {\n      const resultNot = negative.not({ index, input });\n\n      if (!resultNot.success) {\n        return {\n          success: true,\n          ast: post(result.ast),\n          index: result.index,\n          input,\n        };\n      }\n    }\n\n    return { success: false, ast: null, index, input };\n  };\n}\n\n// Token parser combinator\nfunction t(token, post = (v) => v.text) {\n  return function ({ index = 0, input }) {\n    const result = input[index];\n\n    if (\n      result !== undefined &&\n      (token.type === undefined || token.type === result.type) &&\n      (token.text === undefined ||\n        token.text.toUpperCase() === result.text.toUpperCase())\n    ) {\n      return {\n        success: true,\n        ast: post(result),\n        index: index + 1,\n        input,\n      };\n    } else {\n      return { success: false, ast: null, index, input };\n    }\n  };\n}\n\n// Empty parser constant\nconst e = function ({ index = 0, input }) {\n  return { success: true, ast: null, index, input };\n};\n\n// Finish parser constant\nconst f = function ({ index = 0, input }) {\n  return { success: index === input.length, ast: null, index, input };\n};\n\nmodule.exports = { s, a, m, o, l, n, t, e, f };\n"]},"metadata":{},"sourceType":"script"}