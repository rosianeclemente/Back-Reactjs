{"ast":null,"code":"// Oracledb Client\n// -------\nconst {\n  promisify\n} = require('util');\n\nconst stream = require('stream');\n\nconst each = require('lodash/each');\n\nconst flatten = require('lodash/flatten');\n\nconst isEmpty = require('lodash/isEmpty');\n\nconst map = require('lodash/map');\n\nconst values = require('lodash/values');\n\nconst Formatter = require('../../formatter');\n\nconst QueryCompiler = require('./query/oracledb-querycompiler');\n\nconst ColumnCompiler = require('./schema/oracledb-columncompiler');\n\nconst {\n  BlobHelper,\n  ReturningHelper,\n  isConnectionError\n} = require('./utils');\n\nconst Transaction = require('./transaction');\n\nconst Client_Oracle = require('../oracle');\n\nconst {\n  isString\n} = require('../../util/is');\n\nconst {\n  outputQuery,\n  unwrapRaw\n} = require('../../formatter/wrappingFormatter');\n\nconst {\n  compileCallback\n} = require('../../formatter/formatterUtils');\n\nclass Client_Oracledb extends Client_Oracle {\n  constructor(config) {\n    super(config);\n\n    if (this.driver) {\n      process.env.UV_THREADPOOL_SIZE = process.env.UV_THREADPOOL_SIZE || 1;\n      process.env.UV_THREADPOOL_SIZE = parseInt(process.env.UV_THREADPOOL_SIZE) + this.driver.poolMax;\n    }\n  }\n\n  _driver() {\n    const client = this;\n\n    const oracledb = require('oracledb');\n\n    client.fetchAsString = [];\n\n    if (this.config.fetchAsString && Array.isArray(this.config.fetchAsString)) {\n      this.config.fetchAsString.forEach(function (type) {\n        if (!isString(type)) return;\n        type = type.toUpperCase();\n\n        if (oracledb[type]) {\n          if (type !== 'NUMBER' && type !== 'DATE' && type !== 'CLOB' && type !== 'BUFFER') {\n            this.logger.warn('Only \"date\", \"number\", \"clob\" and \"buffer\" are supported for fetchAsString');\n          }\n\n          client.fetchAsString.push(oracledb[type]);\n        }\n      });\n    }\n\n    return oracledb;\n  }\n\n  queryCompiler(builder, formatter) {\n    return new QueryCompiler(this, builder, formatter);\n  }\n\n  columnCompiler() {\n    return new ColumnCompiler(this, ...arguments);\n  }\n\n  formatter(builder) {\n    return new Formatter(this, builder);\n  }\n\n  transaction() {\n    return new Transaction(this, ...arguments);\n  }\n\n  prepBindings(bindings) {\n    return map(bindings, value => {\n      if (value instanceof BlobHelper && this.driver) {\n        return {\n          type: this.driver.BLOB,\n          dir: this.driver.BIND_OUT\n        }; // Returning helper always use ROWID as string\n      } else if (value instanceof ReturningHelper && this.driver) {\n        return {\n          type: this.driver.STRING,\n          dir: this.driver.BIND_OUT\n        };\n      } else if (typeof value === 'boolean') {\n        return value ? 1 : 0;\n      }\n\n      return value;\n    });\n  } // Checks whether a value is a function... if it is, we compile it\n  // otherwise we check whether it's a raw\n\n\n  parameter(value, builder, formatter) {\n    if (typeof value === 'function') {\n      return outputQuery(compileCallback(value, undefined, this, formatter), true, builder, this);\n    } else if (value instanceof BlobHelper) {\n      return 'EMPTY_BLOB()';\n    }\n\n    return unwrapRaw(value, true, builder, this, formatter) || '?';\n  } // Get a raw connection, called by the `pool` whenever a new\n  // connection needs to be added to the pool.\n\n\n  acquireRawConnection() {\n    const client = this;\n    const asyncConnection = new Promise(function (resolver, rejecter) {\n      // If external authentication don't have to worry about username/password and\n      // if not need to set the username and password\n      const oracleDbConfig = client.connectionSettings.externalAuth ? {\n        externalAuth: client.connectionSettings.externalAuth\n      } : {\n        user: client.connectionSettings.user,\n        password: client.connectionSettings.password\n      }; // In the case of external authentication connection string will be given\n\n      oracleDbConfig.connectString = resolveConnectString(client.connectionSettings);\n\n      if (client.connectionSettings.prefetchRowCount) {\n        oracleDbConfig.prefetchRows = client.connectionSettings.prefetchRowCount;\n      }\n\n      if (client.connectionSettings.stmtCacheSize !== undefined) {\n        oracleDbConfig.stmtCacheSize = client.connectionSettings.stmtCacheSize;\n      }\n\n      client.driver.fetchAsString = client.fetchAsString;\n      client.driver.getConnection(oracleDbConfig, function (err, connection) {\n        if (err) {\n          return rejecter(err);\n        }\n\n        connection.commitAsync = function () {\n          return new Promise((commitResolve, commitReject) => {\n            this.commit(function (err) {\n              if (err) {\n                return commitReject(err);\n              }\n\n              commitResolve();\n            });\n          });\n        };\n\n        connection.rollbackAsync = function () {\n          return new Promise((rollbackResolve, rollbackReject) => {\n            this.rollback(function (err) {\n              if (err) {\n                return rollbackReject(err);\n              }\n\n              rollbackResolve();\n            });\n          });\n        };\n\n        const fetchAsync = promisify(function (sql, bindParams, options, cb) {\n          options = options || {};\n          options.outFormat = client.driver.OUT_FORMAT_OBJECT || client.driver.OBJECT;\n\n          if (!options.outFormat) {\n            throw new Error('not found oracledb.outFormat constants');\n          }\n\n          if (options.resultSet) {\n            connection.execute(sql, bindParams || [], options, function (err, result) {\n              if (err) {\n                if (isConnectionError(err)) {\n                  connection.close().catch(function (err) {});\n                  connection.__knex__disposed = err;\n                }\n\n                return cb(err);\n              }\n\n              const fetchResult = {\n                rows: [],\n                resultSet: result.resultSet\n              };\n              const numRows = 100;\n\n              const fetchRowsFromRS = function (connection, resultSet, numRows) {\n                resultSet.getRows(numRows, function (err, rows) {\n                  if (err) {\n                    if (isConnectionError(err)) {\n                      connection.close().catch(function (err) {});\n                      connection.__knex__disposed = err;\n                    }\n\n                    resultSet.close(function () {\n                      return cb(err);\n                    });\n                  } else if (rows.length === 0) {\n                    return cb(null, fetchResult);\n                  } else if (rows.length > 0) {\n                    if (rows.length === numRows) {\n                      fetchResult.rows = fetchResult.rows.concat(rows);\n                      fetchRowsFromRS(connection, resultSet, numRows);\n                    } else {\n                      fetchResult.rows = fetchResult.rows.concat(rows);\n                      return cb(null, fetchResult);\n                    }\n                  }\n                });\n              };\n\n              fetchRowsFromRS(connection, result.resultSet, numRows);\n            });\n          } else {\n            connection.execute(sql, bindParams || [], options, function (err, result) {\n              if (err) {\n                // dispose the connection on connection error\n                if (isConnectionError(err)) {\n                  connection.close().catch(function (err) {});\n                  connection.__knex__disposed = err;\n                }\n\n                return cb(err);\n              }\n\n              return cb(null, result);\n            });\n          }\n        });\n\n        connection.executeAsync = function (sql, bindParams, options) {\n          // Read all lob\n          return fetchAsync(sql, bindParams, options).then(async results => {\n            const closeResultSet = () => {\n              return results.resultSet ? promisify(results.resultSet.close).call(results.resultSet) : Promise.resolve();\n            }; // Collect LOBs to read\n\n\n            const lobs = [];\n\n            if (results.rows) {\n              if (Array.isArray(results.rows)) {\n                for (let i = 0; i < results.rows.length; i++) {\n                  // Iterate through the rows\n                  const row = results.rows[i];\n\n                  for (const column in row) {\n                    if (row[column] instanceof stream.Readable) {\n                      lobs.push({\n                        index: i,\n                        key: column,\n                        stream: row[column]\n                      });\n                    }\n                  }\n                }\n              }\n            }\n\n            try {\n              for (const lob of lobs) {\n                // todo should be fetchAsString/fetchAsBuffer polyfill only\n                results.rows[lob.index][lob.key] = await lobProcessing(lob.stream);\n              }\n            } catch (e) {\n              await closeResultSet().catch(() => {});\n              throw e;\n            }\n\n            await closeResultSet();\n            return results;\n          });\n        };\n\n        resolver(connection);\n      });\n    });\n    return asyncConnection;\n  } // Used to explicitly close a connection, called internally by the pool\n  // when a connection times out or the pool is shutdown.\n\n\n  destroyRawConnection(connection) {\n    return connection.release();\n  } // Runs the query on the specified connection, providing the bindings\n  // and any other necessary prep work.\n\n\n  _query(connection, obj) {\n    if (!obj.sql) throw new Error('The query is empty');\n    const options = {\n      autoCommit: false\n    };\n\n    if (obj.method === 'select') {\n      options.resultSet = true;\n    }\n\n    return connection.executeAsync(obj.sql, obj.bindings, options).then(async function (response) {\n      // Flatten outBinds\n      let outBinds = flatten(response.outBinds);\n      obj.response = response.rows || [];\n      obj.rowsAffected = response.rows ? response.rows.rowsAffected : response.rowsAffected; //added for outBind parameter\n\n      if (obj.method === 'raw' && outBinds.length > 0) {\n        return {\n          response: outBinds\n        };\n      }\n\n      if (obj.method === 'update') {\n        const modifiedRowsCount = obj.rowsAffected.length || obj.rowsAffected;\n        const updatedObjOutBinding = [];\n        const updatedOutBinds = [];\n\n        const updateOutBinds = i => function (value, index) {\n          const OutBindsOffset = index * modifiedRowsCount;\n          updatedOutBinds.push(outBinds[i + OutBindsOffset]);\n        };\n\n        for (let i = 0; i < modifiedRowsCount; i++) {\n          updatedObjOutBinding.push(obj.outBinding[0]);\n          each(obj.outBinding[0], updateOutBinds(i));\n        }\n\n        outBinds = updatedOutBinds;\n        obj.outBinding = updatedObjOutBinding;\n      }\n\n      if (!obj.returning && outBinds.length === 0) {\n        if (!connection.isTransaction) {\n          await connection.commitAsync();\n        }\n\n        return obj;\n      }\n\n      const rowIds = [];\n      let offset = 0;\n\n      for (let line = 0; line < obj.outBinding.length; line++) {\n        const ret = obj.outBinding[line];\n        offset = offset + (obj.outBinding[line - 1] ? obj.outBinding[line - 1].length : 0);\n\n        for (let index = 0; index < ret.length; index++) {\n          const out = ret[index];\n          await new Promise(function (bindResolver, bindRejecter) {\n            if (out instanceof BlobHelper) {\n              const blob = outBinds[index + offset];\n\n              if (out.returning) {\n                obj.response[line] = obj.response[line] || {};\n                obj.response[line][out.columnName] = out.value;\n              }\n\n              blob.on('error', function (err) {\n                bindRejecter(err);\n              });\n              blob.on('finish', function () {\n                bindResolver();\n              });\n              blob.write(out.value);\n              blob.end();\n            } else if (obj.outBinding[line][index] === 'ROWID') {\n              rowIds.push(outBinds[index + offset]);\n              bindResolver();\n            } else {\n              obj.response[line] = obj.response[line] || {};\n              obj.response[line][out] = outBinds[index + offset];\n              bindResolver();\n            }\n          });\n        }\n      }\n\n      if (connection.isTransaction) {\n        return obj;\n      }\n\n      await connection.commitAsync();\n\n      if (obj.returningSql) {\n        const response = await connection.executeAsync(obj.returningSql(), rowIds, {\n          resultSet: true\n        });\n        obj.response = response.rows;\n      }\n\n      return obj;\n    });\n  } // Process the response as returned from the query.\n\n\n  processResponse(obj, runner) {\n    const {\n      response\n    } = obj;\n\n    if (obj.output) {\n      return obj.output.call(runner, response);\n    }\n\n    switch (obj.method) {\n      case 'select':\n        return response;\n\n      case 'first':\n        return response[0];\n\n      case 'pluck':\n        return map(response, obj.pluck);\n\n      case 'insert':\n      case 'del':\n      case 'update':\n      case 'counter':\n        if (obj.returning && !isEmpty(obj.returning)) {\n          if (obj.returning.length === 1 && obj.returning[0] !== '*') {\n            return flatten(map(response, values));\n          }\n\n          return response;\n        } else if (obj.rowsAffected !== undefined) {\n          return obj.rowsAffected;\n        } else {\n          return 1;\n        }\n\n      default:\n        return response;\n    }\n  }\n\n}\n\nClient_Oracledb.prototype.driverName = 'oracledb';\n\nfunction resolveConnectString(connectionSettings) {\n  if (connectionSettings.connectString) {\n    return connectionSettings.connectString;\n  }\n\n  if (!connectionSettings.port) {\n    return connectionSettings.host + '/' + connectionSettings.database;\n  }\n\n  return connectionSettings.host + ':' + connectionSettings.port + '/' + connectionSettings.database;\n}\n/**\n * @param stream\n * @param {'string' | 'buffer'} type\n */\n\n\nfunction readStream(stream, type) {\n  return new Promise((resolve, reject) => {\n    let data = type === 'string' ? '' : Buffer.alloc(0);\n    stream.on('error', function (err) {\n      reject(err);\n    });\n    stream.on('data', function (chunk) {\n      if (type === 'string') {\n        data += chunk;\n      } else {\n        data = Buffer.concat([data, chunk]);\n      }\n    });\n    stream.on('end', function () {\n      resolve(data);\n    });\n  });\n}\n\nconst lobProcessing = function (stream) {\n  const oracledb = require('oracledb');\n  /**\n   * @type 'string' | 'buffer'\n   */\n\n\n  let type;\n\n  if (stream.type) {\n    // v1.2-v4\n    if (stream.type === oracledb.BLOB) {\n      type = 'buffer';\n    } else if (stream.type === oracledb.CLOB) {\n      type = 'string';\n    }\n  } else if (stream.iLob) {\n    // v1\n    if (stream.iLob.type === oracledb.CLOB) {\n      type = 'string';\n    } else if (stream.iLob.type === oracledb.BLOB) {\n      type = 'buffer';\n    }\n  } else {\n    throw new Error('Unrecognized oracledb lob stream type');\n  }\n\n  if (type === 'string') {\n    stream.setEncoding('utf-8');\n  }\n\n  return readStream(stream, type);\n};\n\nmodule.exports = Client_Oracledb;","map":{"version":3,"sources":["/home/rosiane/back/node_modules/knex/lib/dialects/oracledb/index.js"],"names":["promisify","require","stream","each","flatten","isEmpty","map","values","Formatter","QueryCompiler","ColumnCompiler","BlobHelper","ReturningHelper","isConnectionError","Transaction","Client_Oracle","isString","outputQuery","unwrapRaw","compileCallback","Client_Oracledb","constructor","config","driver","process","env","UV_THREADPOOL_SIZE","parseInt","poolMax","_driver","client","oracledb","fetchAsString","Array","isArray","forEach","type","toUpperCase","logger","warn","push","queryCompiler","builder","formatter","columnCompiler","arguments","transaction","prepBindings","bindings","value","BLOB","dir","BIND_OUT","STRING","parameter","undefined","acquireRawConnection","asyncConnection","Promise","resolver","rejecter","oracleDbConfig","connectionSettings","externalAuth","user","password","connectString","resolveConnectString","prefetchRowCount","prefetchRows","stmtCacheSize","getConnection","err","connection","commitAsync","commitResolve","commitReject","commit","rollbackAsync","rollbackResolve","rollbackReject","rollback","fetchAsync","sql","bindParams","options","cb","outFormat","OUT_FORMAT_OBJECT","OBJECT","Error","resultSet","execute","result","close","catch","__knex__disposed","fetchResult","rows","numRows","fetchRowsFromRS","getRows","length","concat","executeAsync","then","results","closeResultSet","call","resolve","lobs","i","row","column","Readable","index","key","lob","lobProcessing","e","destroyRawConnection","release","_query","obj","autoCommit","method","response","outBinds","rowsAffected","modifiedRowsCount","updatedObjOutBinding","updatedOutBinds","updateOutBinds","OutBindsOffset","outBinding","returning","isTransaction","rowIds","offset","line","ret","out","bindResolver","bindRejecter","blob","columnName","on","write","end","returningSql","processResponse","runner","output","pluck","prototype","driverName","port","host","database","readStream","reject","data","Buffer","alloc","chunk","CLOB","iLob","setEncoding","module","exports"],"mappings":"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","sourcesContent":["// Oracledb Client\n// -------\nconst { promisify } = require('util');\nconst stream = require('stream');\nconst each = require('lodash/each');\nconst flatten = require('lodash/flatten');\nconst isEmpty = require('lodash/isEmpty');\nconst map = require('lodash/map');\nconst values = require('lodash/values');\n\nconst Formatter = require('../../formatter');\nconst QueryCompiler = require('./query/oracledb-querycompiler');\nconst ColumnCompiler = require('./schema/oracledb-columncompiler');\nconst { BlobHelper, ReturningHelper, isConnectionError } = require('./utils');\nconst Transaction = require('./transaction');\nconst Client_Oracle = require('../oracle');\nconst { isString } = require('../../util/is');\nconst { outputQuery, unwrapRaw } = require('../../formatter/wrappingFormatter');\nconst { compileCallback } = require('../../formatter/formatterUtils');\n\nclass Client_Oracledb extends Client_Oracle {\n  constructor(config) {\n    super(config);\n    if (this.driver) {\n      process.env.UV_THREADPOOL_SIZE = process.env.UV_THREADPOOL_SIZE || 1;\n      process.env.UV_THREADPOOL_SIZE =\n        parseInt(process.env.UV_THREADPOOL_SIZE) + this.driver.poolMax;\n    }\n  }\n\n  _driver() {\n    const client = this;\n    const oracledb = require('oracledb');\n    client.fetchAsString = [];\n    if (this.config.fetchAsString && Array.isArray(this.config.fetchAsString)) {\n      this.config.fetchAsString.forEach(function (type) {\n        if (!isString(type)) return;\n        type = type.toUpperCase();\n        if (oracledb[type]) {\n          if (\n            type !== 'NUMBER' &&\n            type !== 'DATE' &&\n            type !== 'CLOB' &&\n            type !== 'BUFFER'\n          ) {\n            this.logger.warn(\n              'Only \"date\", \"number\", \"clob\" and \"buffer\" are supported for fetchAsString'\n            );\n          }\n          client.fetchAsString.push(oracledb[type]);\n        }\n      });\n    }\n    return oracledb;\n  }\n\n  queryCompiler(builder, formatter) {\n    return new QueryCompiler(this, builder, formatter);\n  }\n\n  columnCompiler() {\n    return new ColumnCompiler(this, ...arguments);\n  }\n\n  formatter(builder) {\n    return new Formatter(this, builder);\n  }\n\n  transaction() {\n    return new Transaction(this, ...arguments);\n  }\n\n  prepBindings(bindings) {\n    return map(bindings, (value) => {\n      if (value instanceof BlobHelper && this.driver) {\n        return { type: this.driver.BLOB, dir: this.driver.BIND_OUT };\n        // Returning helper always use ROWID as string\n      } else if (value instanceof ReturningHelper && this.driver) {\n        return { type: this.driver.STRING, dir: this.driver.BIND_OUT };\n      } else if (typeof value === 'boolean') {\n        return value ? 1 : 0;\n      }\n      return value;\n    });\n  }\n\n  // Checks whether a value is a function... if it is, we compile it\n  // otherwise we check whether it's a raw\n  parameter(value, builder, formatter) {\n    if (typeof value === 'function') {\n      return outputQuery(\n        compileCallback(value, undefined, this, formatter),\n        true,\n        builder,\n        this\n      );\n    } else if (value instanceof BlobHelper) {\n      return 'EMPTY_BLOB()';\n    }\n    return unwrapRaw(value, true, builder, this, formatter) || '?';\n  }\n\n  // Get a raw connection, called by the `pool` whenever a new\n  // connection needs to be added to the pool.\n  acquireRawConnection() {\n    const client = this;\n    const asyncConnection = new Promise(function (resolver, rejecter) {\n      // If external authentication don't have to worry about username/password and\n      // if not need to set the username and password\n      const oracleDbConfig = client.connectionSettings.externalAuth\n        ? { externalAuth: client.connectionSettings.externalAuth }\n        : {\n            user: client.connectionSettings.user,\n            password: client.connectionSettings.password,\n          };\n\n      // In the case of external authentication connection string will be given\n      oracleDbConfig.connectString = resolveConnectString(\n        client.connectionSettings\n      );\n\n      if (client.connectionSettings.prefetchRowCount) {\n        oracleDbConfig.prefetchRows =\n          client.connectionSettings.prefetchRowCount;\n      }\n\n      if (client.connectionSettings.stmtCacheSize !== undefined) {\n        oracleDbConfig.stmtCacheSize = client.connectionSettings.stmtCacheSize;\n      }\n\n      client.driver.fetchAsString = client.fetchAsString;\n\n      client.driver.getConnection(oracleDbConfig, function (err, connection) {\n        if (err) {\n          return rejecter(err);\n        }\n        connection.commitAsync = function () {\n          return new Promise((commitResolve, commitReject) => {\n            this.commit(function (err) {\n              if (err) {\n                return commitReject(err);\n              }\n              commitResolve();\n            });\n          });\n        };\n        connection.rollbackAsync = function () {\n          return new Promise((rollbackResolve, rollbackReject) => {\n            this.rollback(function (err) {\n              if (err) {\n                return rollbackReject(err);\n              }\n              rollbackResolve();\n            });\n          });\n        };\n        const fetchAsync = promisify(function (sql, bindParams, options, cb) {\n          options = options || {};\n          options.outFormat =\n            client.driver.OUT_FORMAT_OBJECT || client.driver.OBJECT;\n          if (!options.outFormat) {\n            throw new Error('not found oracledb.outFormat constants');\n          }\n          if (options.resultSet) {\n            connection.execute(\n              sql,\n              bindParams || [],\n              options,\n              function (err, result) {\n                if (err) {\n                  if (isConnectionError(err)) {\n                    connection.close().catch(function (err) {});\n                    connection.__knex__disposed = err;\n                  }\n                  return cb(err);\n                }\n                const fetchResult = { rows: [], resultSet: result.resultSet };\n                const numRows = 100;\n                const fetchRowsFromRS = function (\n                  connection,\n                  resultSet,\n                  numRows\n                ) {\n                  resultSet.getRows(numRows, function (err, rows) {\n                    if (err) {\n                      if (isConnectionError(err)) {\n                        connection.close().catch(function (err) {});\n                        connection.__knex__disposed = err;\n                      }\n                      resultSet.close(function () {\n                        return cb(err);\n                      });\n                    } else if (rows.length === 0) {\n                      return cb(null, fetchResult);\n                    } else if (rows.length > 0) {\n                      if (rows.length === numRows) {\n                        fetchResult.rows = fetchResult.rows.concat(rows);\n                        fetchRowsFromRS(connection, resultSet, numRows);\n                      } else {\n                        fetchResult.rows = fetchResult.rows.concat(rows);\n                        return cb(null, fetchResult);\n                      }\n                    }\n                  });\n                };\n                fetchRowsFromRS(connection, result.resultSet, numRows);\n              }\n            );\n          } else {\n            connection.execute(\n              sql,\n              bindParams || [],\n              options,\n              function (err, result) {\n                if (err) {\n                  // dispose the connection on connection error\n                  if (isConnectionError(err)) {\n                    connection.close().catch(function (err) {});\n                    connection.__knex__disposed = err;\n                  }\n                  return cb(err);\n                }\n\n                return cb(null, result);\n              }\n            );\n          }\n        });\n        connection.executeAsync = function (sql, bindParams, options) {\n          // Read all lob\n          return fetchAsync(sql, bindParams, options).then(async (results) => {\n            const closeResultSet = () => {\n              return results.resultSet\n                ? promisify(results.resultSet.close).call(results.resultSet)\n                : Promise.resolve();\n            };\n\n            // Collect LOBs to read\n            const lobs = [];\n            if (results.rows) {\n              if (Array.isArray(results.rows)) {\n                for (let i = 0; i < results.rows.length; i++) {\n                  // Iterate through the rows\n                  const row = results.rows[i];\n                  for (const column in row) {\n                    if (row[column] instanceof stream.Readable) {\n                      lobs.push({ index: i, key: column, stream: row[column] });\n                    }\n                  }\n                }\n              }\n            }\n\n            try {\n              for (const lob of lobs) {\n                // todo should be fetchAsString/fetchAsBuffer polyfill only\n                results.rows[lob.index][lob.key] = await lobProcessing(\n                  lob.stream\n                );\n              }\n            } catch (e) {\n              await closeResultSet().catch(() => {});\n\n              throw e;\n            }\n\n            await closeResultSet();\n\n            return results;\n          });\n        };\n        resolver(connection);\n      });\n    });\n    return asyncConnection;\n  }\n\n  // Used to explicitly close a connection, called internally by the pool\n  // when a connection times out or the pool is shutdown.\n  destroyRawConnection(connection) {\n    return connection.release();\n  }\n\n  // Runs the query on the specified connection, providing the bindings\n  // and any other necessary prep work.\n  _query(connection, obj) {\n    if (!obj.sql) throw new Error('The query is empty');\n\n    const options = { autoCommit: false };\n    if (obj.method === 'select') {\n      options.resultSet = true;\n    }\n    return connection\n      .executeAsync(obj.sql, obj.bindings, options)\n      .then(async function (response) {\n        // Flatten outBinds\n        let outBinds = flatten(response.outBinds);\n        obj.response = response.rows || [];\n        obj.rowsAffected = response.rows\n          ? response.rows.rowsAffected\n          : response.rowsAffected;\n\n        //added for outBind parameter\n        if (obj.method === 'raw' && outBinds.length > 0) {\n          return {\n            response: outBinds,\n          };\n        }\n\n        if (obj.method === 'update') {\n          const modifiedRowsCount = obj.rowsAffected.length || obj.rowsAffected;\n          const updatedObjOutBinding = [];\n          const updatedOutBinds = [];\n          const updateOutBinds = (i) =>\n            function (value, index) {\n              const OutBindsOffset = index * modifiedRowsCount;\n              updatedOutBinds.push(outBinds[i + OutBindsOffset]);\n            };\n\n          for (let i = 0; i < modifiedRowsCount; i++) {\n            updatedObjOutBinding.push(obj.outBinding[0]);\n            each(obj.outBinding[0], updateOutBinds(i));\n          }\n          outBinds = updatedOutBinds;\n          obj.outBinding = updatedObjOutBinding;\n        }\n\n        if (!obj.returning && outBinds.length === 0) {\n          if (!connection.isTransaction) {\n            await connection.commitAsync();\n          }\n          return obj;\n        }\n        const rowIds = [];\n        let offset = 0;\n\n        for (let line = 0; line < obj.outBinding.length; line++) {\n          const ret = obj.outBinding[line];\n\n          offset =\n            offset +\n            (obj.outBinding[line - 1] ? obj.outBinding[line - 1].length : 0);\n\n          for (let index = 0; index < ret.length; index++) {\n            const out = ret[index];\n\n            await new Promise(function (bindResolver, bindRejecter) {\n              if (out instanceof BlobHelper) {\n                const blob = outBinds[index + offset];\n                if (out.returning) {\n                  obj.response[line] = obj.response[line] || {};\n                  obj.response[line][out.columnName] = out.value;\n                }\n                blob.on('error', function (err) {\n                  bindRejecter(err);\n                });\n                blob.on('finish', function () {\n                  bindResolver();\n                });\n                blob.write(out.value);\n                blob.end();\n              } else if (obj.outBinding[line][index] === 'ROWID') {\n                rowIds.push(outBinds[index + offset]);\n                bindResolver();\n              } else {\n                obj.response[line] = obj.response[line] || {};\n                obj.response[line][out] = outBinds[index + offset];\n                bindResolver();\n              }\n            });\n          }\n        }\n        if (connection.isTransaction) {\n          return obj;\n        }\n        await connection.commitAsync();\n        if (obj.returningSql) {\n          const response = await connection.executeAsync(\n            obj.returningSql(),\n            rowIds,\n            { resultSet: true }\n          );\n          obj.response = response.rows;\n        }\n        return obj;\n      });\n  }\n\n  // Process the response as returned from the query.\n  processResponse(obj, runner) {\n    const { response } = obj;\n    if (obj.output) {\n      return obj.output.call(runner, response);\n    }\n    switch (obj.method) {\n      case 'select':\n        return response;\n      case 'first':\n        return response[0];\n      case 'pluck':\n        return map(response, obj.pluck);\n      case 'insert':\n      case 'del':\n      case 'update':\n      case 'counter':\n        if (obj.returning && !isEmpty(obj.returning)) {\n          if (obj.returning.length === 1 && obj.returning[0] !== '*') {\n            return flatten(map(response, values));\n          }\n          return response;\n        } else if (obj.rowsAffected !== undefined) {\n          return obj.rowsAffected;\n        } else {\n          return 1;\n        }\n      default:\n        return response;\n    }\n  }\n}\n\nClient_Oracledb.prototype.driverName = 'oracledb';\n\nfunction resolveConnectString(connectionSettings) {\n  if (connectionSettings.connectString) {\n    return connectionSettings.connectString;\n  }\n\n  if (!connectionSettings.port) {\n    return connectionSettings.host + '/' + connectionSettings.database;\n  }\n\n  return (\n    connectionSettings.host +\n    ':' +\n    connectionSettings.port +\n    '/' +\n    connectionSettings.database\n  );\n}\n\n/**\n * @param stream\n * @param {'string' | 'buffer'} type\n */\nfunction readStream(stream, type) {\n  return new Promise((resolve, reject) => {\n    let data = type === 'string' ? '' : Buffer.alloc(0);\n\n    stream.on('error', function (err) {\n      reject(err);\n    });\n    stream.on('data', function (chunk) {\n      if (type === 'string') {\n        data += chunk;\n      } else {\n        data = Buffer.concat([data, chunk]);\n      }\n    });\n    stream.on('end', function () {\n      resolve(data);\n    });\n  });\n}\n\nconst lobProcessing = function (stream) {\n  const oracledb = require('oracledb');\n\n  /**\n   * @type 'string' | 'buffer'\n   */\n  let type;\n\n  if (stream.type) {\n    // v1.2-v4\n    if (stream.type === oracledb.BLOB) {\n      type = 'buffer';\n    } else if (stream.type === oracledb.CLOB) {\n      type = 'string';\n    }\n  } else if (stream.iLob) {\n    // v1\n    if (stream.iLob.type === oracledb.CLOB) {\n      type = 'string';\n    } else if (stream.iLob.type === oracledb.BLOB) {\n      type = 'buffer';\n    }\n  } else {\n    throw new Error('Unrecognized oracledb lob stream type');\n  }\n  if (type === 'string') {\n    stream.setEncoding('utf-8');\n  }\n  return readStream(stream, type);\n};\n\nmodule.exports = Client_Oracledb;\n"]},"metadata":{},"sourceType":"script"}