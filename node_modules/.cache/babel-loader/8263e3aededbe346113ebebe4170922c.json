{"ast":null,"code":"const {\n  parse\n} = require('pg-connection-string');\n\nconst parsePG = parse;\nconst isWindows = process && process.platform && process.platform === 'win32';\n/**\n * @param str\n * @returns {URL}\n */\n\nfunction tryParse(str) {\n  try {\n    return new URL(str);\n  } catch (e) {\n    return null;\n  }\n}\n\nmodule.exports = function parseConnectionString(str) {\n  const parsed = tryParse(str);\n  const isDriveLetter = isWindows && parsed && parsed.protocol.length === 2;\n\n  if (!parsed || isDriveLetter) {\n    return {\n      client: 'sqlite3',\n      connection: {\n        filename: str\n      }\n    };\n  }\n\n  let {\n    protocol\n  } = parsed;\n\n  if (protocol.slice(-1) === ':') {\n    protocol = protocol.slice(0, -1);\n  }\n\n  const isPG = ['postgresql', 'postgres'].includes(protocol);\n  return {\n    client: protocol,\n    connection: isPG ? parsePG(str) : connectionObject(parsed)\n  };\n};\n/**\n * @param {URL} parsed\n * @returns {{}}\n */\n\n\nfunction connectionObject(parsed) {\n  const connection = {};\n  let db = parsed.pathname;\n\n  if (db[0] === '/') {\n    db = db.slice(1);\n  }\n\n  connection.database = db;\n\n  if (parsed.hostname) {\n    if (parsed.protocol.indexOf('mssql') === 0) {\n      connection.server = parsed.hostname;\n    } else {\n      connection.host = parsed.hostname;\n    }\n  }\n\n  if (parsed.port) {\n    connection.port = parsed.port;\n  }\n\n  if (parsed.username || parsed.password) {\n    connection.user = decodeURIComponent(parsed.username);\n  }\n\n  if (parsed.password) {\n    connection.password = decodeURIComponent(parsed.password);\n  }\n\n  if (parsed.searchParams) {\n    for (const [key, value] of parsed.searchParams.entries()) {\n      connection[key] = value;\n    }\n  }\n\n  return connection;\n}","map":{"version":3,"sources":["/home/rosiane/Projeto-completo/back/node_modules/knex/lib/knex-builder/internal/parse-connection.js"],"names":["parse","require","parsePG","isWindows","process","platform","tryParse","str","URL","e","module","exports","parseConnectionString","parsed","isDriveLetter","protocol","length","client","connection","filename","slice","isPG","includes","connectionObject","db","pathname","database","hostname","indexOf","server","host","port","username","password","user","decodeURIComponent","searchParams","key","value","entries"],"mappings":"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","sourcesContent":["const { parse } = require('pg-connection-string');\nconst parsePG = parse;\nconst isWindows = process && process.platform && process.platform === 'win32';\n\n/**\n * @param str\n * @returns {URL}\n */\nfunction tryParse(str) {\n  try {\n    return new URL(str);\n  } catch (e) {\n    return null;\n  }\n}\n\nmodule.exports = function parseConnectionString(str) {\n  const parsed = tryParse(str);\n  const isDriveLetter = isWindows && parsed && parsed.protocol.length === 2;\n  if (!parsed || isDriveLetter) {\n    return {\n      client: 'sqlite3',\n      connection: {\n        filename: str,\n      },\n    };\n  }\n  let { protocol } = parsed;\n  if (protocol.slice(-1) === ':') {\n    protocol = protocol.slice(0, -1);\n  }\n\n  const isPG = ['postgresql', 'postgres'].includes(protocol);\n\n  return {\n    client: protocol,\n    connection: isPG ? parsePG(str) : connectionObject(parsed),\n  };\n};\n\n/**\n * @param {URL} parsed\n * @returns {{}}\n */\nfunction connectionObject(parsed) {\n  const connection = {};\n  let db = parsed.pathname;\n  if (db[0] === '/') {\n    db = db.slice(1);\n  }\n\n  connection.database = db;\n\n  if (parsed.hostname) {\n    if (parsed.protocol.indexOf('mssql') === 0) {\n      connection.server = parsed.hostname;\n    } else {\n      connection.host = parsed.hostname;\n    }\n  }\n  if (parsed.port) {\n    connection.port = parsed.port;\n  }\n  if (parsed.username || parsed.password) {\n    connection.user = decodeURIComponent(parsed.username);\n  }\n  if (parsed.password) {\n    connection.password = decodeURIComponent(parsed.password);\n  }\n  if (parsed.searchParams) {\n    for (const [key, value] of parsed.searchParams.entries()) {\n      connection[key] = value;\n    }\n  }\n  return connection;\n}\n"]},"metadata":{},"sourceType":"script"}