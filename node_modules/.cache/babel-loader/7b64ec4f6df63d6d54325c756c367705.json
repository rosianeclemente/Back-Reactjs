{"ast":null,"code":"// Seeder\n// -------\nconst path = require('path');\n\nconst flatten = require('lodash/flatten');\n\nconst extend = require('lodash/extend');\n\nconst includes = require('lodash/includes');\n\nconst {\n  ensureDirectoryExists,\n  getFilepathsInFolder\n} = require('../util/fs');\n\nconst {\n  writeJsFileUsingTemplate\n} = require('../util/template');\n\nconst {\n  yyyymmddhhmmss\n} = require('../util/timestamp');\n\nconst filterByLoadExtensions = extensions => value => {\n  const extension = path.extname(value);\n  return includes(extensions, extension);\n}; // The new seeds we're performing, typically called from the `knex.seed`\n// interface on the main `knex` object. Passes the `knex` instance performing\n// the seeds.\n\n\nclass Seeder {\n  constructor(knex) {\n    this.knex = knex;\n    this.config = this.setConfig(knex.client.config.seeds);\n  } // Runs seed files for the given environment.\n\n\n  async run(config) {\n    this.config = this.setConfig(config);\n    let files = await this._listAll();\n\n    if (config && config.specific) {\n      files = files.filter(file => path.basename(file) === config.specific);\n\n      if (files.length === 0) {\n        throw new Error(`Invalid argument provided: the specific seed \"${config.specific}\" does not exist.`);\n      }\n    }\n\n    return this._runSeeds(files);\n  } // Creates a new seed file, with a given name.\n\n\n  async make(name, config) {\n    this.config = this.setConfig(config);\n    if (!name) throw new Error('A name must be specified for the generated seed');\n    await this._ensureFolder(config);\n    const seedPath = await this._writeNewSeed(name);\n    return seedPath;\n  } // Lists all available seed files as a sorted array.\n\n\n  async _listAll(config) {\n    this.config = this.setConfig(config);\n    const {\n      loadExtensions,\n      recursive\n    } = this.config;\n    const seeds = flatten(await Promise.all(this._absoluteConfigDirs().map(d => getFilepathsInFolder(d, recursive)))); // if true, each dir are already sorted\n    // (getFilepathsInFolderRecursively does this)\n    // if false, we need to sort all the seeds\n\n    if (this.config.sortDirsSeparately) {\n      return seeds.filter(filterByLoadExtensions(loadExtensions));\n    } else {\n      return seeds.filter(filterByLoadExtensions(loadExtensions)).sort();\n    }\n  } // Ensures a folder for the seeds exist, dependent on the\n  // seed config settings.\n\n\n  _ensureFolder() {\n    const dirs = this._absoluteConfigDirs();\n\n    const promises = dirs.map(ensureDirectoryExists);\n    return Promise.all(promises);\n  } // Run seed files, in sequence.\n\n\n  _runSeeds(seeds) {\n    seeds.forEach(seed => this._validateSeedStructure(seed));\n    return this._waterfallBatch(seeds);\n  } // Validates seed files by requiring and checking for a `seed` function.\n\n\n  async _validateSeedStructure(filepath) {\n    const importFile = require('../util/import-file'); // late import\n\n\n    const seed = await importFile(filepath);\n\n    if (typeof seed.seed !== 'function') {\n      throw new Error(`Invalid seed file: ${filepath} must have a seed function`);\n    }\n\n    return filepath;\n  }\n\n  _getStubPath() {\n    return this.config.stub || path.join(__dirname, 'stub', this.config.extension + '.stub');\n  }\n\n  _getNewStubFileName(name) {\n    if (name[0] === '-') name = name.slice(1);\n\n    if (this.config.timestampFilenamePrefix === true) {\n      name = `${yyyymmddhhmmss()}_${name}`;\n    }\n\n    return `${name}.${this.config.extension}`;\n  }\n\n  _getNewStubFilePath(name) {\n    const fileName = this._getNewStubFileName(name);\n\n    const dirs = this._absoluteConfigDirs();\n\n    const dir = dirs.slice(-1)[0]; // Get last specified directory\n\n    return path.join(dir, fileName);\n  } // Write a new seed to disk, using the config and generated filename,\n  // passing any `variables` given in the config to the template.\n\n\n  async _writeNewSeed(name) {\n    const seedPath = this._getNewStubFilePath(name);\n\n    await writeJsFileUsingTemplate(seedPath, this._getStubPath(), {\n      variable: 'd'\n    }, this.config.variables || {});\n    return seedPath;\n  } // Runs a batch of seed files.\n\n\n  async _waterfallBatch(seeds) {\n    const {\n      knex\n    } = this;\n    const log = [];\n\n    for (const seedPath of seeds) {\n      const importFile = require('../util/import-file'); // late import\n\n\n      const seed = await importFile(seedPath);\n\n      try {\n        await seed.seed(knex);\n        log.push(seedPath);\n      } catch (originalError) {\n        const error = new Error(`Error while executing \"${seedPath}\" seed: ${originalError.message}`);\n        error.original = originalError;\n        error.stack = error.stack.split('\\n').slice(0, 2).join('\\n') + '\\n' + originalError.stack;\n        throw error;\n      }\n    }\n\n    return [log];\n  }\n  /**\n   * Return all the config directories\n   * @returns {string[]}\n   */\n\n\n  _absoluteConfigDirs() {\n    const directories = Array.isArray(this.config.directory) ? this.config.directory : [this.config.directory];\n    return directories.map(directory => {\n      if (!directory) {\n        console.warn('Failed to resolve config file, knex cannot determine where to run or make seeds');\n      }\n\n      return path.resolve(process.cwd(), directory);\n    });\n  }\n\n  setConfig(config) {\n    return extend({\n      extension: 'js',\n      directory: './seeds',\n      loadExtensions: ['.co', '.coffee', '.eg', '.iced', '.js', '.litcoffee', '.ls', '.ts', '.cjs'],\n      timestampFilenamePrefix: false,\n      sortDirsSeparately: false,\n      recursive: false\n    }, this.config || {}, config);\n  }\n\n}\n\nmodule.exports = Seeder;","map":{"version":3,"sources":["/home/rosiane/back/node_modules/knex/lib/migrations/seed/Seeder.js"],"names":["path","require","flatten","extend","includes","ensureDirectoryExists","getFilepathsInFolder","writeJsFileUsingTemplate","yyyymmddhhmmss","filterByLoadExtensions","extensions","value","extension","extname","Seeder","constructor","knex","config","setConfig","client","seeds","run","files","_listAll","specific","filter","file","basename","length","Error","_runSeeds","make","name","_ensureFolder","seedPath","_writeNewSeed","loadExtensions","recursive","Promise","all","_absoluteConfigDirs","map","d","sortDirsSeparately","sort","dirs","promises","forEach","seed","_validateSeedStructure","_waterfallBatch","filepath","importFile","_getStubPath","stub","join","__dirname","_getNewStubFileName","slice","timestampFilenamePrefix","_getNewStubFilePath","fileName","dir","variable","variables","log","push","originalError","error","message","original","stack","split","directories","Array","isArray","directory","console","warn","resolve","process","cwd","module","exports"],"mappings":"AAAA;AACA;AAEA,MAAMA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,gBAAD,CAAvB;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,eAAD,CAAtB;;AACA,MAAMG,QAAQ,GAAGH,OAAO,CAAC,iBAAD,CAAxB;;AACA,MAAM;AAAEI,EAAAA,qBAAF;AAAyBC,EAAAA;AAAzB,IAAkDL,OAAO,CAAC,YAAD,CAA/D;;AACA,MAAM;AAAEM,EAAAA;AAAF,IAA+BN,OAAO,CAAC,kBAAD,CAA5C;;AACA,MAAM;AAAEO,EAAAA;AAAF,IAAqBP,OAAO,CAAC,mBAAD,CAAlC;;AAEA,MAAMQ,sBAAsB,GAAIC,UAAD,IAAiBC,KAAD,IAAW;AACxD,QAAMC,SAAS,GAAGZ,IAAI,CAACa,OAAL,CAAaF,KAAb,CAAlB;AACA,SAAOP,QAAQ,CAACM,UAAD,EAAaE,SAAb,CAAf;AACD,CAHD,C,CAKA;AACA;AACA;;;AACA,MAAME,MAAN,CAAa;AACXC,EAAAA,WAAW,CAACC,IAAD,EAAO;AAChB,SAAKA,IAAL,GAAYA,IAAZ;AACA,SAAKC,MAAL,GAAc,KAAKC,SAAL,CAAeF,IAAI,CAACG,MAAL,CAAYF,MAAZ,CAAmBG,KAAlC,CAAd;AACD,GAJU,CAMX;;;AACS,QAAHC,GAAG,CAACJ,MAAD,EAAS;AAChB,SAAKA,MAAL,GAAc,KAAKC,SAAL,CAAeD,MAAf,CAAd;AACA,QAAIK,KAAK,GAAG,MAAM,KAAKC,QAAL,EAAlB;;AACA,QAAIN,MAAM,IAAIA,MAAM,CAACO,QAArB,EAA+B;AAC7BF,MAAAA,KAAK,GAAGA,KAAK,CAACG,MAAN,CAAcC,IAAD,IAAU1B,IAAI,CAAC2B,QAAL,CAAcD,IAAd,MAAwBT,MAAM,CAACO,QAAtD,CAAR;;AACA,UAAIF,KAAK,CAACM,MAAN,KAAiB,CAArB,EAAwB;AACtB,cAAM,IAAIC,KAAJ,CACH,iDAAgDZ,MAAM,CAACO,QAAS,mBAD7D,CAAN;AAGD;AACF;;AACD,WAAO,KAAKM,SAAL,CAAeR,KAAf,CAAP;AACD,GAnBU,CAqBX;;;AACU,QAAJS,IAAI,CAACC,IAAD,EAAOf,MAAP,EAAe;AACvB,SAAKA,MAAL,GAAc,KAAKC,SAAL,CAAeD,MAAf,CAAd;AACA,QAAI,CAACe,IAAL,EACE,MAAM,IAAIH,KAAJ,CAAU,iDAAV,CAAN;AACF,UAAM,KAAKI,aAAL,CAAmBhB,MAAnB,CAAN;AACA,UAAMiB,QAAQ,GAAG,MAAM,KAAKC,aAAL,CAAmBH,IAAnB,CAAvB;AACA,WAAOE,QAAP;AACD,GA7BU,CA+BX;;;AACc,QAARX,QAAQ,CAACN,MAAD,EAAS;AACrB,SAAKA,MAAL,GAAc,KAAKC,SAAL,CAAeD,MAAf,CAAd;AACA,UAAM;AAAEmB,MAAAA,cAAF;AAAkBC,MAAAA;AAAlB,QAAgC,KAAKpB,MAA3C;AACA,UAAMG,KAAK,GAAGlB,OAAO,CACnB,MAAMoC,OAAO,CAACC,GAAR,CACJ,KAAKC,mBAAL,GAA2BC,GAA3B,CAAgCC,CAAD,IAC7BpC,oBAAoB,CAACoC,CAAD,EAAIL,SAAJ,CADtB,CADI,CADa,CAArB,CAHqB,CAUrB;AACA;AACA;;AACA,QAAI,KAAKpB,MAAL,CAAY0B,kBAAhB,EAAoC;AAClC,aAAOvB,KAAK,CAACK,MAAN,CAAahB,sBAAsB,CAAC2B,cAAD,CAAnC,CAAP;AACD,KAFD,MAEO;AACL,aAAOhB,KAAK,CAACK,MAAN,CAAahB,sBAAsB,CAAC2B,cAAD,CAAnC,EAAqDQ,IAArD,EAAP;AACD;AACF,GAlDU,CAoDX;AACA;;;AACAX,EAAAA,aAAa,GAAG;AACd,UAAMY,IAAI,GAAG,KAAKL,mBAAL,EAAb;;AACA,UAAMM,QAAQ,GAAGD,IAAI,CAACJ,GAAL,CAASpC,qBAAT,CAAjB;AACA,WAAOiC,OAAO,CAACC,GAAR,CAAYO,QAAZ,CAAP;AACD,GA1DU,CA4DX;;;AACAhB,EAAAA,SAAS,CAACV,KAAD,EAAQ;AACfA,IAAAA,KAAK,CAAC2B,OAAN,CAAeC,IAAD,IAAU,KAAKC,sBAAL,CAA4BD,IAA5B,CAAxB;AACA,WAAO,KAAKE,eAAL,CAAqB9B,KAArB,CAAP;AACD,GAhEU,CAkEX;;;AAC4B,QAAtB6B,sBAAsB,CAACE,QAAD,EAAW;AACrC,UAAMC,UAAU,GAAGnD,OAAO,CAAC,qBAAD,CAA1B,CADqC,CACc;;;AACnD,UAAM+C,IAAI,GAAG,MAAMI,UAAU,CAACD,QAAD,CAA7B;;AACA,QAAI,OAAOH,IAAI,CAACA,IAAZ,KAAqB,UAAzB,EAAqC;AACnC,YAAM,IAAInB,KAAJ,CACH,sBAAqBsB,QAAS,4BAD3B,CAAN;AAGD;;AACD,WAAOA,QAAP;AACD;;AAEDE,EAAAA,YAAY,GAAG;AACb,WACE,KAAKpC,MAAL,CAAYqC,IAAZ,IACAtD,IAAI,CAACuD,IAAL,CAAUC,SAAV,EAAqB,MAArB,EAA6B,KAAKvC,MAAL,CAAYL,SAAZ,GAAwB,OAArD,CAFF;AAID;;AAED6C,EAAAA,mBAAmB,CAACzB,IAAD,EAAO;AACxB,QAAIA,IAAI,CAAC,CAAD,CAAJ,KAAY,GAAhB,EAAqBA,IAAI,GAAGA,IAAI,CAAC0B,KAAL,CAAW,CAAX,CAAP;;AAErB,QAAI,KAAKzC,MAAL,CAAY0C,uBAAZ,KAAwC,IAA5C,EAAkD;AAChD3B,MAAAA,IAAI,GAAI,GAAExB,cAAc,EAAG,IAAGwB,IAAK,EAAnC;AACD;;AAED,WAAQ,GAAEA,IAAK,IAAG,KAAKf,MAAL,CAAYL,SAAU,EAAxC;AACD;;AAEDgD,EAAAA,mBAAmB,CAAC5B,IAAD,EAAO;AACxB,UAAM6B,QAAQ,GAAG,KAAKJ,mBAAL,CAAyBzB,IAAzB,CAAjB;;AACA,UAAMa,IAAI,GAAG,KAAKL,mBAAL,EAAb;;AACA,UAAMsB,GAAG,GAAGjB,IAAI,CAACa,KAAL,CAAW,CAAC,CAAZ,EAAe,CAAf,CAAZ,CAHwB,CAGO;;AAC/B,WAAO1D,IAAI,CAACuD,IAAL,CAAUO,GAAV,EAAeD,QAAf,CAAP;AACD,GApGU,CAsGX;AACA;;;AACmB,QAAb1B,aAAa,CAACH,IAAD,EAAO;AACxB,UAAME,QAAQ,GAAG,KAAK0B,mBAAL,CAAyB5B,IAAzB,CAAjB;;AACA,UAAMzB,wBAAwB,CAC5B2B,QAD4B,EAE5B,KAAKmB,YAAL,EAF4B,EAG5B;AAAEU,MAAAA,QAAQ,EAAE;AAAZ,KAH4B,EAI5B,KAAK9C,MAAL,CAAY+C,SAAZ,IAAyB,EAJG,CAA9B;AAMA,WAAO9B,QAAP;AACD,GAjHU,CAmHX;;;AACqB,QAAfgB,eAAe,CAAC9B,KAAD,EAAQ;AAC3B,UAAM;AAAEJ,MAAAA;AAAF,QAAW,IAAjB;AACA,UAAMiD,GAAG,GAAG,EAAZ;;AACA,SAAK,MAAM/B,QAAX,IAAuBd,KAAvB,EAA8B;AAC5B,YAAMgC,UAAU,GAAGnD,OAAO,CAAC,qBAAD,CAA1B,CAD4B,CACuB;;;AACnD,YAAM+C,IAAI,GAAG,MAAMI,UAAU,CAAClB,QAAD,CAA7B;;AACA,UAAI;AACF,cAAMc,IAAI,CAACA,IAAL,CAAUhC,IAAV,CAAN;AACAiD,QAAAA,GAAG,CAACC,IAAJ,CAAShC,QAAT;AACD,OAHD,CAGE,OAAOiC,aAAP,EAAsB;AACtB,cAAMC,KAAK,GAAG,IAAIvC,KAAJ,CACX,0BAAyBK,QAAS,WAAUiC,aAAa,CAACE,OAAQ,EADvD,CAAd;AAGAD,QAAAA,KAAK,CAACE,QAAN,GAAiBH,aAAjB;AACAC,QAAAA,KAAK,CAACG,KAAN,GACEH,KAAK,CAACG,KAAN,CAAYC,KAAZ,CAAkB,IAAlB,EAAwBd,KAAxB,CAA8B,CAA9B,EAAiC,CAAjC,EAAoCH,IAApC,CAAyC,IAAzC,IACA,IADA,GAEAY,aAAa,CAACI,KAHhB;AAIA,cAAMH,KAAN;AACD;AACF;;AACD,WAAO,CAACH,GAAD,CAAP;AACD;AAED;AACF;AACA;AACA;;;AACEzB,EAAAA,mBAAmB,GAAG;AACpB,UAAMiC,WAAW,GAAGC,KAAK,CAACC,OAAN,CAAc,KAAK1D,MAAL,CAAY2D,SAA1B,IAChB,KAAK3D,MAAL,CAAY2D,SADI,GAEhB,CAAC,KAAK3D,MAAL,CAAY2D,SAAb,CAFJ;AAGA,WAAOH,WAAW,CAAChC,GAAZ,CAAiBmC,SAAD,IAAe;AACpC,UAAI,CAACA,SAAL,EAAgB;AACdC,QAAAA,OAAO,CAACC,IAAR,CACE,iFADF;AAGD;;AACD,aAAO9E,IAAI,CAAC+E,OAAL,CAAaC,OAAO,CAACC,GAAR,EAAb,EAA4BL,SAA5B,CAAP;AACD,KAPM,CAAP;AAQD;;AAED1D,EAAAA,SAAS,CAACD,MAAD,EAAS;AAChB,WAAOd,MAAM,CACX;AACES,MAAAA,SAAS,EAAE,IADb;AAEEgE,MAAAA,SAAS,EAAE,SAFb;AAGExC,MAAAA,cAAc,EAAE,CACd,KADc,EAEd,SAFc,EAGd,KAHc,EAId,OAJc,EAKd,KALc,EAMd,YANc,EAOd,KAPc,EAQd,KARc,EASd,MATc,CAHlB;AAcEuB,MAAAA,uBAAuB,EAAE,KAd3B;AAeEhB,MAAAA,kBAAkB,EAAE,KAftB;AAgBEN,MAAAA,SAAS,EAAE;AAhBb,KADW,EAmBX,KAAKpB,MAAL,IAAe,EAnBJ,EAoBXA,MApBW,CAAb;AAsBD;;AArLU;;AAwLbiE,MAAM,CAACC,OAAP,GAAiBrE,MAAjB","sourcesContent":["// Seeder\n// -------\n\nconst path = require('path');\nconst flatten = require('lodash/flatten');\nconst extend = require('lodash/extend');\nconst includes = require('lodash/includes');\nconst { ensureDirectoryExists, getFilepathsInFolder } = require('../util/fs');\nconst { writeJsFileUsingTemplate } = require('../util/template');\nconst { yyyymmddhhmmss } = require('../util/timestamp');\n\nconst filterByLoadExtensions = (extensions) => (value) => {\n  const extension = path.extname(value);\n  return includes(extensions, extension);\n};\n\n// The new seeds we're performing, typically called from the `knex.seed`\n// interface on the main `knex` object. Passes the `knex` instance performing\n// the seeds.\nclass Seeder {\n  constructor(knex) {\n    this.knex = knex;\n    this.config = this.setConfig(knex.client.config.seeds);\n  }\n\n  // Runs seed files for the given environment.\n  async run(config) {\n    this.config = this.setConfig(config);\n    let files = await this._listAll();\n    if (config && config.specific) {\n      files = files.filter((file) => path.basename(file) === config.specific);\n      if (files.length === 0) {\n        throw new Error(\n          `Invalid argument provided: the specific seed \"${config.specific}\" does not exist.`\n        );\n      }\n    }\n    return this._runSeeds(files);\n  }\n\n  // Creates a new seed file, with a given name.\n  async make(name, config) {\n    this.config = this.setConfig(config);\n    if (!name)\n      throw new Error('A name must be specified for the generated seed');\n    await this._ensureFolder(config);\n    const seedPath = await this._writeNewSeed(name);\n    return seedPath;\n  }\n\n  // Lists all available seed files as a sorted array.\n  async _listAll(config) {\n    this.config = this.setConfig(config);\n    const { loadExtensions, recursive } = this.config;\n    const seeds = flatten(\n      await Promise.all(\n        this._absoluteConfigDirs().map((d) =>\n          getFilepathsInFolder(d, recursive)\n        )\n      )\n    );\n    // if true, each dir are already sorted\n    // (getFilepathsInFolderRecursively does this)\n    // if false, we need to sort all the seeds\n    if (this.config.sortDirsSeparately) {\n      return seeds.filter(filterByLoadExtensions(loadExtensions));\n    } else {\n      return seeds.filter(filterByLoadExtensions(loadExtensions)).sort();\n    }\n  }\n\n  // Ensures a folder for the seeds exist, dependent on the\n  // seed config settings.\n  _ensureFolder() {\n    const dirs = this._absoluteConfigDirs();\n    const promises = dirs.map(ensureDirectoryExists);\n    return Promise.all(promises);\n  }\n\n  // Run seed files, in sequence.\n  _runSeeds(seeds) {\n    seeds.forEach((seed) => this._validateSeedStructure(seed));\n    return this._waterfallBatch(seeds);\n  }\n\n  // Validates seed files by requiring and checking for a `seed` function.\n  async _validateSeedStructure(filepath) {\n    const importFile = require('../util/import-file'); // late import\n    const seed = await importFile(filepath);\n    if (typeof seed.seed !== 'function') {\n      throw new Error(\n        `Invalid seed file: ${filepath} must have a seed function`\n      );\n    }\n    return filepath;\n  }\n\n  _getStubPath() {\n    return (\n      this.config.stub ||\n      path.join(__dirname, 'stub', this.config.extension + '.stub')\n    );\n  }\n\n  _getNewStubFileName(name) {\n    if (name[0] === '-') name = name.slice(1);\n\n    if (this.config.timestampFilenamePrefix === true) {\n      name = `${yyyymmddhhmmss()}_${name}`;\n    }\n\n    return `${name}.${this.config.extension}`;\n  }\n\n  _getNewStubFilePath(name) {\n    const fileName = this._getNewStubFileName(name);\n    const dirs = this._absoluteConfigDirs();\n    const dir = dirs.slice(-1)[0]; // Get last specified directory\n    return path.join(dir, fileName);\n  }\n\n  // Write a new seed to disk, using the config and generated filename,\n  // passing any `variables` given in the config to the template.\n  async _writeNewSeed(name) {\n    const seedPath = this._getNewStubFilePath(name);\n    await writeJsFileUsingTemplate(\n      seedPath,\n      this._getStubPath(),\n      { variable: 'd' },\n      this.config.variables || {}\n    );\n    return seedPath;\n  }\n\n  // Runs a batch of seed files.\n  async _waterfallBatch(seeds) {\n    const { knex } = this;\n    const log = [];\n    for (const seedPath of seeds) {\n      const importFile = require('../util/import-file'); // late import\n      const seed = await importFile(seedPath);\n      try {\n        await seed.seed(knex);\n        log.push(seedPath);\n      } catch (originalError) {\n        const error = new Error(\n          `Error while executing \"${seedPath}\" seed: ${originalError.message}`\n        );\n        error.original = originalError;\n        error.stack =\n          error.stack.split('\\n').slice(0, 2).join('\\n') +\n          '\\n' +\n          originalError.stack;\n        throw error;\n      }\n    }\n    return [log];\n  }\n\n  /**\n   * Return all the config directories\n   * @returns {string[]}\n   */\n  _absoluteConfigDirs() {\n    const directories = Array.isArray(this.config.directory)\n      ? this.config.directory\n      : [this.config.directory];\n    return directories.map((directory) => {\n      if (!directory) {\n        console.warn(\n          'Failed to resolve config file, knex cannot determine where to run or make seeds'\n        );\n      }\n      return path.resolve(process.cwd(), directory);\n    });\n  }\n\n  setConfig(config) {\n    return extend(\n      {\n        extension: 'js',\n        directory: './seeds',\n        loadExtensions: [\n          '.co',\n          '.coffee',\n          '.eg',\n          '.iced',\n          '.js',\n          '.litcoffee',\n          '.ls',\n          '.ts',\n          '.cjs',\n        ],\n        timestampFilenamePrefix: false,\n        sortDirsSeparately: false,\n        recursive: false,\n      },\n      this.config || {},\n      config\n    );\n  }\n}\n\nmodule.exports = Seeder;\n"]},"metadata":{},"sourceType":"script"}