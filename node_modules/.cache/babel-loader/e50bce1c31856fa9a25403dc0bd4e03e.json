{"ast":null,"code":"// Redshift Query Builder & Compiler\n// ------\nconst QueryCompiler = require('../../../query/querycompiler');\n\nconst QueryCompiler_PG = require('../../postgres/query/pg-querycompiler');\n\nconst identity = require('lodash/identity');\n\nconst reduce = require('lodash/reduce');\n\nclass QueryCompiler_Redshift extends QueryCompiler_PG {\n  truncate() {\n    return `truncate ${this.tableName.toLowerCase()}`;\n  } // Compiles an `insert` query, allowing for multiple\n  // inserts using a single query statement.\n\n\n  insert() {\n    const sql = QueryCompiler.prototype.insert.apply(this, arguments);\n    if (sql === '') return sql;\n\n    this._slightReturn();\n\n    return {\n      sql\n    };\n  } // Compiles an `update` query, warning on unsupported returning\n\n\n  update() {\n    const sql = QueryCompiler.prototype.update.apply(this, arguments);\n\n    this._slightReturn();\n\n    return {\n      sql\n    };\n  } // Compiles an `delete` query, warning on unsupported returning\n\n\n  del() {\n    const sql = QueryCompiler.prototype.del.apply(this, arguments);\n\n    this._slightReturn();\n\n    return {\n      sql\n    };\n  } // simple: if trying to return, warn\n\n\n  _slightReturn() {\n    if (this.single.isReturning) {\n      this.client.logger.warn('insert/update/delete returning is not supported by redshift dialect');\n    }\n  }\n\n  forUpdate() {\n    this.client.logger.warn('table lock is not supported by redshift dialect');\n    return '';\n  }\n\n  forShare() {\n    this.client.logger.warn('lock for share is not supported by redshift dialect');\n    return '';\n  } // Compiles a columnInfo query\n\n\n  columnInfo() {\n    const column = this.single.columnInfo;\n    let schema = this.single.schema; // The user may have specified a custom wrapIdentifier function in the config. We\n    // need to run the identifiers through that function, but not format them as\n    // identifiers otherwise.\n\n    const table = this.client.customWrapIdentifier(this.single.table, identity);\n\n    if (schema) {\n      schema = this.client.customWrapIdentifier(schema, identity);\n    }\n\n    let sql = 'select * from information_schema.columns where table_name = ? and table_catalog = ?';\n    const bindings = [table.toLowerCase(), this.client.database().toLowerCase()];\n\n    if (schema) {\n      sql += ' and table_schema = ?';\n      bindings.push(schema);\n    } else {\n      sql += ' and table_schema = current_schema()';\n    }\n\n    return {\n      sql,\n      bindings,\n\n      output(resp) {\n        const out = reduce(resp.rows, function (columns, val) {\n          columns[val.column_name] = {\n            type: val.data_type,\n            maxLength: val.character_maximum_length,\n            nullable: val.is_nullable === 'YES',\n            defaultValue: val.column_default\n          };\n          return columns;\n        }, {});\n        return column && out[column] || out;\n      }\n\n    };\n  }\n\n}\n\nmodule.exports = QueryCompiler_Redshift;","map":{"version":3,"sources":["/home/rosiane/Projeto-completo/back/node_modules/knex/lib/dialects/redshift/query/redshift-querycompiler.js"],"names":["QueryCompiler","require","QueryCompiler_PG","identity","reduce","QueryCompiler_Redshift","truncate","tableName","toLowerCase","insert","sql","prototype","apply","arguments","_slightReturn","update","del","single","isReturning","client","logger","warn","forUpdate","forShare","columnInfo","column","schema","table","customWrapIdentifier","bindings","database","push","output","resp","out","rows","columns","val","column_name","type","data_type","maxLength","character_maximum_length","nullable","is_nullable","defaultValue","column_default","module","exports"],"mappings":"AAAA;AACA;AACA,MAAMA,aAAa,GAAGC,OAAO,CAAC,8BAAD,CAA7B;;AACA,MAAMC,gBAAgB,GAAGD,OAAO,CAAC,uCAAD,CAAhC;;AAEA,MAAME,QAAQ,GAAGF,OAAO,CAAC,iBAAD,CAAxB;;AACA,MAAMG,MAAM,GAAGH,OAAO,CAAC,eAAD,CAAtB;;AAEA,MAAMI,sBAAN,SAAqCH,gBAArC,CAAsD;AACpDI,EAAAA,QAAQ,GAAG;AACT,WAAQ,YAAW,KAAKC,SAAL,CAAeC,WAAf,EAA6B,EAAhD;AACD,GAHmD,CAKpD;AACA;;;AACAC,EAAAA,MAAM,GAAG;AACP,UAAMC,GAAG,GAAGV,aAAa,CAACW,SAAd,CAAwBF,MAAxB,CAA+BG,KAA/B,CAAqC,IAArC,EAA2CC,SAA3C,CAAZ;AACA,QAAIH,GAAG,KAAK,EAAZ,EAAgB,OAAOA,GAAP;;AAChB,SAAKI,aAAL;;AACA,WAAO;AACLJ,MAAAA;AADK,KAAP;AAGD,GAdmD,CAgBpD;;;AACAK,EAAAA,MAAM,GAAG;AACP,UAAML,GAAG,GAAGV,aAAa,CAACW,SAAd,CAAwBI,MAAxB,CAA+BH,KAA/B,CAAqC,IAArC,EAA2CC,SAA3C,CAAZ;;AACA,SAAKC,aAAL;;AACA,WAAO;AACLJ,MAAAA;AADK,KAAP;AAGD,GAvBmD,CAyBpD;;;AACAM,EAAAA,GAAG,GAAG;AACJ,UAAMN,GAAG,GAAGV,aAAa,CAACW,SAAd,CAAwBK,GAAxB,CAA4BJ,KAA5B,CAAkC,IAAlC,EAAwCC,SAAxC,CAAZ;;AACA,SAAKC,aAAL;;AACA,WAAO;AACLJ,MAAAA;AADK,KAAP;AAGD,GAhCmD,CAkCpD;;;AACAI,EAAAA,aAAa,GAAG;AACd,QAAI,KAAKG,MAAL,CAAYC,WAAhB,EAA6B;AAC3B,WAAKC,MAAL,CAAYC,MAAZ,CAAmBC,IAAnB,CACE,qEADF;AAGD;AACF;;AAEDC,EAAAA,SAAS,GAAG;AACV,SAAKH,MAAL,CAAYC,MAAZ,CAAmBC,IAAnB,CAAwB,iDAAxB;AACA,WAAO,EAAP;AACD;;AAEDE,EAAAA,QAAQ,GAAG;AACT,SAAKJ,MAAL,CAAYC,MAAZ,CAAmBC,IAAnB,CACE,qDADF;AAGA,WAAO,EAAP;AACD,GArDmD,CAuDpD;;;AACAG,EAAAA,UAAU,GAAG;AACX,UAAMC,MAAM,GAAG,KAAKR,MAAL,CAAYO,UAA3B;AACA,QAAIE,MAAM,GAAG,KAAKT,MAAL,CAAYS,MAAzB,CAFW,CAIX;AACA;AACA;;AACA,UAAMC,KAAK,GAAG,KAAKR,MAAL,CAAYS,oBAAZ,CAAiC,KAAKX,MAAL,CAAYU,KAA7C,EAAoDxB,QAApD,CAAd;;AAEA,QAAIuB,MAAJ,EAAY;AACVA,MAAAA,MAAM,GAAG,KAAKP,MAAL,CAAYS,oBAAZ,CAAiCF,MAAjC,EAAyCvB,QAAzC,CAAT;AACD;;AAED,QAAIO,GAAG,GACL,qFADF;AAEA,UAAMmB,QAAQ,GAAG,CACfF,KAAK,CAACnB,WAAN,EADe,EAEf,KAAKW,MAAL,CAAYW,QAAZ,GAAuBtB,WAAvB,EAFe,CAAjB;;AAKA,QAAIkB,MAAJ,EAAY;AACVhB,MAAAA,GAAG,IAAI,uBAAP;AACAmB,MAAAA,QAAQ,CAACE,IAAT,CAAcL,MAAd;AACD,KAHD,MAGO;AACLhB,MAAAA,GAAG,IAAI,sCAAP;AACD;;AAED,WAAO;AACLA,MAAAA,GADK;AAELmB,MAAAA,QAFK;;AAGLG,MAAAA,MAAM,CAACC,IAAD,EAAO;AACX,cAAMC,GAAG,GAAG9B,MAAM,CAChB6B,IAAI,CAACE,IADW,EAEhB,UAAUC,OAAV,EAAmBC,GAAnB,EAAwB;AACtBD,UAAAA,OAAO,CAACC,GAAG,CAACC,WAAL,CAAP,GAA2B;AACzBC,YAAAA,IAAI,EAAEF,GAAG,CAACG,SADe;AAEzBC,YAAAA,SAAS,EAAEJ,GAAG,CAACK,wBAFU;AAGzBC,YAAAA,QAAQ,EAAEN,GAAG,CAACO,WAAJ,KAAoB,KAHL;AAIzBC,YAAAA,YAAY,EAAER,GAAG,CAACS;AAJO,WAA3B;AAMA,iBAAOV,OAAP;AACD,SAVe,EAWhB,EAXgB,CAAlB;AAaA,eAAQX,MAAM,IAAIS,GAAG,CAACT,MAAD,CAAd,IAA2BS,GAAlC;AACD;;AAlBI,KAAP;AAoBD;;AAvGmD;;AA0GtDa,MAAM,CAACC,OAAP,GAAiB3C,sBAAjB","sourcesContent":["// Redshift Query Builder & Compiler\n// ------\nconst QueryCompiler = require('../../../query/querycompiler');\nconst QueryCompiler_PG = require('../../postgres/query/pg-querycompiler');\n\nconst identity = require('lodash/identity');\nconst reduce = require('lodash/reduce');\n\nclass QueryCompiler_Redshift extends QueryCompiler_PG {\n  truncate() {\n    return `truncate ${this.tableName.toLowerCase()}`;\n  }\n\n  // Compiles an `insert` query, allowing for multiple\n  // inserts using a single query statement.\n  insert() {\n    const sql = QueryCompiler.prototype.insert.apply(this, arguments);\n    if (sql === '') return sql;\n    this._slightReturn();\n    return {\n      sql,\n    };\n  }\n\n  // Compiles an `update` query, warning on unsupported returning\n  update() {\n    const sql = QueryCompiler.prototype.update.apply(this, arguments);\n    this._slightReturn();\n    return {\n      sql,\n    };\n  }\n\n  // Compiles an `delete` query, warning on unsupported returning\n  del() {\n    const sql = QueryCompiler.prototype.del.apply(this, arguments);\n    this._slightReturn();\n    return {\n      sql,\n    };\n  }\n\n  // simple: if trying to return, warn\n  _slightReturn() {\n    if (this.single.isReturning) {\n      this.client.logger.warn(\n        'insert/update/delete returning is not supported by redshift dialect'\n      );\n    }\n  }\n\n  forUpdate() {\n    this.client.logger.warn('table lock is not supported by redshift dialect');\n    return '';\n  }\n\n  forShare() {\n    this.client.logger.warn(\n      'lock for share is not supported by redshift dialect'\n    );\n    return '';\n  }\n\n  // Compiles a columnInfo query\n  columnInfo() {\n    const column = this.single.columnInfo;\n    let schema = this.single.schema;\n\n    // The user may have specified a custom wrapIdentifier function in the config. We\n    // need to run the identifiers through that function, but not format them as\n    // identifiers otherwise.\n    const table = this.client.customWrapIdentifier(this.single.table, identity);\n\n    if (schema) {\n      schema = this.client.customWrapIdentifier(schema, identity);\n    }\n\n    let sql =\n      'select * from information_schema.columns where table_name = ? and table_catalog = ?';\n    const bindings = [\n      table.toLowerCase(),\n      this.client.database().toLowerCase(),\n    ];\n\n    if (schema) {\n      sql += ' and table_schema = ?';\n      bindings.push(schema);\n    } else {\n      sql += ' and table_schema = current_schema()';\n    }\n\n    return {\n      sql,\n      bindings,\n      output(resp) {\n        const out = reduce(\n          resp.rows,\n          function (columns, val) {\n            columns[val.column_name] = {\n              type: val.data_type,\n              maxLength: val.character_maximum_length,\n              nullable: val.is_nullable === 'YES',\n              defaultValue: val.column_default,\n            };\n            return columns;\n          },\n          {}\n        );\n        return (column && out[column]) || out;\n      },\n    };\n  }\n}\n\nmodule.exports = QueryCompiler_Redshift;\n"]},"metadata":{},"sourceType":"script"}