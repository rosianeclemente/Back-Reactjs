{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst PendingOperation_1 = require(\"./PendingOperation\");\n\nconst Resource_1 = require(\"./Resource\");\n\nconst utils_1 = require(\"./utils\");\n\nconst events_1 = require(\"events\");\n\nconst timers_1 = require(\"timers\");\n\nclass Pool {\n  constructor(opt) {\n    this.destroyed = false;\n    this.emitter = new events_1.EventEmitter();\n    opt = opt || {};\n\n    if (!opt.create) {\n      throw new Error('Tarn: opt.create function most be provided');\n    }\n\n    if (!opt.destroy) {\n      throw new Error('Tarn: opt.destroy function most be provided');\n    }\n\n    if (typeof opt.min !== 'number' || opt.min < 0 || opt.min !== Math.round(opt.min)) {\n      throw new Error('Tarn: opt.min must be an integer >= 0');\n    }\n\n    if (typeof opt.max !== 'number' || opt.max <= 0 || opt.max !== Math.round(opt.max)) {\n      throw new Error('Tarn: opt.max must be an integer > 0');\n    }\n\n    if (opt.min > opt.max) {\n      throw new Error('Tarn: opt.max is smaller than opt.min');\n    }\n\n    if (!utils_1.checkOptionalTime(opt.acquireTimeoutMillis)) {\n      throw new Error('Tarn: invalid opt.acquireTimeoutMillis ' + JSON.stringify(opt.acquireTimeoutMillis));\n    }\n\n    if (!utils_1.checkOptionalTime(opt.createTimeoutMillis)) {\n      throw new Error('Tarn: invalid opt.createTimeoutMillis ' + JSON.stringify(opt.createTimeoutMillis));\n    }\n\n    if (!utils_1.checkOptionalTime(opt.destroyTimeoutMillis)) {\n      throw new Error('Tarn: invalid opt.destroyTimeoutMillis ' + JSON.stringify(opt.destroyTimeoutMillis));\n    }\n\n    if (!utils_1.checkOptionalTime(opt.idleTimeoutMillis)) {\n      throw new Error('Tarn: invalid opt.idleTimeoutMillis ' + JSON.stringify(opt.idleTimeoutMillis));\n    }\n\n    if (!utils_1.checkOptionalTime(opt.reapIntervalMillis)) {\n      throw new Error('Tarn: invalid opt.reapIntervalMillis ' + JSON.stringify(opt.reapIntervalMillis));\n    }\n\n    if (!utils_1.checkOptionalTime(opt.createRetryIntervalMillis)) {\n      throw new Error('Tarn: invalid opt.createRetryIntervalMillis ' + JSON.stringify(opt.createRetryIntervalMillis));\n    }\n\n    const allowedKeys = {\n      create: true,\n      validate: true,\n      destroy: true,\n      log: true,\n      min: true,\n      max: true,\n      acquireTimeoutMillis: true,\n      createTimeoutMillis: true,\n      destroyTimeoutMillis: true,\n      idleTimeoutMillis: true,\n      reapIntervalMillis: true,\n      createRetryIntervalMillis: true,\n      propagateCreateError: true\n    };\n\n    for (const key of Object.keys(opt)) {\n      if (!allowedKeys[key]) {\n        throw new Error(`Tarn: unsupported option opt.${key}`);\n      }\n    }\n\n    this.creator = opt.create;\n    this.destroyer = opt.destroy;\n    this.validate = typeof opt.validate === 'function' ? opt.validate : () => true;\n\n    this.log = opt.log || (() => {});\n\n    this.acquireTimeoutMillis = opt.acquireTimeoutMillis || 30000;\n    this.createTimeoutMillis = opt.createTimeoutMillis || 30000;\n    this.destroyTimeoutMillis = opt.destroyTimeoutMillis || 5000;\n    this.idleTimeoutMillis = opt.idleTimeoutMillis || 30000;\n    this.reapIntervalMillis = opt.reapIntervalMillis || 1000;\n    this.createRetryIntervalMillis = opt.createRetryIntervalMillis || 200;\n    this.propagateCreateError = !!opt.propagateCreateError;\n    this.min = opt.min;\n    this.max = opt.max; // All the resources, which are either already acquired or which are\n    // considered for being passed to acquire in async validation phase.\n\n    this.used = []; // All the resources, which are either just created and free or returned\n    // back to pool after using.\n\n    this.free = [];\n    this.pendingCreates = [];\n    this.pendingAcquires = [];\n    this.pendingDestroys = []; // When acquire is pending, but also still in validation phase\n\n    this.pendingValidations = [];\n    this.destroyed = false;\n    this.interval = null;\n    this.eventId = 1;\n  }\n\n  numUsed() {\n    return this.used.length;\n  }\n\n  numFree() {\n    return this.free.length;\n  }\n\n  numPendingAcquires() {\n    return this.pendingAcquires.length;\n  }\n\n  numPendingValidations() {\n    return this.pendingValidations.length;\n  }\n\n  numPendingCreates() {\n    return this.pendingCreates.length;\n  }\n\n  acquire() {\n    const eventId = this.eventId++;\n\n    this._executeEventHandlers('acquireRequest', eventId);\n\n    const pendingAcquire = new PendingOperation_1.PendingOperation(this.acquireTimeoutMillis);\n    this.pendingAcquires.push(pendingAcquire); // If the acquire fails for whatever reason\n    // remove it from the pending queue.\n\n    pendingAcquire.promise = pendingAcquire.promise.then(resource => {\n      this._executeEventHandlers('acquireSuccess', eventId, resource);\n\n      return resource;\n    }).catch(err => {\n      this._executeEventHandlers('acquireFail', eventId, err);\n\n      remove(this.pendingAcquires, pendingAcquire);\n      return Promise.reject(err);\n    });\n\n    this._tryAcquireOrCreate();\n\n    return pendingAcquire;\n  }\n\n  release(resource) {\n    this._executeEventHandlers('release', resource);\n\n    for (let i = 0, l = this.used.length; i < l; ++i) {\n      const used = this.used[i];\n\n      if (used.resource === resource) {\n        this.used.splice(i, 1);\n        this.free.push(used.resolve());\n\n        this._tryAcquireOrCreate();\n\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  isEmpty() {\n    return [this.numFree(), this.numUsed(), this.numPendingAcquires(), this.numPendingValidations(), this.numPendingCreates()].reduce((total, value) => total + value) === 0;\n  }\n  /**\n   * Reaping cycle.\n   */\n\n\n  check() {\n    const timestamp = utils_1.now();\n    const newFree = [];\n    const minKeep = this.min - this.used.length;\n    const maxDestroy = this.free.length - minKeep;\n    let numDestroyed = 0;\n    this.free.forEach(free => {\n      if (utils_1.duration(timestamp, free.timestamp) >= this.idleTimeoutMillis && numDestroyed < maxDestroy) {\n        numDestroyed++;\n\n        this._destroy(free.resource);\n      } else {\n        newFree.push(free);\n      }\n    });\n    this.free = newFree; // Pool is completely empty, stop reaping.\n    // Next .acquire will start reaping interval again.\n\n    if (this.isEmpty()) {\n      this._stopReaping();\n    }\n  }\n\n  destroy() {\n    const eventId = this.eventId++;\n\n    this._executeEventHandlers('poolDestroyRequest', eventId);\n\n    this._stopReaping();\n\n    this.destroyed = true; // First wait for all the pending creates get ready.\n\n    return utils_1.reflect(Promise.all(this.pendingCreates.map(create => utils_1.reflect(create.promise))).then(() => {\n      // eslint-disable-next-line\n      return new Promise((resolve, reject) => {\n        // poll every 100ms and wait that all validations are ready\n        if (this.numPendingValidations() === 0) {\n          resolve();\n          return;\n        }\n\n        const interval = setInterval(() => {\n          if (this.numPendingValidations() === 0) {\n            timers_1.clearInterval(interval);\n            resolve();\n          }\n        }, 100);\n      });\n    }).then(() => {\n      // Wait for all the used resources to be freed.\n      return Promise.all(this.used.map(used => utils_1.reflect(used.promise)));\n    }).then(() => {\n      // Abort all pending acquires.\n      return Promise.all(this.pendingAcquires.map(acquire => {\n        acquire.abort();\n        return utils_1.reflect(acquire.promise);\n      }));\n    }).then(() => {\n      // Now we can destroy all the freed resources.\n      return Promise.all(this.free.map(free => utils_1.reflect(this._destroy(free.resource))));\n    }).then(() => {\n      // Also wait rest of the pending destroys to finish\n      return Promise.all(this.pendingDestroys.map(pd => pd.promise));\n    }).then(() => {\n      this.free = [];\n      this.pendingAcquires = [];\n    })).then(res => {\n      this._executeEventHandlers('poolDestroySuccess', eventId);\n\n      this.emitter.removeAllListeners();\n      return res;\n    });\n  }\n\n  on(event, listener) {\n    this.emitter.on(event, listener);\n  }\n\n  removeListener(event, listener) {\n    this.emitter.removeListener(event, listener);\n  }\n\n  removeAllListeners(event) {\n    this.emitter.removeAllListeners(event);\n  }\n  /**\n   * The most important method that is called always when resources\n   * are created / destroyed / acquired / released. In other words\n   * every time when resources are moved from used to free or vice\n   * versa.\n   *\n   * Either assigns free resources to pendingAcquires or creates new\n   * resources if there is room for it in the pool.\n   */\n\n\n  _tryAcquireOrCreate() {\n    if (this.destroyed) {\n      return;\n    }\n\n    if (this._hasFreeResources()) {\n      this._doAcquire();\n    } else if (this._shouldCreateMoreResources()) {\n      this._doCreate();\n    }\n  }\n\n  _hasFreeResources() {\n    return this.free.length > 0;\n  }\n\n  _doAcquire() {\n    // Acquire as many pending acquires as possible concurrently\n    while (this._canAcquire()) {\n      // To allow async validation, we actually need to move free resource\n      // and pending acquire temporary from their respective arrays and depending\n      // on validation result to either leave the free resource to used resources array\n      // or destroy the free resource if validation did fail.\n      const pendingAcquire = this.pendingAcquires.shift();\n      const free = this.free.pop();\n\n      if (free === undefined || pendingAcquire === undefined) {\n        const errMessage = 'this.free was empty while trying to acquire resource';\n        this.log(`Tarn: ${errMessage}`, 'warn');\n        throw new Error(`Internal error, should never happen. ${errMessage}`);\n      } // Make sure that pendingAcquire that is being validated is not lost and\n      // can be freed when pool is destroyed.\n\n\n      this.pendingValidations.push(pendingAcquire); // Must be added here pre-emptively to prevent logic that decides\n      // if new resources are created will keep on working correctly.\n\n      this.used.push(free); // if acquire fails also pending validation, must be aborted so that pre reserved\n      // resource will be returned to free resources immediately\n\n      const abortAbleValidation = new PendingOperation_1.PendingOperation(this.acquireTimeoutMillis); // eslint-disable-next-line\n\n      pendingAcquire.promise.catch(err => {\n        abortAbleValidation.abort();\n      });\n      abortAbleValidation.promise.catch(err => {\n        // There's nothing we can do here but log the error. This would otherwise\n        // leak out as an unhandled exception.\n        this.log('Tarn: resource validator threw an exception ' + err.stack, 'warn');\n        return false;\n      }).then(validationSuccess => {\n        try {\n          if (validationSuccess) {\n            // At least one active resource exist, start reaping.\n            this._startReaping();\n\n            pendingAcquire.resolve(free.resource);\n          } else {\n            remove(this.used, free);\n\n            this._destroy(free.resource); // is acquire was canceled, failed or timed out already\n            // no need to return it to pending queries\n\n\n            if (!pendingAcquire.isRejected) {\n              this.pendingAcquires.unshift(pendingAcquire);\n            } // Since we destroyed an invalid resource and were not able to fulfill\n            // all the pending acquires, we may need to create new ones or at\n            // least run this acquire loop again to verify it. But not immediately\n            // to prevent starving event loop.\n\n\n            setTimeout(() => {\n              this._tryAcquireOrCreate();\n            }, 0);\n          }\n        } finally {\n          remove(this.pendingValidations, pendingAcquire);\n        }\n      }); // try to validate\n\n      this._validateResource(free.resource).then(validationSuccess => {\n        abortAbleValidation.resolve(validationSuccess);\n      }).catch(err => {\n        abortAbleValidation.reject(err);\n      });\n    }\n  }\n\n  _canAcquire() {\n    return this.free.length > 0 && this.pendingAcquires.length > 0;\n  }\n\n  _validateResource(resource) {\n    try {\n      return Promise.resolve(this.validate(resource));\n    } catch (err) {\n      // prevent leaking of sync exception\n      return Promise.reject(err);\n    }\n  }\n\n  _shouldCreateMoreResources() {\n    return this.used.length + this.pendingCreates.length < this.max && this.pendingCreates.length < this.pendingAcquires.length;\n  }\n\n  _doCreate() {\n    const pendingAcquiresBeforeCreate = this.pendingAcquires.slice();\n\n    const pendingCreate = this._create();\n\n    pendingCreate.promise.then(() => {\n      // Not returned on purpose.\n      this._tryAcquireOrCreate();\n\n      return null;\n    }).catch(err => {\n      if (this.propagateCreateError && this.pendingAcquires.length !== 0) {\n        // If propagateCreateError is true, we don't retry the create\n        // but reject the first pending acquire immediately. Intentionally\n        // use `this.pendingAcquires` instead of `pendingAcquiresBeforeCreate`\n        // in case some acquires in pendingAcquiresBeforeCreate have already\n        // been resolved.\n        this.pendingAcquires[0].reject(err);\n      } // Save the create error to all pending acquires so that we can use it\n      // as the error to reject the acquire if it times out.\n\n\n      pendingAcquiresBeforeCreate.forEach(pendingAcquire => {\n        pendingAcquire.possibleTimeoutCause = err;\n      }); // Not returned on purpose.\n\n      utils_1.delay(this.createRetryIntervalMillis).then(() => this._tryAcquireOrCreate());\n    });\n  }\n\n  _create() {\n    const eventId = this.eventId++;\n\n    this._executeEventHandlers('createRequest', eventId);\n\n    const pendingCreate = new PendingOperation_1.PendingOperation(this.createTimeoutMillis); // If an error occurs (likely a create timeout) remove this creation from\n    // the list of pending creations so we try to create a new one.\n\n    pendingCreate.promise = pendingCreate.promise.catch(err => {\n      if (remove(this.pendingCreates, pendingCreate)) {\n        // TODO: figure out more consistent way for different error handlers in next rewrite\n        this._executeEventHandlers('createFail', eventId, err);\n      }\n\n      throw err;\n    });\n    this.pendingCreates.push(pendingCreate);\n    callbackOrPromise(this.creator).then(resource => {\n      if (pendingCreate.isRejected) {\n        this.destroyer(resource);\n        return null;\n      }\n\n      remove(this.pendingCreates, pendingCreate);\n      this.free.push(new Resource_1.Resource(resource)); // Not returned on purpose.\n\n      pendingCreate.resolve(resource);\n\n      this._executeEventHandlers('createSuccess', eventId, resource);\n\n      return null;\n    }).catch(err => {\n      if (pendingCreate.isRejected) {\n        return null;\n      }\n\n      if (remove(this.pendingCreates, pendingCreate)) {\n        this._executeEventHandlers('createFail', eventId, err);\n      } // Not returned on purpose.\n\n\n      pendingCreate.reject(err);\n      return null;\n    });\n    return pendingCreate;\n  }\n\n  _destroy(resource) {\n    const eventId = this.eventId++;\n\n    this._executeEventHandlers('destroyRequest', eventId, resource); // this.destroyer can be both synchronous and asynchronous.\n    // so we wrap it to promise to get all exceptions through same pipeline\n\n\n    const pendingDestroy = new PendingOperation_1.PendingOperation(this.destroyTimeoutMillis);\n    const retVal = Promise.resolve().then(() => this.destroyer(resource));\n    retVal.then(() => {\n      pendingDestroy.resolve(resource);\n    }).catch(err => {\n      pendingDestroy.reject(err);\n    });\n    this.pendingDestroys.push(pendingDestroy); // In case of an error there's nothing we can do here but log it.\n\n    return pendingDestroy.promise.then(res => {\n      this._executeEventHandlers('destroySuccess', eventId, resource);\n\n      return res;\n    }).catch(err => this._logDestroyerError(eventId, resource, err)).then(res => {\n      const index = this.pendingDestroys.findIndex(pd => pd === pendingDestroy);\n      this.pendingDestroys.splice(index, 1);\n      return res;\n    });\n  }\n\n  _logDestroyerError(eventId, resource, err) {\n    this._executeEventHandlers('destroyFail', eventId, resource, err);\n\n    this.log('Tarn: resource destroyer threw an exception ' + err.stack, 'warn');\n  }\n\n  _startReaping() {\n    if (!this.interval) {\n      this._executeEventHandlers('startReaping');\n\n      this.interval = setInterval(() => this.check(), this.reapIntervalMillis);\n    }\n  }\n\n  _stopReaping() {\n    if (this.interval !== null) {\n      this._executeEventHandlers('stopReaping');\n\n      timers_1.clearInterval(this.interval);\n    }\n\n    this.interval = null;\n  }\n\n  _executeEventHandlers(eventName, ...args) {\n    const listeners = this.emitter.listeners(eventName); // just calling .emit() would stop running rest of the listeners if one them fails\n\n    listeners.forEach(listener => {\n      try {\n        listener(...args);\n      } catch (err) {\n        // There's nothing we can do here but log the error. This would otherwise\n        // leak out as an unhandled exception.\n        this.log(`Tarn: event handler \"${eventName}\" threw an exception ${err.stack}`, 'warn');\n      }\n    });\n  }\n\n}\n\nexports.Pool = Pool;\n\nfunction remove(arr, item) {\n  const idx = arr.indexOf(item);\n\n  if (idx === -1) {\n    return false;\n  } else {\n    arr.splice(idx, 1);\n    return true;\n  }\n}\n\nfunction callbackOrPromise(func) {\n  return new Promise((resolve, reject) => {\n    const callback = (err, resource) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(resource);\n      }\n    };\n\n    utils_1.tryPromise(() => func(callback)).then(res => {\n      // If the result is falsy, we assume that the callback will\n      // be called instead of interpreting the falsy value as a\n      // result value.\n      if (res) {\n        resolve(res);\n      }\n    }).catch(err => {\n      reject(err);\n    });\n  });\n}","map":{"version":3,"sources":["/home/rosiane/Projeto-completo/back/node_modules/tarn/dist/Pool.js"],"names":["Object","defineProperty","exports","value","PendingOperation_1","require","Resource_1","utils_1","events_1","timers_1","Pool","constructor","opt","destroyed","emitter","EventEmitter","create","Error","destroy","min","Math","round","max","checkOptionalTime","acquireTimeoutMillis","JSON","stringify","createTimeoutMillis","destroyTimeoutMillis","idleTimeoutMillis","reapIntervalMillis","createRetryIntervalMillis","allowedKeys","validate","log","propagateCreateError","key","keys","creator","destroyer","used","free","pendingCreates","pendingAcquires","pendingDestroys","pendingValidations","interval","eventId","numUsed","length","numFree","numPendingAcquires","numPendingValidations","numPendingCreates","acquire","_executeEventHandlers","pendingAcquire","PendingOperation","push","promise","then","resource","catch","err","remove","Promise","reject","_tryAcquireOrCreate","release","i","l","splice","resolve","isEmpty","reduce","total","check","timestamp","now","newFree","minKeep","maxDestroy","numDestroyed","forEach","duration","_destroy","_stopReaping","reflect","all","map","setInterval","clearInterval","abort","pd","res","removeAllListeners","on","event","listener","removeListener","_hasFreeResources","_doAcquire","_shouldCreateMoreResources","_doCreate","_canAcquire","shift","pop","undefined","errMessage","abortAbleValidation","stack","validationSuccess","_startReaping","isRejected","unshift","setTimeout","_validateResource","pendingAcquiresBeforeCreate","slice","pendingCreate","_create","possibleTimeoutCause","delay","callbackOrPromise","Resource","pendingDestroy","retVal","_logDestroyerError","index","findIndex","eventName","args","listeners","arr","item","idx","indexOf","func","callback","tryPromise"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst PendingOperation_1 = require(\"./PendingOperation\");\nconst Resource_1 = require(\"./Resource\");\nconst utils_1 = require(\"./utils\");\nconst events_1 = require(\"events\");\nconst timers_1 = require(\"timers\");\nclass Pool {\n    constructor(opt) {\n        this.destroyed = false;\n        this.emitter = new events_1.EventEmitter();\n        opt = opt || {};\n        if (!opt.create) {\n            throw new Error('Tarn: opt.create function most be provided');\n        }\n        if (!opt.destroy) {\n            throw new Error('Tarn: opt.destroy function most be provided');\n        }\n        if (typeof opt.min !== 'number' || opt.min < 0 || opt.min !== Math.round(opt.min)) {\n            throw new Error('Tarn: opt.min must be an integer >= 0');\n        }\n        if (typeof opt.max !== 'number' || opt.max <= 0 || opt.max !== Math.round(opt.max)) {\n            throw new Error('Tarn: opt.max must be an integer > 0');\n        }\n        if (opt.min > opt.max) {\n            throw new Error('Tarn: opt.max is smaller than opt.min');\n        }\n        if (!utils_1.checkOptionalTime(opt.acquireTimeoutMillis)) {\n            throw new Error('Tarn: invalid opt.acquireTimeoutMillis ' + JSON.stringify(opt.acquireTimeoutMillis));\n        }\n        if (!utils_1.checkOptionalTime(opt.createTimeoutMillis)) {\n            throw new Error('Tarn: invalid opt.createTimeoutMillis ' + JSON.stringify(opt.createTimeoutMillis));\n        }\n        if (!utils_1.checkOptionalTime(opt.destroyTimeoutMillis)) {\n            throw new Error('Tarn: invalid opt.destroyTimeoutMillis ' + JSON.stringify(opt.destroyTimeoutMillis));\n        }\n        if (!utils_1.checkOptionalTime(opt.idleTimeoutMillis)) {\n            throw new Error('Tarn: invalid opt.idleTimeoutMillis ' + JSON.stringify(opt.idleTimeoutMillis));\n        }\n        if (!utils_1.checkOptionalTime(opt.reapIntervalMillis)) {\n            throw new Error('Tarn: invalid opt.reapIntervalMillis ' + JSON.stringify(opt.reapIntervalMillis));\n        }\n        if (!utils_1.checkOptionalTime(opt.createRetryIntervalMillis)) {\n            throw new Error('Tarn: invalid opt.createRetryIntervalMillis ' +\n                JSON.stringify(opt.createRetryIntervalMillis));\n        }\n        const allowedKeys = {\n            create: true,\n            validate: true,\n            destroy: true,\n            log: true,\n            min: true,\n            max: true,\n            acquireTimeoutMillis: true,\n            createTimeoutMillis: true,\n            destroyTimeoutMillis: true,\n            idleTimeoutMillis: true,\n            reapIntervalMillis: true,\n            createRetryIntervalMillis: true,\n            propagateCreateError: true\n        };\n        for (const key of Object.keys(opt)) {\n            if (!allowedKeys[key]) {\n                throw new Error(`Tarn: unsupported option opt.${key}`);\n            }\n        }\n        this.creator = opt.create;\n        this.destroyer = opt.destroy;\n        this.validate = typeof opt.validate === 'function' ? opt.validate : () => true;\n        this.log = opt.log || (() => { });\n        this.acquireTimeoutMillis = opt.acquireTimeoutMillis || 30000;\n        this.createTimeoutMillis = opt.createTimeoutMillis || 30000;\n        this.destroyTimeoutMillis = opt.destroyTimeoutMillis || 5000;\n        this.idleTimeoutMillis = opt.idleTimeoutMillis || 30000;\n        this.reapIntervalMillis = opt.reapIntervalMillis || 1000;\n        this.createRetryIntervalMillis = opt.createRetryIntervalMillis || 200;\n        this.propagateCreateError = !!opt.propagateCreateError;\n        this.min = opt.min;\n        this.max = opt.max;\n        // All the resources, which are either already acquired or which are\n        // considered for being passed to acquire in async validation phase.\n        this.used = [];\n        // All the resources, which are either just created and free or returned\n        // back to pool after using.\n        this.free = [];\n        this.pendingCreates = [];\n        this.pendingAcquires = [];\n        this.pendingDestroys = [];\n        // When acquire is pending, but also still in validation phase\n        this.pendingValidations = [];\n        this.destroyed = false;\n        this.interval = null;\n        this.eventId = 1;\n    }\n    numUsed() {\n        return this.used.length;\n    }\n    numFree() {\n        return this.free.length;\n    }\n    numPendingAcquires() {\n        return this.pendingAcquires.length;\n    }\n    numPendingValidations() {\n        return this.pendingValidations.length;\n    }\n    numPendingCreates() {\n        return this.pendingCreates.length;\n    }\n    acquire() {\n        const eventId = this.eventId++;\n        this._executeEventHandlers('acquireRequest', eventId);\n        const pendingAcquire = new PendingOperation_1.PendingOperation(this.acquireTimeoutMillis);\n        this.pendingAcquires.push(pendingAcquire);\n        // If the acquire fails for whatever reason\n        // remove it from the pending queue.\n        pendingAcquire.promise = pendingAcquire.promise\n            .then(resource => {\n            this._executeEventHandlers('acquireSuccess', eventId, resource);\n            return resource;\n        })\n            .catch(err => {\n            this._executeEventHandlers('acquireFail', eventId, err);\n            remove(this.pendingAcquires, pendingAcquire);\n            return Promise.reject(err);\n        });\n        this._tryAcquireOrCreate();\n        return pendingAcquire;\n    }\n    release(resource) {\n        this._executeEventHandlers('release', resource);\n        for (let i = 0, l = this.used.length; i < l; ++i) {\n            const used = this.used[i];\n            if (used.resource === resource) {\n                this.used.splice(i, 1);\n                this.free.push(used.resolve());\n                this._tryAcquireOrCreate();\n                return true;\n            }\n        }\n        return false;\n    }\n    isEmpty() {\n        return ([\n            this.numFree(),\n            this.numUsed(),\n            this.numPendingAcquires(),\n            this.numPendingValidations(),\n            this.numPendingCreates()\n        ].reduce((total, value) => total + value) === 0);\n    }\n    /**\n     * Reaping cycle.\n     */\n    check() {\n        const timestamp = utils_1.now();\n        const newFree = [];\n        const minKeep = this.min - this.used.length;\n        const maxDestroy = this.free.length - minKeep;\n        let numDestroyed = 0;\n        this.free.forEach(free => {\n            if (utils_1.duration(timestamp, free.timestamp) >= this.idleTimeoutMillis &&\n                numDestroyed < maxDestroy) {\n                numDestroyed++;\n                this._destroy(free.resource);\n            }\n            else {\n                newFree.push(free);\n            }\n        });\n        this.free = newFree;\n        // Pool is completely empty, stop reaping.\n        // Next .acquire will start reaping interval again.\n        if (this.isEmpty()) {\n            this._stopReaping();\n        }\n    }\n    destroy() {\n        const eventId = this.eventId++;\n        this._executeEventHandlers('poolDestroyRequest', eventId);\n        this._stopReaping();\n        this.destroyed = true;\n        // First wait for all the pending creates get ready.\n        return utils_1.reflect(Promise.all(this.pendingCreates.map(create => utils_1.reflect(create.promise)))\n            .then(() => {\n            // eslint-disable-next-line\n            return new Promise((resolve, reject) => {\n                // poll every 100ms and wait that all validations are ready\n                if (this.numPendingValidations() === 0) {\n                    resolve();\n                    return;\n                }\n                const interval = setInterval(() => {\n                    if (this.numPendingValidations() === 0) {\n                        timers_1.clearInterval(interval);\n                        resolve();\n                    }\n                }, 100);\n            });\n        })\n            .then(() => {\n            // Wait for all the used resources to be freed.\n            return Promise.all(this.used.map(used => utils_1.reflect(used.promise)));\n        })\n            .then(() => {\n            // Abort all pending acquires.\n            return Promise.all(this.pendingAcquires.map(acquire => {\n                acquire.abort();\n                return utils_1.reflect(acquire.promise);\n            }));\n        })\n            .then(() => {\n            // Now we can destroy all the freed resources.\n            return Promise.all(this.free.map(free => utils_1.reflect(this._destroy(free.resource))));\n        })\n            .then(() => {\n            // Also wait rest of the pending destroys to finish\n            return Promise.all(this.pendingDestroys.map(pd => pd.promise));\n        })\n            .then(() => {\n            this.free = [];\n            this.pendingAcquires = [];\n        })).then(res => {\n            this._executeEventHandlers('poolDestroySuccess', eventId);\n            this.emitter.removeAllListeners();\n            return res;\n        });\n    }\n    on(event, listener) {\n        this.emitter.on(event, listener);\n    }\n    removeListener(event, listener) {\n        this.emitter.removeListener(event, listener);\n    }\n    removeAllListeners(event) {\n        this.emitter.removeAllListeners(event);\n    }\n    /**\n     * The most important method that is called always when resources\n     * are created / destroyed / acquired / released. In other words\n     * every time when resources are moved from used to free or vice\n     * versa.\n     *\n     * Either assigns free resources to pendingAcquires or creates new\n     * resources if there is room for it in the pool.\n     */\n    _tryAcquireOrCreate() {\n        if (this.destroyed) {\n            return;\n        }\n        if (this._hasFreeResources()) {\n            this._doAcquire();\n        }\n        else if (this._shouldCreateMoreResources()) {\n            this._doCreate();\n        }\n    }\n    _hasFreeResources() {\n        return this.free.length > 0;\n    }\n    _doAcquire() {\n        // Acquire as many pending acquires as possible concurrently\n        while (this._canAcquire()) {\n            // To allow async validation, we actually need to move free resource\n            // and pending acquire temporary from their respective arrays and depending\n            // on validation result to either leave the free resource to used resources array\n            // or destroy the free resource if validation did fail.\n            const pendingAcquire = this.pendingAcquires.shift();\n            const free = this.free.pop();\n            if (free === undefined || pendingAcquire === undefined) {\n                const errMessage = 'this.free was empty while trying to acquire resource';\n                this.log(`Tarn: ${errMessage}`, 'warn');\n                throw new Error(`Internal error, should never happen. ${errMessage}`);\n            }\n            // Make sure that pendingAcquire that is being validated is not lost and\n            // can be freed when pool is destroyed.\n            this.pendingValidations.push(pendingAcquire);\n            // Must be added here pre-emptively to prevent logic that decides\n            // if new resources are created will keep on working correctly.\n            this.used.push(free);\n            // if acquire fails also pending validation, must be aborted so that pre reserved\n            // resource will be returned to free resources immediately\n            const abortAbleValidation = new PendingOperation_1.PendingOperation(this.acquireTimeoutMillis);\n            // eslint-disable-next-line\n            pendingAcquire.promise.catch(err => {\n                abortAbleValidation.abort();\n            });\n            abortAbleValidation.promise\n                .catch(err => {\n                // There's nothing we can do here but log the error. This would otherwise\n                // leak out as an unhandled exception.\n                this.log('Tarn: resource validator threw an exception ' + err.stack, 'warn');\n                return false;\n            })\n                .then(validationSuccess => {\n                try {\n                    if (validationSuccess) {\n                        // At least one active resource exist, start reaping.\n                        this._startReaping();\n                        pendingAcquire.resolve(free.resource);\n                    }\n                    else {\n                        remove(this.used, free);\n                        this._destroy(free.resource);\n                        // is acquire was canceled, failed or timed out already\n                        // no need to return it to pending queries\n                        if (!pendingAcquire.isRejected) {\n                            this.pendingAcquires.unshift(pendingAcquire);\n                        }\n                        // Since we destroyed an invalid resource and were not able to fulfill\n                        // all the pending acquires, we may need to create new ones or at\n                        // least run this acquire loop again to verify it. But not immediately\n                        // to prevent starving event loop.\n                        setTimeout(() => {\n                            this._tryAcquireOrCreate();\n                        }, 0);\n                    }\n                }\n                finally {\n                    remove(this.pendingValidations, pendingAcquire);\n                }\n            });\n            // try to validate\n            this._validateResource(free.resource)\n                .then(validationSuccess => {\n                abortAbleValidation.resolve(validationSuccess);\n            })\n                .catch(err => {\n                abortAbleValidation.reject(err);\n            });\n        }\n    }\n    _canAcquire() {\n        return this.free.length > 0 && this.pendingAcquires.length > 0;\n    }\n    _validateResource(resource) {\n        try {\n            return Promise.resolve(this.validate(resource));\n        }\n        catch (err) {\n            // prevent leaking of sync exception\n            return Promise.reject(err);\n        }\n    }\n    _shouldCreateMoreResources() {\n        return (this.used.length + this.pendingCreates.length < this.max &&\n            this.pendingCreates.length < this.pendingAcquires.length);\n    }\n    _doCreate() {\n        const pendingAcquiresBeforeCreate = this.pendingAcquires.slice();\n        const pendingCreate = this._create();\n        pendingCreate.promise\n            .then(() => {\n            // Not returned on purpose.\n            this._tryAcquireOrCreate();\n            return null;\n        })\n            .catch(err => {\n            if (this.propagateCreateError && this.pendingAcquires.length !== 0) {\n                // If propagateCreateError is true, we don't retry the create\n                // but reject the first pending acquire immediately. Intentionally\n                // use `this.pendingAcquires` instead of `pendingAcquiresBeforeCreate`\n                // in case some acquires in pendingAcquiresBeforeCreate have already\n                // been resolved.\n                this.pendingAcquires[0].reject(err);\n            }\n            // Save the create error to all pending acquires so that we can use it\n            // as the error to reject the acquire if it times out.\n            pendingAcquiresBeforeCreate.forEach(pendingAcquire => {\n                pendingAcquire.possibleTimeoutCause = err;\n            });\n            // Not returned on purpose.\n            utils_1.delay(this.createRetryIntervalMillis).then(() => this._tryAcquireOrCreate());\n        });\n    }\n    _create() {\n        const eventId = this.eventId++;\n        this._executeEventHandlers('createRequest', eventId);\n        const pendingCreate = new PendingOperation_1.PendingOperation(this.createTimeoutMillis);\n        // If an error occurs (likely a create timeout) remove this creation from\n        // the list of pending creations so we try to create a new one.\n        pendingCreate.promise = pendingCreate.promise.catch(err => {\n            if (remove(this.pendingCreates, pendingCreate)) {\n                // TODO: figure out more consistent way for different error handlers in next rewrite\n                this._executeEventHandlers('createFail', eventId, err);\n            }\n            throw err;\n        });\n        this.pendingCreates.push(pendingCreate);\n        callbackOrPromise(this.creator)\n            .then(resource => {\n            if (pendingCreate.isRejected) {\n                this.destroyer(resource);\n                return null;\n            }\n            remove(this.pendingCreates, pendingCreate);\n            this.free.push(new Resource_1.Resource(resource));\n            // Not returned on purpose.\n            pendingCreate.resolve(resource);\n            this._executeEventHandlers('createSuccess', eventId, resource);\n            return null;\n        })\n            .catch(err => {\n            if (pendingCreate.isRejected) {\n                return null;\n            }\n            if (remove(this.pendingCreates, pendingCreate)) {\n                this._executeEventHandlers('createFail', eventId, err);\n            }\n            // Not returned on purpose.\n            pendingCreate.reject(err);\n            return null;\n        });\n        return pendingCreate;\n    }\n    _destroy(resource) {\n        const eventId = this.eventId++;\n        this._executeEventHandlers('destroyRequest', eventId, resource);\n        // this.destroyer can be both synchronous and asynchronous.\n        // so we wrap it to promise to get all exceptions through same pipeline\n        const pendingDestroy = new PendingOperation_1.PendingOperation(this.destroyTimeoutMillis);\n        const retVal = Promise.resolve().then(() => this.destroyer(resource));\n        retVal\n            .then(() => {\n            pendingDestroy.resolve(resource);\n        })\n            .catch((err) => {\n            pendingDestroy.reject(err);\n        });\n        this.pendingDestroys.push(pendingDestroy);\n        // In case of an error there's nothing we can do here but log it.\n        return pendingDestroy.promise\n            .then(res => {\n            this._executeEventHandlers('destroySuccess', eventId, resource);\n            return res;\n        })\n            .catch(err => this._logDestroyerError(eventId, resource, err))\n            .then(res => {\n            const index = this.pendingDestroys.findIndex(pd => pd === pendingDestroy);\n            this.pendingDestroys.splice(index, 1);\n            return res;\n        });\n    }\n    _logDestroyerError(eventId, resource, err) {\n        this._executeEventHandlers('destroyFail', eventId, resource, err);\n        this.log('Tarn: resource destroyer threw an exception ' + err.stack, 'warn');\n    }\n    _startReaping() {\n        if (!this.interval) {\n            this._executeEventHandlers('startReaping');\n            this.interval = setInterval(() => this.check(), this.reapIntervalMillis);\n        }\n    }\n    _stopReaping() {\n        if (this.interval !== null) {\n            this._executeEventHandlers('stopReaping');\n            timers_1.clearInterval(this.interval);\n        }\n        this.interval = null;\n    }\n    _executeEventHandlers(eventName, ...args) {\n        const listeners = this.emitter.listeners(eventName);\n        // just calling .emit() would stop running rest of the listeners if one them fails\n        listeners.forEach(listener => {\n            try {\n                listener(...args);\n            }\n            catch (err) {\n                // There's nothing we can do here but log the error. This would otherwise\n                // leak out as an unhandled exception.\n                this.log(`Tarn: event handler \"${eventName}\" threw an exception ${err.stack}`, 'warn');\n            }\n        });\n    }\n}\nexports.Pool = Pool;\nfunction remove(arr, item) {\n    const idx = arr.indexOf(item);\n    if (idx === -1) {\n        return false;\n    }\n    else {\n        arr.splice(idx, 1);\n        return true;\n    }\n}\nfunction callbackOrPromise(func) {\n    return new Promise((resolve, reject) => {\n        const callback = (err, resource) => {\n            if (err) {\n                reject(err);\n            }\n            else {\n                resolve(resource);\n            }\n        };\n        utils_1.tryPromise(() => func(callback))\n            .then(res => {\n            // If the result is falsy, we assume that the callback will\n            // be called instead of interpreting the falsy value as a\n            // result value.\n            if (res) {\n                resolve(res);\n            }\n        })\n            .catch(err => {\n            reject(err);\n        });\n    });\n}\n"]},"metadata":{},"sourceType":"script"}