{"ast":null,"code":"// SQLite3 Query Builder & Compiler\nconst constant = require('lodash/constant');\n\nconst each = require('lodash/each');\n\nconst identity = require('lodash/identity');\n\nconst isEmpty = require('lodash/isEmpty');\n\nconst reduce = require('lodash/reduce');\n\nconst QueryCompiler = require('../../../query/querycompiler');\n\nconst noop = require('../../../util/noop');\n\nconst {\n  isString\n} = require('../../../util/is');\n\nconst {\n  wrapString\n} = require('../../../formatter/wrappingFormatter');\n\nconst emptyStr = constant('');\n\nclass QueryCompiler_SQLite3 extends QueryCompiler {\n  constructor(client, builder, formatter) {\n    super(client, builder, formatter);\n    const {\n      returning\n    } = this.single;\n\n    if (returning) {\n      this.client.logger.warn('.returning() is not supported by sqlite3 and will not have any effect.');\n    } // The locks are not applicable in SQLite3\n\n\n    this.forShare = emptyStr;\n    this.forUpdate = emptyStr;\n  } // SQLite requires us to build the multi-row insert as a listing of select with\n  // unions joining them together. So we'll build out this list of columns and\n  // then join them all together with select unions to complete the queries.\n\n\n  insert() {\n    const insertValues = this.single.insert || [];\n    let sql = this.with() + `insert into ${this.tableName} `;\n\n    if (Array.isArray(insertValues)) {\n      if (insertValues.length === 0) {\n        return '';\n      } else if (insertValues.length === 1 && insertValues[0] && isEmpty(insertValues[0])) {\n        return sql + this._emptyInsertValue;\n      }\n    } else if (typeof insertValues === 'object' && isEmpty(insertValues)) {\n      return sql + this._emptyInsertValue;\n    }\n\n    const insertData = this._prepInsert(insertValues);\n\n    if (isString(insertData)) {\n      return sql + insertData;\n    }\n\n    if (insertData.columns.length === 0) {\n      return '';\n    }\n\n    sql += `(${this.formatter.columnize(insertData.columns)})`; // backwards compatible error\n\n    if (this.client.valueForUndefined !== null) {\n      insertData.values.forEach(bindings => {\n        each(bindings, binding => {\n          if (binding === undefined) throw new TypeError('`sqlite` does not support inserting default values. Specify ' + 'values explicitly or use the `useNullAsDefault` config flag. ' + '(see docs http://knexjs.org/#Builder-insert).');\n        });\n      });\n    }\n\n    if (insertData.values.length === 1) {\n      const parameters = this.client.parameterize(insertData.values[0], this.client.valueForUndefined, this.builder, this.bindingsHolder);\n      sql += ` values (${parameters})`;\n      const {\n        onConflict,\n        ignore,\n        merge\n      } = this.single;\n      if (onConflict && ignore) sql += this._ignore(onConflict);else if (onConflict && merge) {\n        sql += this._merge(merge.updates, onConflict, insertValues);\n        const wheres = this.where();\n        if (wheres) sql += ` ${wheres}`;\n      }\n      return sql;\n    }\n\n    const blocks = [];\n    let i = -1;\n\n    while (++i < insertData.values.length) {\n      let i2 = -1;\n      const block = blocks[i] = [];\n      let current = insertData.values[i];\n      current = current === undefined ? this.client.valueForUndefined : current;\n\n      while (++i2 < insertData.columns.length) {\n        block.push(this.client.alias(this.client.parameter(current[i2], this.builder, this.bindingsHolder), this.formatter.wrap(insertData.columns[i2])));\n      }\n\n      blocks[i] = block.join(', ');\n    }\n\n    sql += ' select ' + blocks.join(' union all select ');\n    const {\n      onConflict,\n      ignore,\n      merge\n    } = this.single;\n    if (onConflict && ignore) sql += ' where true' + this._ignore(onConflict);else if (onConflict && merge) {\n      sql += ' where true' + this._merge(merge.updates, onConflict, insertValues);\n    }\n    return sql;\n  }\n\n  _ignore(columns) {\n    return ` on conflict (${this.formatter.columnize(columns)}) do nothing`;\n  }\n\n  _merge(updates, columns, insert) {\n    let sql = ` on conflict (${this.formatter.columnize(columns)}) do update set `;\n\n    if (updates && Array.isArray(updates)) {\n      sql += updates.map(column => wrapString(column.split('.').pop(), this.formatter.builder, this.client, this.formatter)).map(column => `${column} = excluded.${column}`).join(', ');\n      return sql;\n    } else if (updates && typeof updates === 'object') {\n      const updateData = this._prepUpdate(updates);\n\n      if (typeof updateData === 'string') {\n        sql += updateData;\n      } else {\n        sql += updateData.join(',');\n      }\n\n      return sql;\n    } else {\n      const insertData = this._prepInsert(insert);\n\n      if (typeof insertData === 'string') {\n        throw new Error('If using merge with a raw insert query, then updates must be provided');\n      }\n\n      sql += insertData.columns.map(column => wrapString(column.split('.').pop(), this.builder, this.client)).map(column => `${column} = excluded.${column}`).join(', ');\n      return sql;\n    }\n  } // Compile a truncate table statement into SQL.\n\n\n  truncate() {\n    const {\n      table\n    } = this.single;\n    return {\n      sql: `delete from ${this.tableName}`,\n\n      output() {\n        return this.query({\n          sql: `delete from sqlite_sequence where name = '${table}'`\n        }).catch(noop);\n      }\n\n    };\n  } // Compiles a `columnInfo` query\n\n\n  columnInfo() {\n    const column = this.single.columnInfo; // The user may have specified a custom wrapIdentifier function in the config. We\n    // need to run the identifiers through that function, but not format them as\n    // identifiers otherwise.\n\n    const table = this.client.customWrapIdentifier(this.single.table, identity);\n    return {\n      sql: `PRAGMA table_info(\\`${table}\\`)`,\n\n      output(resp) {\n        const maxLengthRegex = /.*\\((\\d+)\\)/;\n        const out = reduce(resp, function (columns, val) {\n          let {\n            type\n          } = val;\n          let maxLength = type.match(maxLengthRegex);\n\n          if (maxLength) {\n            maxLength = maxLength[1];\n          }\n\n          type = maxLength ? type.split('(')[0] : type;\n          columns[val.name] = {\n            type: type.toLowerCase(),\n            maxLength,\n            nullable: !val.notnull,\n            defaultValue: val.dflt_value\n          };\n          return columns;\n        }, {});\n        return column && out[column] || out;\n      }\n\n    };\n  }\n\n  limit() {\n    const noLimit = !this.single.limit && this.single.limit !== 0;\n    if (noLimit && !this.single.offset) return ''; // Workaround for offset only,\n    // see http://stackoverflow.com/questions/10491492/sqllite-with-skip-offset-only-not-limit\n\n    return `limit ${this.client.parameter(noLimit ? -1 : this.single.limit, this.builder, this.bindingsHolder)}`;\n  }\n\n}\n\nmodule.exports = QueryCompiler_SQLite3;","map":{"version":3,"sources":["/home/rosiane/Projeto-completo/back/node_modules/knex/lib/dialects/sqlite3/query/sqlite-querycompiler.js"],"names":["constant","require","each","identity","isEmpty","reduce","QueryCompiler","noop","isString","wrapString","emptyStr","QueryCompiler_SQLite3","constructor","client","builder","formatter","returning","single","logger","warn","forShare","forUpdate","insert","insertValues","sql","with","tableName","Array","isArray","length","_emptyInsertValue","insertData","_prepInsert","columns","columnize","valueForUndefined","values","forEach","bindings","binding","undefined","TypeError","parameters","parameterize","bindingsHolder","onConflict","ignore","merge","_ignore","_merge","updates","wheres","where","blocks","i","i2","block","current","push","alias","parameter","wrap","join","map","column","split","pop","updateData","_prepUpdate","Error","truncate","table","output","query","catch","columnInfo","customWrapIdentifier","resp","maxLengthRegex","out","val","type","maxLength","match","name","toLowerCase","nullable","notnull","defaultValue","dflt_value","limit","noLimit","offset","module","exports"],"mappings":"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","sourcesContent":["// SQLite3 Query Builder & Compiler\n\nconst constant = require('lodash/constant');\nconst each = require('lodash/each');\nconst identity = require('lodash/identity');\nconst isEmpty = require('lodash/isEmpty');\nconst reduce = require('lodash/reduce');\n\nconst QueryCompiler = require('../../../query/querycompiler');\nconst noop = require('../../../util/noop');\nconst { isString } = require('../../../util/is');\nconst { wrapString } = require('../../../formatter/wrappingFormatter');\n\nconst emptyStr = constant('');\n\nclass QueryCompiler_SQLite3 extends QueryCompiler {\n  constructor(client, builder, formatter) {\n    super(client, builder, formatter);\n\n    const { returning } = this.single;\n\n    if (returning) {\n      this.client.logger.warn(\n        '.returning() is not supported by sqlite3 and will not have any effect.'\n      );\n    }\n\n    // The locks are not applicable in SQLite3\n    this.forShare = emptyStr;\n    this.forUpdate = emptyStr;\n  }\n\n  // SQLite requires us to build the multi-row insert as a listing of select with\n  // unions joining them together. So we'll build out this list of columns and\n  // then join them all together with select unions to complete the queries.\n  insert() {\n    const insertValues = this.single.insert || [];\n    let sql = this.with() + `insert into ${this.tableName} `;\n\n    if (Array.isArray(insertValues)) {\n      if (insertValues.length === 0) {\n        return '';\n      } else if (\n        insertValues.length === 1 &&\n        insertValues[0] &&\n        isEmpty(insertValues[0])\n      ) {\n        return sql + this._emptyInsertValue;\n      }\n    } else if (typeof insertValues === 'object' && isEmpty(insertValues)) {\n      return sql + this._emptyInsertValue;\n    }\n\n    const insertData = this._prepInsert(insertValues);\n\n    if (isString(insertData)) {\n      return sql + insertData;\n    }\n\n    if (insertData.columns.length === 0) {\n      return '';\n    }\n\n    sql += `(${this.formatter.columnize(insertData.columns)})`;\n\n    // backwards compatible error\n    if (this.client.valueForUndefined !== null) {\n      insertData.values.forEach((bindings) => {\n        each(bindings, (binding) => {\n          if (binding === undefined)\n            throw new TypeError(\n              '`sqlite` does not support inserting default values. Specify ' +\n                'values explicitly or use the `useNullAsDefault` config flag. ' +\n                '(see docs http://knexjs.org/#Builder-insert).'\n            );\n        });\n      });\n    }\n\n    if (insertData.values.length === 1) {\n      const parameters = this.client.parameterize(\n        insertData.values[0],\n        this.client.valueForUndefined,\n        this.builder,\n        this.bindingsHolder\n      );\n      sql += ` values (${parameters})`;\n\n      const { onConflict, ignore, merge } = this.single;\n      if (onConflict && ignore) sql += this._ignore(onConflict);\n      else if (onConflict && merge) {\n        sql += this._merge(merge.updates, onConflict, insertValues);\n        const wheres = this.where();\n        if (wheres) sql += ` ${wheres}`;\n      }\n\n      return sql;\n    }\n\n    const blocks = [];\n    let i = -1;\n    while (++i < insertData.values.length) {\n      let i2 = -1;\n      const block = (blocks[i] = []);\n      let current = insertData.values[i];\n      current = current === undefined ? this.client.valueForUndefined : current;\n      while (++i2 < insertData.columns.length) {\n        block.push(\n          this.client.alias(\n            this.client.parameter(\n              current[i2],\n              this.builder,\n              this.bindingsHolder\n            ),\n            this.formatter.wrap(insertData.columns[i2])\n          )\n        );\n      }\n      blocks[i] = block.join(', ');\n    }\n    sql += ' select ' + blocks.join(' union all select ');\n\n    const { onConflict, ignore, merge } = this.single;\n    if (onConflict && ignore) sql += ' where true' + this._ignore(onConflict);\n    else if (onConflict && merge) {\n      sql +=\n        ' where true' + this._merge(merge.updates, onConflict, insertValues);\n    }\n\n    return sql;\n  }\n\n  _ignore(columns) {\n    return ` on conflict (${this.formatter.columnize(columns)}) do nothing`;\n  }\n\n  _merge(updates, columns, insert) {\n    let sql = ` on conflict (${this.formatter.columnize(\n      columns\n    )}) do update set `;\n    if (updates && Array.isArray(updates)) {\n      sql += updates\n        .map((column) =>\n          wrapString(\n            column.split('.').pop(),\n            this.formatter.builder,\n            this.client,\n            this.formatter\n          )\n        )\n        .map((column) => `${column} = excluded.${column}`)\n        .join(', ');\n\n      return sql;\n    } else if (updates && typeof updates === 'object') {\n      const updateData = this._prepUpdate(updates);\n      if (typeof updateData === 'string') {\n        sql += updateData;\n      } else {\n        sql += updateData.join(',');\n      }\n\n      return sql;\n    } else {\n      const insertData = this._prepInsert(insert);\n      if (typeof insertData === 'string') {\n        throw new Error(\n          'If using merge with a raw insert query, then updates must be provided'\n        );\n      }\n\n      sql += insertData.columns\n        .map((column) =>\n          wrapString(column.split('.').pop(), this.builder, this.client)\n        )\n        .map((column) => `${column} = excluded.${column}`)\n        .join(', ');\n\n      return sql;\n    }\n  }\n\n  // Compile a truncate table statement into SQL.\n  truncate() {\n    const { table } = this.single;\n    return {\n      sql: `delete from ${this.tableName}`,\n      output() {\n        return this.query({\n          sql: `delete from sqlite_sequence where name = '${table}'`,\n        }).catch(noop);\n      },\n    };\n  }\n\n  // Compiles a `columnInfo` query\n  columnInfo() {\n    const column = this.single.columnInfo;\n\n    // The user may have specified a custom wrapIdentifier function in the config. We\n    // need to run the identifiers through that function, but not format them as\n    // identifiers otherwise.\n    const table = this.client.customWrapIdentifier(this.single.table, identity);\n\n    return {\n      sql: `PRAGMA table_info(\\`${table}\\`)`,\n      output(resp) {\n        const maxLengthRegex = /.*\\((\\d+)\\)/;\n        const out = reduce(\n          resp,\n          function (columns, val) {\n            let { type } = val;\n            let maxLength = type.match(maxLengthRegex);\n            if (maxLength) {\n              maxLength = maxLength[1];\n            }\n            type = maxLength ? type.split('(')[0] : type;\n            columns[val.name] = {\n              type: type.toLowerCase(),\n              maxLength,\n              nullable: !val.notnull,\n              defaultValue: val.dflt_value,\n            };\n            return columns;\n          },\n          {}\n        );\n        return (column && out[column]) || out;\n      },\n    };\n  }\n\n  limit() {\n    const noLimit = !this.single.limit && this.single.limit !== 0;\n    if (noLimit && !this.single.offset) return '';\n\n    // Workaround for offset only,\n    // see http://stackoverflow.com/questions/10491492/sqllite-with-skip-offset-only-not-limit\n    return `limit ${this.client.parameter(\n      noLimit ? -1 : this.single.limit,\n      this.builder,\n      this.bindingsHolder\n    )}`;\n  }\n}\n\nmodule.exports = QueryCompiler_SQLite3;\n"]},"metadata":{},"sourceType":"script"}