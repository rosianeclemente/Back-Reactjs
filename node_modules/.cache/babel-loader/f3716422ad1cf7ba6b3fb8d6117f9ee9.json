{"ast":null,"code":"// TableBuilder\n// Takes the function passed to the \"createTable\" or \"table/editTable\"\n// functions and calls it with the \"TableBuilder\" as both the context and\n// the first argument. Inside this function we can specify what happens to the\n// method, pushing everything we want to do onto the \"allStatements\" array,\n// which is then compiled into sql.\n// ------\nconst each = require('lodash/each');\n\nconst extend = require('lodash/extend');\n\nconst toArray = require('lodash/toArray');\n\nconst helpers = require('../util/helpers');\n\nconst {\n  isString,\n  isFunction\n} = require('../util/is');\n\nclass TableBuilder {\n  constructor(client, method, tableName, fn) {\n    this.client = client;\n    this._fn = fn;\n    this._method = method;\n    this._schemaName = undefined;\n    this._tableName = tableName;\n    this._statements = [];\n    this._single = {};\n\n    if (!isFunction(this._fn)) {\n      throw new TypeError('A callback function must be supplied to calls against `.createTable` ' + 'and `.table`');\n    }\n  }\n\n  setSchema(schemaName) {\n    this._schemaName = schemaName;\n  } // Convert the current tableBuilder object \"toSQL\"\n  // giving us additional methods if we're altering\n  // rather than creating the table.\n\n\n  toSQL() {\n    if (this._method === 'alter') {\n      extend(this, AlterMethods);\n    }\n\n    this._fn.call(this, this);\n\n    return this.client.tableCompiler(this).toSQL();\n  } // The \"timestamps\" call is really just sets the `created_at` and `updated_at` columns.\n\n\n  timestamps() {\n    const method = arguments[0] === true ? 'timestamp' : 'datetime';\n    const createdAt = this[method]('created_at');\n    const updatedAt = this[method]('updated_at');\n\n    if (arguments[1] === true) {\n      const now = this.client.raw('CURRENT_TIMESTAMP');\n      createdAt.notNullable().defaultTo(now);\n      updatedAt.notNullable().defaultTo(now);\n    }\n\n    return;\n  } // Set the comment value for a table, they're only allowed to be called\n  // once per table.\n\n\n  comment(value) {\n    if (typeof value !== 'string') {\n      throw new TypeError('Table comment must be string');\n    }\n\n    this._single.comment = value;\n  } // Set a foreign key on the table, calling\n  // `table.foreign('column_name').references('column').on('table').onDelete()...\n  // Also called from the ColumnBuilder context when chaining.\n\n\n  foreign(column, keyName) {\n    const foreignData = {\n      column: column,\n      keyName: keyName\n    };\n\n    this._statements.push({\n      grouping: 'alterTable',\n      method: 'foreign',\n      args: [foreignData]\n    });\n\n    let returnObj = {\n      references(tableColumn) {\n        let pieces;\n\n        if (isString(tableColumn)) {\n          pieces = tableColumn.split('.');\n        }\n\n        if (!pieces || pieces.length === 1) {\n          foreignData.references = pieces ? pieces[0] : tableColumn;\n          return {\n            on(tableName) {\n              if (typeof tableName !== 'string') {\n                throw new TypeError(`Expected tableName to be a string, got: ${typeof tableName}`);\n              }\n\n              foreignData.inTable = tableName;\n              return returnObj;\n            },\n\n            inTable() {\n              return this.on.apply(this, arguments);\n            }\n\n          };\n        }\n\n        foreignData.inTable = pieces[0];\n        foreignData.references = pieces[1];\n        return returnObj;\n      },\n\n      withKeyName(keyName) {\n        foreignData.keyName = keyName;\n        return returnObj;\n      },\n\n      onUpdate(statement) {\n        foreignData.onUpdate = statement;\n        return returnObj;\n      },\n\n      onDelete(statement) {\n        foreignData.onDelete = statement;\n        return returnObj;\n      },\n\n      _columnBuilder(builder) {\n        extend(builder, returnObj);\n        returnObj = builder;\n        return builder;\n      }\n\n    };\n    return returnObj;\n  }\n\n}\n\n[// Each of the index methods can be called individually, with the\n// column name to be used, e.g. table.unique('column').\n'index', 'primary', 'unique', // Key specific\n'dropPrimary', 'dropUnique', 'dropIndex', 'dropForeign'].forEach(method => {\n  TableBuilder.prototype[method] = function () {\n    this._statements.push({\n      grouping: 'alterTable',\n      method,\n      args: toArray(arguments)\n    });\n\n    return this;\n  };\n}); // Warn for dialect-specific table methods, since that's the\n// only time these are supported.\n\nconst specialMethods = {\n  mysql: ['engine', 'charset', 'collate'],\n  postgresql: ['inherits']\n};\neach(specialMethods, function (methods, dialect) {\n  methods.forEach(function (method) {\n    TableBuilder.prototype[method] = function (value) {\n      if (this.client.dialect !== dialect) {\n        throw new Error(`Knex only supports ${method} statement with ${dialect}.`);\n      }\n\n      if (this._method === 'alter') {\n        throw new Error(`Knex does not support altering the ${method} outside of create ` + `table, please use knex.raw statement.`);\n      }\n\n      this._single[method] = value;\n    };\n  });\n});\nhelpers.addQueryContext(TableBuilder); // Each of the column types that we can add, we create a new ColumnBuilder\n// instance and push it onto the statements array.\n\nconst columnTypes = [// Numeric\n'tinyint', 'smallint', 'mediumint', 'int', 'bigint', 'decimal', 'float', 'double', 'real', 'bit', 'boolean', 'serial', // Date / Time\n'date', 'datetime', 'timestamp', 'time', 'year', // String\n'char', 'varchar', 'tinytext', 'tinyText', 'text', 'mediumtext', 'mediumText', 'longtext', 'longText', 'binary', 'varbinary', 'tinyblob', 'tinyBlob', 'mediumblob', 'mediumBlob', 'blob', 'longblob', 'longBlob', 'enum', 'set', // Increments, Aliases, and Additional\n'bool', 'dateTime', 'increments', 'bigincrements', 'bigIncrements', 'integer', 'biginteger', 'bigInteger', 'string', 'json', 'jsonb', 'uuid', 'enu', 'specificType']; // For each of the column methods, create a new \"ColumnBuilder\" interface,\n// push it onto the \"allStatements\" stack, and then return the interface,\n// with which we can add indexes, etc.\n\ncolumnTypes.forEach(type => {\n  TableBuilder.prototype[type] = function () {\n    const args = toArray(arguments);\n    const builder = this.client.columnBuilder(this, type, args);\n\n    this._statements.push({\n      grouping: 'columns',\n      builder\n    });\n\n    return builder;\n  };\n});\nconst AlterMethods = {\n  // Renames the current column `from` the current\n  // TODO: this.column(from).rename(to)\n  renameColumn(from, to) {\n    this._statements.push({\n      grouping: 'alterTable',\n      method: 'renameColumn',\n      args: [from, to]\n    });\n\n    return this;\n  },\n\n  dropTimestamps() {\n    return this.dropColumns(['created_at', 'updated_at']);\n  } // TODO: changeType\n\n\n}; // Drop a column from the current table.\n// TODO: Enable this.column(columnName).drop();\n\nAlterMethods.dropColumn = AlterMethods.dropColumns = function () {\n  this._statements.push({\n    grouping: 'alterTable',\n    method: 'dropColumn',\n    args: toArray(arguments)\n  });\n\n  return this;\n};\n\nmodule.exports = TableBuilder;","map":{"version":3,"sources":["/home/rosiane/Projeto-completo/back/node_modules/knex/lib/schema/tablebuilder.js"],"names":["each","require","extend","toArray","helpers","isString","isFunction","TableBuilder","constructor","client","method","tableName","fn","_fn","_method","_schemaName","undefined","_tableName","_statements","_single","TypeError","setSchema","schemaName","toSQL","AlterMethods","call","tableCompiler","timestamps","arguments","createdAt","updatedAt","now","raw","notNullable","defaultTo","comment","value","foreign","column","keyName","foreignData","push","grouping","args","returnObj","references","tableColumn","pieces","split","length","on","inTable","apply","withKeyName","onUpdate","statement","onDelete","_columnBuilder","builder","forEach","prototype","specialMethods","mysql","postgresql","methods","dialect","Error","addQueryContext","columnTypes","type","columnBuilder","renameColumn","from","to","dropTimestamps","dropColumns","dropColumn","module","exports"],"mappings":"AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,IAAI,GAAGC,OAAO,CAAC,aAAD,CAApB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,eAAD,CAAtB;;AACA,MAAME,OAAO,GAAGF,OAAO,CAAC,gBAAD,CAAvB;;AACA,MAAMG,OAAO,GAAGH,OAAO,CAAC,iBAAD,CAAvB;;AACA,MAAM;AAAEI,EAAAA,QAAF;AAAYC,EAAAA;AAAZ,IAA2BL,OAAO,CAAC,YAAD,CAAxC;;AAEA,MAAMM,YAAN,CAAmB;AACjBC,EAAAA,WAAW,CAACC,MAAD,EAASC,MAAT,EAAiBC,SAAjB,EAA4BC,EAA5B,EAAgC;AACzC,SAAKH,MAAL,GAAcA,MAAd;AACA,SAAKI,GAAL,GAAWD,EAAX;AACA,SAAKE,OAAL,GAAeJ,MAAf;AACA,SAAKK,WAAL,GAAmBC,SAAnB;AACA,SAAKC,UAAL,GAAkBN,SAAlB;AACA,SAAKO,WAAL,GAAmB,EAAnB;AACA,SAAKC,OAAL,GAAe,EAAf;;AAEA,QAAI,CAACb,UAAU,CAAC,KAAKO,GAAN,CAAf,EAA2B;AACzB,YAAM,IAAIO,SAAJ,CACJ,0EACE,cAFE,CAAN;AAID;AACF;;AAEDC,EAAAA,SAAS,CAACC,UAAD,EAAa;AACpB,SAAKP,WAAL,GAAmBO,UAAnB;AACD,GApBgB,CAsBjB;AACA;AACA;;;AACAC,EAAAA,KAAK,GAAG;AACN,QAAI,KAAKT,OAAL,KAAiB,OAArB,EAA8B;AAC5BZ,MAAAA,MAAM,CAAC,IAAD,EAAOsB,YAAP,CAAN;AACD;;AACD,SAAKX,GAAL,CAASY,IAAT,CAAc,IAAd,EAAoB,IAApB;;AACA,WAAO,KAAKhB,MAAL,CAAYiB,aAAZ,CAA0B,IAA1B,EAAgCH,KAAhC,EAAP;AACD,GA/BgB,CAiCjB;;;AACAI,EAAAA,UAAU,GAAG;AACX,UAAMjB,MAAM,GAAGkB,SAAS,CAAC,CAAD,CAAT,KAAiB,IAAjB,GAAwB,WAAxB,GAAsC,UAArD;AACA,UAAMC,SAAS,GAAG,KAAKnB,MAAL,EAAa,YAAb,CAAlB;AACA,UAAMoB,SAAS,GAAG,KAAKpB,MAAL,EAAa,YAAb,CAAlB;;AACA,QAAIkB,SAAS,CAAC,CAAD,CAAT,KAAiB,IAArB,EAA2B;AACzB,YAAMG,GAAG,GAAG,KAAKtB,MAAL,CAAYuB,GAAZ,CAAgB,mBAAhB,CAAZ;AACAH,MAAAA,SAAS,CAACI,WAAV,GAAwBC,SAAxB,CAAkCH,GAAlC;AACAD,MAAAA,SAAS,CAACG,WAAV,GAAwBC,SAAxB,CAAkCH,GAAlC;AACD;;AACD;AACD,GA5CgB,CA8CjB;AACA;;;AACAI,EAAAA,OAAO,CAACC,KAAD,EAAQ;AACb,QAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC7B,YAAM,IAAIhB,SAAJ,CAAc,8BAAd,CAAN;AACD;;AACD,SAAKD,OAAL,CAAagB,OAAb,GAAuBC,KAAvB;AACD,GArDgB,CAuDjB;AACA;AACA;;;AACAC,EAAAA,OAAO,CAACC,MAAD,EAASC,OAAT,EAAkB;AACvB,UAAMC,WAAW,GAAG;AAAEF,MAAAA,MAAM,EAAEA,MAAV;AAAkBC,MAAAA,OAAO,EAAEA;AAA3B,KAApB;;AACA,SAAKrB,WAAL,CAAiBuB,IAAjB,CAAsB;AACpBC,MAAAA,QAAQ,EAAE,YADU;AAEpBhC,MAAAA,MAAM,EAAE,SAFY;AAGpBiC,MAAAA,IAAI,EAAE,CAACH,WAAD;AAHc,KAAtB;;AAKA,QAAII,SAAS,GAAG;AACdC,MAAAA,UAAU,CAACC,WAAD,EAAc;AACtB,YAAIC,MAAJ;;AACA,YAAI1C,QAAQ,CAACyC,WAAD,CAAZ,EAA2B;AACzBC,UAAAA,MAAM,GAAGD,WAAW,CAACE,KAAZ,CAAkB,GAAlB,CAAT;AACD;;AACD,YAAI,CAACD,MAAD,IAAWA,MAAM,CAACE,MAAP,KAAkB,CAAjC,EAAoC;AAClCT,UAAAA,WAAW,CAACK,UAAZ,GAAyBE,MAAM,GAAGA,MAAM,CAAC,CAAD,CAAT,GAAeD,WAA9C;AACA,iBAAO;AACLI,YAAAA,EAAE,CAACvC,SAAD,EAAY;AACZ,kBAAI,OAAOA,SAAP,KAAqB,QAAzB,EAAmC;AACjC,sBAAM,IAAIS,SAAJ,CACH,2CAA0C,OAAOT,SAAU,EADxD,CAAN;AAGD;;AACD6B,cAAAA,WAAW,CAACW,OAAZ,GAAsBxC,SAAtB;AACA,qBAAOiC,SAAP;AACD,aATI;;AAULO,YAAAA,OAAO,GAAG;AACR,qBAAO,KAAKD,EAAL,CAAQE,KAAR,CAAc,IAAd,EAAoBxB,SAApB,CAAP;AACD;;AAZI,WAAP;AAcD;;AACDY,QAAAA,WAAW,CAACW,OAAZ,GAAsBJ,MAAM,CAAC,CAAD,CAA5B;AACAP,QAAAA,WAAW,CAACK,UAAZ,GAAyBE,MAAM,CAAC,CAAD,CAA/B;AACA,eAAOH,SAAP;AACD,OA1Ba;;AA2BdS,MAAAA,WAAW,CAACd,OAAD,EAAU;AACnBC,QAAAA,WAAW,CAACD,OAAZ,GAAsBA,OAAtB;AACA,eAAOK,SAAP;AACD,OA9Ba;;AA+BdU,MAAAA,QAAQ,CAACC,SAAD,EAAY;AAClBf,QAAAA,WAAW,CAACc,QAAZ,GAAuBC,SAAvB;AACA,eAAOX,SAAP;AACD,OAlCa;;AAmCdY,MAAAA,QAAQ,CAACD,SAAD,EAAY;AAClBf,QAAAA,WAAW,CAACgB,QAAZ,GAAuBD,SAAvB;AACA,eAAOX,SAAP;AACD,OAtCa;;AAuCda,MAAAA,cAAc,CAACC,OAAD,EAAU;AACtBxD,QAAAA,MAAM,CAACwD,OAAD,EAAUd,SAAV,CAAN;AACAA,QAAAA,SAAS,GAAGc,OAAZ;AACA,eAAOA,OAAP;AACD;;AA3Ca,KAAhB;AA6CA,WAAOd,SAAP;AACD;;AA/GgB;;AAkHnB,CACE;AACA;AACA,OAHF,EAIE,SAJF,EAKE,QALF,EAOE;AACA,aARF,EASE,YATF,EAUE,WAVF,EAWE,aAXF,EAYEe,OAZF,CAYWjD,MAAD,IAAY;AACpBH,EAAAA,YAAY,CAACqD,SAAb,CAAuBlD,MAAvB,IAAiC,YAAY;AAC3C,SAAKQ,WAAL,CAAiBuB,IAAjB,CAAsB;AACpBC,MAAAA,QAAQ,EAAE,YADU;AAEpBhC,MAAAA,MAFoB;AAGpBiC,MAAAA,IAAI,EAAExC,OAAO,CAACyB,SAAD;AAHO,KAAtB;;AAKA,WAAO,IAAP;AACD,GAPD;AAQD,CArBD,E,CAuBA;AACA;;AACA,MAAMiC,cAAc,GAAG;AACrBC,EAAAA,KAAK,EAAE,CAAC,QAAD,EAAW,SAAX,EAAsB,SAAtB,CADc;AAErBC,EAAAA,UAAU,EAAE,CAAC,UAAD;AAFS,CAAvB;AAIA/D,IAAI,CAAC6D,cAAD,EAAiB,UAAUG,OAAV,EAAmBC,OAAnB,EAA4B;AAC/CD,EAAAA,OAAO,CAACL,OAAR,CAAgB,UAAUjD,MAAV,EAAkB;AAChCH,IAAAA,YAAY,CAACqD,SAAb,CAAuBlD,MAAvB,IAAiC,UAAU0B,KAAV,EAAiB;AAChD,UAAI,KAAK3B,MAAL,CAAYwD,OAAZ,KAAwBA,OAA5B,EAAqC;AACnC,cAAM,IAAIC,KAAJ,CACH,sBAAqBxD,MAAO,mBAAkBuD,OAAQ,GADnD,CAAN;AAGD;;AACD,UAAI,KAAKnD,OAAL,KAAiB,OAArB,EAA8B;AAC5B,cAAM,IAAIoD,KAAJ,CACH,sCAAqCxD,MAAO,qBAA7C,GACG,uCAFC,CAAN;AAID;;AACD,WAAKS,OAAL,CAAaT,MAAb,IAAuB0B,KAAvB;AACD,KAbD;AAcD,GAfD;AAgBD,CAjBG,CAAJ;AAmBAhC,OAAO,CAAC+D,eAAR,CAAwB5D,YAAxB,E,CAEA;AACA;;AACA,MAAM6D,WAAW,GAAG,CAClB;AACA,SAFkB,EAGlB,UAHkB,EAIlB,WAJkB,EAKlB,KALkB,EAMlB,QANkB,EAOlB,SAPkB,EAQlB,OARkB,EASlB,QATkB,EAUlB,MAVkB,EAWlB,KAXkB,EAYlB,SAZkB,EAalB,QAbkB,EAelB;AACA,MAhBkB,EAiBlB,UAjBkB,EAkBlB,WAlBkB,EAmBlB,MAnBkB,EAoBlB,MApBkB,EAsBlB;AACA,MAvBkB,EAwBlB,SAxBkB,EAyBlB,UAzBkB,EA0BlB,UA1BkB,EA2BlB,MA3BkB,EA4BlB,YA5BkB,EA6BlB,YA7BkB,EA8BlB,UA9BkB,EA+BlB,UA/BkB,EAgClB,QAhCkB,EAiClB,WAjCkB,EAkClB,UAlCkB,EAmClB,UAnCkB,EAoClB,YApCkB,EAqClB,YArCkB,EAsClB,MAtCkB,EAuClB,UAvCkB,EAwClB,UAxCkB,EAyClB,MAzCkB,EA0ClB,KA1CkB,EA4ClB;AACA,MA7CkB,EA8ClB,UA9CkB,EA+ClB,YA/CkB,EAgDlB,eAhDkB,EAiDlB,eAjDkB,EAkDlB,SAlDkB,EAmDlB,YAnDkB,EAoDlB,YApDkB,EAqDlB,QArDkB,EAsDlB,MAtDkB,EAuDlB,OAvDkB,EAwDlB,MAxDkB,EAyDlB,KAzDkB,EA0DlB,cA1DkB,CAApB,C,CA6DA;AACA;AACA;;AACAA,WAAW,CAACT,OAAZ,CAAqBU,IAAD,IAAU;AAC5B9D,EAAAA,YAAY,CAACqD,SAAb,CAAuBS,IAAvB,IAA+B,YAAY;AACzC,UAAM1B,IAAI,GAAGxC,OAAO,CAACyB,SAAD,CAApB;AACA,UAAM8B,OAAO,GAAG,KAAKjD,MAAL,CAAY6D,aAAZ,CAA0B,IAA1B,EAAgCD,IAAhC,EAAsC1B,IAAtC,CAAhB;;AACA,SAAKzB,WAAL,CAAiBuB,IAAjB,CAAsB;AACpBC,MAAAA,QAAQ,EAAE,SADU;AAEpBgB,MAAAA;AAFoB,KAAtB;;AAIA,WAAOA,OAAP;AACD,GARD;AASD,CAVD;AAYA,MAAMlC,YAAY,GAAG;AACnB;AACA;AACA+C,EAAAA,YAAY,CAACC,IAAD,EAAOC,EAAP,EAAW;AACrB,SAAKvD,WAAL,CAAiBuB,IAAjB,CAAsB;AACpBC,MAAAA,QAAQ,EAAE,YADU;AAEpBhC,MAAAA,MAAM,EAAE,cAFY;AAGpBiC,MAAAA,IAAI,EAAE,CAAC6B,IAAD,EAAOC,EAAP;AAHc,KAAtB;;AAKA,WAAO,IAAP;AACD,GAVkB;;AAYnBC,EAAAA,cAAc,GAAG;AACf,WAAO,KAAKC,WAAL,CAAiB,CAAC,YAAD,EAAe,YAAf,CAAjB,CAAP;AACD,GAdkB,CAgBnB;;;AAhBmB,CAArB,C,CAmBA;AACA;;AACAnD,YAAY,CAACoD,UAAb,GAA0BpD,YAAY,CAACmD,WAAb,GAA2B,YAAY;AAC/D,OAAKzD,WAAL,CAAiBuB,IAAjB,CAAsB;AACpBC,IAAAA,QAAQ,EAAE,YADU;AAEpBhC,IAAAA,MAAM,EAAE,YAFY;AAGpBiC,IAAAA,IAAI,EAAExC,OAAO,CAACyB,SAAD;AAHO,GAAtB;;AAKA,SAAO,IAAP;AACD,CAPD;;AASAiD,MAAM,CAACC,OAAP,GAAiBvE,YAAjB","sourcesContent":["// TableBuilder\n\n// Takes the function passed to the \"createTable\" or \"table/editTable\"\n// functions and calls it with the \"TableBuilder\" as both the context and\n// the first argument. Inside this function we can specify what happens to the\n// method, pushing everything we want to do onto the \"allStatements\" array,\n// which is then compiled into sql.\n// ------\nconst each = require('lodash/each');\nconst extend = require('lodash/extend');\nconst toArray = require('lodash/toArray');\nconst helpers = require('../util/helpers');\nconst { isString, isFunction } = require('../util/is');\n\nclass TableBuilder {\n  constructor(client, method, tableName, fn) {\n    this.client = client;\n    this._fn = fn;\n    this._method = method;\n    this._schemaName = undefined;\n    this._tableName = tableName;\n    this._statements = [];\n    this._single = {};\n\n    if (!isFunction(this._fn)) {\n      throw new TypeError(\n        'A callback function must be supplied to calls against `.createTable` ' +\n          'and `.table`'\n      );\n    }\n  }\n\n  setSchema(schemaName) {\n    this._schemaName = schemaName;\n  }\n\n  // Convert the current tableBuilder object \"toSQL\"\n  // giving us additional methods if we're altering\n  // rather than creating the table.\n  toSQL() {\n    if (this._method === 'alter') {\n      extend(this, AlterMethods);\n    }\n    this._fn.call(this, this);\n    return this.client.tableCompiler(this).toSQL();\n  }\n\n  // The \"timestamps\" call is really just sets the `created_at` and `updated_at` columns.\n  timestamps() {\n    const method = arguments[0] === true ? 'timestamp' : 'datetime';\n    const createdAt = this[method]('created_at');\n    const updatedAt = this[method]('updated_at');\n    if (arguments[1] === true) {\n      const now = this.client.raw('CURRENT_TIMESTAMP');\n      createdAt.notNullable().defaultTo(now);\n      updatedAt.notNullable().defaultTo(now);\n    }\n    return;\n  }\n\n  // Set the comment value for a table, they're only allowed to be called\n  // once per table.\n  comment(value) {\n    if (typeof value !== 'string') {\n      throw new TypeError('Table comment must be string');\n    }\n    this._single.comment = value;\n  }\n\n  // Set a foreign key on the table, calling\n  // `table.foreign('column_name').references('column').on('table').onDelete()...\n  // Also called from the ColumnBuilder context when chaining.\n  foreign(column, keyName) {\n    const foreignData = { column: column, keyName: keyName };\n    this._statements.push({\n      grouping: 'alterTable',\n      method: 'foreign',\n      args: [foreignData],\n    });\n    let returnObj = {\n      references(tableColumn) {\n        let pieces;\n        if (isString(tableColumn)) {\n          pieces = tableColumn.split('.');\n        }\n        if (!pieces || pieces.length === 1) {\n          foreignData.references = pieces ? pieces[0] : tableColumn;\n          return {\n            on(tableName) {\n              if (typeof tableName !== 'string') {\n                throw new TypeError(\n                  `Expected tableName to be a string, got: ${typeof tableName}`\n                );\n              }\n              foreignData.inTable = tableName;\n              return returnObj;\n            },\n            inTable() {\n              return this.on.apply(this, arguments);\n            },\n          };\n        }\n        foreignData.inTable = pieces[0];\n        foreignData.references = pieces[1];\n        return returnObj;\n      },\n      withKeyName(keyName) {\n        foreignData.keyName = keyName;\n        return returnObj;\n      },\n      onUpdate(statement) {\n        foreignData.onUpdate = statement;\n        return returnObj;\n      },\n      onDelete(statement) {\n        foreignData.onDelete = statement;\n        return returnObj;\n      },\n      _columnBuilder(builder) {\n        extend(builder, returnObj);\n        returnObj = builder;\n        return builder;\n      },\n    };\n    return returnObj;\n  }\n}\n\n[\n  // Each of the index methods can be called individually, with the\n  // column name to be used, e.g. table.unique('column').\n  'index',\n  'primary',\n  'unique',\n\n  // Key specific\n  'dropPrimary',\n  'dropUnique',\n  'dropIndex',\n  'dropForeign',\n].forEach((method) => {\n  TableBuilder.prototype[method] = function () {\n    this._statements.push({\n      grouping: 'alterTable',\n      method,\n      args: toArray(arguments),\n    });\n    return this;\n  };\n});\n\n// Warn for dialect-specific table methods, since that's the\n// only time these are supported.\nconst specialMethods = {\n  mysql: ['engine', 'charset', 'collate'],\n  postgresql: ['inherits'],\n};\neach(specialMethods, function (methods, dialect) {\n  methods.forEach(function (method) {\n    TableBuilder.prototype[method] = function (value) {\n      if (this.client.dialect !== dialect) {\n        throw new Error(\n          `Knex only supports ${method} statement with ${dialect}.`\n        );\n      }\n      if (this._method === 'alter') {\n        throw new Error(\n          `Knex does not support altering the ${method} outside of create ` +\n            `table, please use knex.raw statement.`\n        );\n      }\n      this._single[method] = value;\n    };\n  });\n});\n\nhelpers.addQueryContext(TableBuilder);\n\n// Each of the column types that we can add, we create a new ColumnBuilder\n// instance and push it onto the statements array.\nconst columnTypes = [\n  // Numeric\n  'tinyint',\n  'smallint',\n  'mediumint',\n  'int',\n  'bigint',\n  'decimal',\n  'float',\n  'double',\n  'real',\n  'bit',\n  'boolean',\n  'serial',\n\n  // Date / Time\n  'date',\n  'datetime',\n  'timestamp',\n  'time',\n  'year',\n\n  // String\n  'char',\n  'varchar',\n  'tinytext',\n  'tinyText',\n  'text',\n  'mediumtext',\n  'mediumText',\n  'longtext',\n  'longText',\n  'binary',\n  'varbinary',\n  'tinyblob',\n  'tinyBlob',\n  'mediumblob',\n  'mediumBlob',\n  'blob',\n  'longblob',\n  'longBlob',\n  'enum',\n  'set',\n\n  // Increments, Aliases, and Additional\n  'bool',\n  'dateTime',\n  'increments',\n  'bigincrements',\n  'bigIncrements',\n  'integer',\n  'biginteger',\n  'bigInteger',\n  'string',\n  'json',\n  'jsonb',\n  'uuid',\n  'enu',\n  'specificType',\n];\n\n// For each of the column methods, create a new \"ColumnBuilder\" interface,\n// push it onto the \"allStatements\" stack, and then return the interface,\n// with which we can add indexes, etc.\ncolumnTypes.forEach((type) => {\n  TableBuilder.prototype[type] = function () {\n    const args = toArray(arguments);\n    const builder = this.client.columnBuilder(this, type, args);\n    this._statements.push({\n      grouping: 'columns',\n      builder,\n    });\n    return builder;\n  };\n});\n\nconst AlterMethods = {\n  // Renames the current column `from` the current\n  // TODO: this.column(from).rename(to)\n  renameColumn(from, to) {\n    this._statements.push({\n      grouping: 'alterTable',\n      method: 'renameColumn',\n      args: [from, to],\n    });\n    return this;\n  },\n\n  dropTimestamps() {\n    return this.dropColumns(['created_at', 'updated_at']);\n  },\n\n  // TODO: changeType\n};\n\n// Drop a column from the current table.\n// TODO: Enable this.column(columnName).drop();\nAlterMethods.dropColumn = AlterMethods.dropColumns = function () {\n  this._statements.push({\n    grouping: 'alterTable',\n    method: 'dropColumn',\n    args: toArray(arguments),\n  });\n  return this;\n};\n\nmodule.exports = TableBuilder;\n"]},"metadata":{},"sourceType":"script"}