{"ast":null,"code":"const identity = require('lodash/identity');\n\nconst chunk = require('lodash/chunk');\n\nfunction insertChunked(trx, chunkSize, target, iterator, existingData) {\n  const result = [];\n  iterator = iterator || identity;\n  const chunked = chunk(existingData, chunkSize);\n\n  for (const batch of chunked) {\n    result.push(trx.queryBuilder().table(target).insert(batch.map(iterator)).toQuery());\n  }\n\n  return result;\n}\n\nfunction createNewTable(sql, tablename, alteredName) {\n  return sql.replace(tablename, alteredName);\n} // ToDo To be removed\n\n\nasync function copyData(trx, iterator, tableName, alteredName) {\n  const existingData = await trx.raw(`SELECT * FROM \"${tableName}\"`);\n  return insertChunked(trx, 20, alteredName, iterator, existingData);\n}\n\nfunction copyAllData(sourceTable, targetTable) {\n  return `INSERT INTO ${targetTable} SELECT * FROM ${sourceTable};`;\n}\n\nfunction dropOriginal(tableName) {\n  return `DROP TABLE \"${tableName}\"`;\n}\n\nfunction renameTable(tableName, alteredName) {\n  return `ALTER TABLE \"${tableName}\" RENAME TO \"${alteredName}\"`;\n}\n\nfunction getTableSql(tableName) {\n  return `SELECT type, sql FROM sqlite_master WHERE (type=\"table\" OR (type=\"index\" AND sql IS NOT NULL)) AND tbl_name=\"${tableName}\"`;\n}\n\nmodule.exports = {\n  copyAllData,\n  createNewTable,\n  dropOriginal,\n  copyData,\n  renameTable,\n  getTableSql\n};","map":{"version":3,"sources":["/home/rosiane/Projeto-completo/back/node_modules/knex/lib/dialects/sqlite3/schema/internal/sqlite-ddl-operations.js"],"names":["identity","require","chunk","insertChunked","trx","chunkSize","target","iterator","existingData","result","chunked","batch","push","queryBuilder","table","insert","map","toQuery","createNewTable","sql","tablename","alteredName","replace","copyData","tableName","raw","copyAllData","sourceTable","targetTable","dropOriginal","renameTable","getTableSql","module","exports"],"mappings":"AAAA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,iBAAD,CAAxB;;AACA,MAAMC,KAAK,GAAGD,OAAO,CAAC,cAAD,CAArB;;AAEA,SAASE,aAAT,CAAuBC,GAAvB,EAA4BC,SAA5B,EAAuCC,MAAvC,EAA+CC,QAA/C,EAAyDC,YAAzD,EAAuE;AACrE,QAAMC,MAAM,GAAG,EAAf;AACAF,EAAAA,QAAQ,GAAGA,QAAQ,IAAIP,QAAvB;AACA,QAAMU,OAAO,GAAGR,KAAK,CAACM,YAAD,EAAeH,SAAf,CAArB;;AACA,OAAK,MAAMM,KAAX,IAAoBD,OAApB,EAA6B;AAC3BD,IAAAA,MAAM,CAACG,IAAP,CACER,GAAG,CAACS,YAAJ,GAAmBC,KAAnB,CAAyBR,MAAzB,EAAiCS,MAAjC,CAAwCJ,KAAK,CAACK,GAAN,CAAUT,QAAV,CAAxC,EAA6DU,OAA7D,EADF;AAGD;;AACD,SAAOR,MAAP;AACD;;AAED,SAASS,cAAT,CAAwBC,GAAxB,EAA6BC,SAA7B,EAAwCC,WAAxC,EAAqD;AACnD,SAAOF,GAAG,CAACG,OAAJ,CAAYF,SAAZ,EAAuBC,WAAvB,CAAP;AACD,C,CAED;;;AACA,eAAeE,QAAf,CAAwBnB,GAAxB,EAA6BG,QAA7B,EAAuCiB,SAAvC,EAAkDH,WAAlD,EAA+D;AAC7D,QAAMb,YAAY,GAAG,MAAMJ,GAAG,CAACqB,GAAJ,CAAS,kBAAiBD,SAAU,GAApC,CAA3B;AACA,SAAOrB,aAAa,CAACC,GAAD,EAAM,EAAN,EAAUiB,WAAV,EAAuBd,QAAvB,EAAiCC,YAAjC,CAApB;AACD;;AAED,SAASkB,WAAT,CAAqBC,WAArB,EAAkCC,WAAlC,EAA+C;AAC7C,SAAQ,eAAcA,WAAY,kBAAiBD,WAAY,GAA/D;AACD;;AAED,SAASE,YAAT,CAAsBL,SAAtB,EAAiC;AAC/B,SAAQ,eAAcA,SAAU,GAAhC;AACD;;AAED,SAASM,WAAT,CAAqBN,SAArB,EAAgCH,WAAhC,EAA6C;AAC3C,SAAQ,gBAAeG,SAAU,gBAAeH,WAAY,GAA5D;AACD;;AAED,SAASU,WAAT,CAAqBP,SAArB,EAAgC;AAC9B,SAAQ,gHAA+GA,SAAU,GAAjI;AACD;;AAEDQ,MAAM,CAACC,OAAP,GAAiB;AACfP,EAAAA,WADe;AAEfR,EAAAA,cAFe;AAGfW,EAAAA,YAHe;AAIfN,EAAAA,QAJe;AAKfO,EAAAA,WALe;AAMfC,EAAAA;AANe,CAAjB","sourcesContent":["const identity = require('lodash/identity');\nconst chunk = require('lodash/chunk');\n\nfunction insertChunked(trx, chunkSize, target, iterator, existingData) {\n  const result = [];\n  iterator = iterator || identity;\n  const chunked = chunk(existingData, chunkSize);\n  for (const batch of chunked) {\n    result.push(\n      trx.queryBuilder().table(target).insert(batch.map(iterator)).toQuery()\n    );\n  }\n  return result;\n}\n\nfunction createNewTable(sql, tablename, alteredName) {\n  return sql.replace(tablename, alteredName);\n}\n\n// ToDo To be removed\nasync function copyData(trx, iterator, tableName, alteredName) {\n  const existingData = await trx.raw(`SELECT * FROM \"${tableName}\"`);\n  return insertChunked(trx, 20, alteredName, iterator, existingData);\n}\n\nfunction copyAllData(sourceTable, targetTable) {\n  return `INSERT INTO ${targetTable} SELECT * FROM ${sourceTable};`;\n}\n\nfunction dropOriginal(tableName) {\n  return `DROP TABLE \"${tableName}\"`;\n}\n\nfunction renameTable(tableName, alteredName) {\n  return `ALTER TABLE \"${tableName}\" RENAME TO \"${alteredName}\"`;\n}\n\nfunction getTableSql(tableName) {\n  return `SELECT type, sql FROM sqlite_master WHERE (type=\"table\" OR (type=\"index\" AND sql IS NOT NULL)) AND tbl_name=\"${tableName}\"`;\n}\n\nmodule.exports = {\n  copyAllData,\n  createNewTable,\n  dropOriginal,\n  copyData,\n  renameTable,\n  getTableSql,\n};\n"]},"metadata":{},"sourceType":"script"}