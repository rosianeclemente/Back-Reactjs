{"ast":null,"code":"// PostgreSQL Query Builder & Compiler\n// ------\nconst identity = require('lodash/identity');\n\nconst reduce = require('lodash/reduce');\n\nconst QueryCompiler = require('../../../query/querycompiler');\n\nconst {\n  wrapString\n} = require('../../../formatter/wrappingFormatter');\n\nclass QueryCompiler_PG extends QueryCompiler {\n  constructor(client, builder, formatter) {\n    super(client, builder, formatter);\n    this._defaultInsertValue = 'default';\n  } // Compiles a truncate query.\n\n\n  truncate() {\n    return `truncate ${this.tableName} restart identity`;\n  } // is used if the an array with multiple empty values supplied\n  // Compiles an `insert` query, allowing for multiple\n  // inserts using a single query statement.\n\n\n  insert() {\n    let sql = super.insert();\n    if (sql === '') return sql;\n    const {\n      returning,\n      onConflict,\n      ignore,\n      merge,\n      insert\n    } = this.single;\n    if (onConflict && ignore) sql += this._ignore(onConflict);\n\n    if (onConflict && merge) {\n      sql += this._merge(merge.updates, onConflict, insert);\n      const wheres = this.where();\n      if (wheres) sql += ` ${wheres}`;\n    }\n\n    if (returning) sql += this._returning(returning);\n    return {\n      sql: sql,\n      returning\n    };\n  } // Compiles an `update` query, allowing for a return value.\n\n\n  update() {\n    const withSQL = this.with();\n\n    const updateData = this._prepUpdate(this.single.update);\n\n    const wheres = this.where();\n    const {\n      returning\n    } = this.single;\n    return {\n      sql: withSQL + `update ${this.single.only ? 'only ' : ''}${this.tableName} ` + `set ${updateData.join(', ')}` + (wheres ? ` ${wheres}` : '') + this._returning(returning),\n      returning\n    };\n  } // Compiles an `update` query, allowing for a return value.\n\n\n  del() {\n    const sql = super.del(...arguments);\n    const {\n      returning\n    } = this.single;\n    return {\n      sql: sql + this._returning(returning),\n      returning\n    };\n  }\n\n  aggregate(stmt) {\n    return this._aggregate(stmt, {\n      distinctParentheses: true\n    });\n  }\n\n  _returning(value) {\n    return value ? ` returning ${this.formatter.columnize(value)}` : '';\n  }\n\n  _ignore(columns) {\n    return ` on conflict (${this.formatter.columnize(columns)}) do nothing`;\n  }\n\n  _merge(updates, columns, insert) {\n    let sql = ` on conflict (${this.formatter.columnize(columns)}) do update set `;\n\n    if (updates && Array.isArray(updates)) {\n      sql += updates.map(column => wrapString(column.split('.').pop(), this.formatter.builder, this.client, this.formatter)).map(column => `${column} = excluded.${column}`).join(', ');\n      return sql;\n    } else if (updates && typeof updates === 'object') {\n      const updateData = this._prepUpdate(updates);\n\n      if (typeof updateData === 'string') {\n        sql += updateData;\n      } else {\n        sql += updateData.join(',');\n      }\n\n      return sql;\n    } else {\n      const insertData = this._prepInsert(insert);\n\n      if (typeof insertData === 'string') {\n        throw new Error('If using merge with a raw insert query, then updates must be provided');\n      }\n\n      sql += insertData.columns.map(column => wrapString(column.split('.').pop(), this.builder, this.client)).map(column => `${column} = excluded.${column}`).join(', ');\n      return sql;\n    }\n  } // Join array of table names and apply default schema.\n\n\n  _tableNames(tables) {\n    const schemaName = this.single.schema;\n    const sql = [];\n\n    for (let i = 0; i < tables.length; i++) {\n      let tableName = tables[i];\n\n      if (tableName) {\n        if (schemaName) {\n          tableName = `${schemaName}.${tableName}`;\n        }\n\n        sql.push(this.formatter.wrap(tableName));\n      }\n    }\n\n    return sql.join(', ');\n  }\n\n  forUpdate() {\n    const tables = this.single.lockTables || [];\n    return 'for update' + (tables.length ? ' of ' + this._tableNames(tables) : '');\n  }\n\n  forShare() {\n    const tables = this.single.lockTables || [];\n    return 'for share' + (tables.length ? ' of ' + this._tableNames(tables) : '');\n  }\n\n  skipLocked() {\n    return 'skip locked';\n  }\n\n  noWait() {\n    return 'nowait';\n  } // Compiles a columnInfo query\n\n\n  columnInfo() {\n    const column = this.single.columnInfo;\n    let schema = this.single.schema; // The user may have specified a custom wrapIdentifier function in the config. We\n    // need to run the identifiers through that function, but not format them as\n    // identifiers otherwise.\n\n    const table = this.client.customWrapIdentifier(this.single.table, identity);\n\n    if (schema) {\n      schema = this.client.customWrapIdentifier(schema, identity);\n    }\n\n    let sql = 'select * from information_schema.columns where table_name = ? and table_catalog = ?';\n    const bindings = [table, this.client.database()];\n\n    if (schema) {\n      sql += ' and table_schema = ?';\n      bindings.push(schema);\n    } else {\n      sql += ' and table_schema = current_schema()';\n    }\n\n    return {\n      sql,\n      bindings,\n\n      output(resp) {\n        const out = reduce(resp.rows, function (columns, val) {\n          columns[val.column_name] = {\n            type: val.data_type,\n            maxLength: val.character_maximum_length,\n            nullable: val.is_nullable === 'YES',\n            defaultValue: val.column_default\n          };\n          return columns;\n        }, {});\n        return column && out[column] || out;\n      }\n\n    };\n  }\n\n  distinctOn(value) {\n    return 'distinct on (' + this.formatter.columnize(value) + ') ';\n  }\n\n}\n\nmodule.exports = QueryCompiler_PG;","map":{"version":3,"sources":["/home/rosiane/back/node_modules/knex/lib/dialects/postgres/query/pg-querycompiler.js"],"names":["identity","require","reduce","QueryCompiler","wrapString","QueryCompiler_PG","constructor","client","builder","formatter","_defaultInsertValue","truncate","tableName","insert","sql","returning","onConflict","ignore","merge","single","_ignore","_merge","updates","wheres","where","_returning","update","withSQL","with","updateData","_prepUpdate","only","join","del","arguments","aggregate","stmt","_aggregate","distinctParentheses","value","columnize","columns","Array","isArray","map","column","split","pop","insertData","_prepInsert","Error","_tableNames","tables","schemaName","schema","i","length","push","wrap","forUpdate","lockTables","forShare","skipLocked","noWait","columnInfo","table","customWrapIdentifier","bindings","database","output","resp","out","rows","val","column_name","type","data_type","maxLength","character_maximum_length","nullable","is_nullable","defaultValue","column_default","distinctOn","module","exports"],"mappings":"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","sourcesContent":["// PostgreSQL Query Builder & Compiler\n// ------\nconst identity = require('lodash/identity');\nconst reduce = require('lodash/reduce');\n\nconst QueryCompiler = require('../../../query/querycompiler');\nconst { wrapString } = require('../../../formatter/wrappingFormatter');\n\nclass QueryCompiler_PG extends QueryCompiler {\n  constructor(client, builder, formatter) {\n    super(client, builder, formatter);\n    this._defaultInsertValue = 'default';\n  }\n\n  // Compiles a truncate query.\n  truncate() {\n    return `truncate ${this.tableName} restart identity`;\n  }\n\n  // is used if the an array with multiple empty values supplied\n\n  // Compiles an `insert` query, allowing for multiple\n  // inserts using a single query statement.\n  insert() {\n    let sql = super.insert();\n    if (sql === '') return sql;\n\n    const { returning, onConflict, ignore, merge, insert } = this.single;\n    if (onConflict && ignore) sql += this._ignore(onConflict);\n    if (onConflict && merge) {\n      sql += this._merge(merge.updates, onConflict, insert);\n      const wheres = this.where();\n      if (wheres) sql += ` ${wheres}`;\n    }\n    if (returning) sql += this._returning(returning);\n\n    return {\n      sql: sql,\n      returning,\n    };\n  }\n\n  // Compiles an `update` query, allowing for a return value.\n  update() {\n    const withSQL = this.with();\n    const updateData = this._prepUpdate(this.single.update);\n    const wheres = this.where();\n    const { returning } = this.single;\n    return {\n      sql:\n        withSQL +\n        `update ${this.single.only ? 'only ' : ''}${this.tableName} ` +\n        `set ${updateData.join(', ')}` +\n        (wheres ? ` ${wheres}` : '') +\n        this._returning(returning),\n      returning,\n    };\n  }\n\n  // Compiles an `update` query, allowing for a return value.\n  del() {\n    const sql = super.del(...arguments);\n    const { returning } = this.single;\n    return {\n      sql: sql + this._returning(returning),\n      returning,\n    };\n  }\n\n  aggregate(stmt) {\n    return this._aggregate(stmt, { distinctParentheses: true });\n  }\n\n  _returning(value) {\n    return value ? ` returning ${this.formatter.columnize(value)}` : '';\n  }\n\n  _ignore(columns) {\n    return ` on conflict (${this.formatter.columnize(columns)}) do nothing`;\n  }\n\n  _merge(updates, columns, insert) {\n    let sql = ` on conflict (${this.formatter.columnize(\n      columns\n    )}) do update set `;\n    if (updates && Array.isArray(updates)) {\n      sql += updates\n        .map((column) =>\n          wrapString(\n            column.split('.').pop(),\n            this.formatter.builder,\n            this.client,\n            this.formatter\n          )\n        )\n        .map((column) => `${column} = excluded.${column}`)\n        .join(', ');\n\n      return sql;\n    } else if (updates && typeof updates === 'object') {\n      const updateData = this._prepUpdate(updates);\n      if (typeof updateData === 'string') {\n        sql += updateData;\n      } else {\n        sql += updateData.join(',');\n      }\n\n      return sql;\n    } else {\n      const insertData = this._prepInsert(insert);\n      if (typeof insertData === 'string') {\n        throw new Error(\n          'If using merge with a raw insert query, then updates must be provided'\n        );\n      }\n\n      sql += insertData.columns\n        .map((column) =>\n          wrapString(column.split('.').pop(), this.builder, this.client)\n        )\n        .map((column) => `${column} = excluded.${column}`)\n        .join(', ');\n\n      return sql;\n    }\n  }\n\n  // Join array of table names and apply default schema.\n  _tableNames(tables) {\n    const schemaName = this.single.schema;\n    const sql = [];\n\n    for (let i = 0; i < tables.length; i++) {\n      let tableName = tables[i];\n\n      if (tableName) {\n        if (schemaName) {\n          tableName = `${schemaName}.${tableName}`;\n        }\n        sql.push(this.formatter.wrap(tableName));\n      }\n    }\n\n    return sql.join(', ');\n  }\n\n  forUpdate() {\n    const tables = this.single.lockTables || [];\n\n    return (\n      'for update' + (tables.length ? ' of ' + this._tableNames(tables) : '')\n    );\n  }\n\n  forShare() {\n    const tables = this.single.lockTables || [];\n\n    return (\n      'for share' + (tables.length ? ' of ' + this._tableNames(tables) : '')\n    );\n  }\n\n  skipLocked() {\n    return 'skip locked';\n  }\n\n  noWait() {\n    return 'nowait';\n  }\n\n  // Compiles a columnInfo query\n  columnInfo() {\n    const column = this.single.columnInfo;\n    let schema = this.single.schema;\n\n    // The user may have specified a custom wrapIdentifier function in the config. We\n    // need to run the identifiers through that function, but not format them as\n    // identifiers otherwise.\n    const table = this.client.customWrapIdentifier(this.single.table, identity);\n\n    if (schema) {\n      schema = this.client.customWrapIdentifier(schema, identity);\n    }\n\n    let sql =\n      'select * from information_schema.columns where table_name = ? and table_catalog = ?';\n    const bindings = [table, this.client.database()];\n\n    if (schema) {\n      sql += ' and table_schema = ?';\n      bindings.push(schema);\n    } else {\n      sql += ' and table_schema = current_schema()';\n    }\n\n    return {\n      sql,\n      bindings,\n      output(resp) {\n        const out = reduce(\n          resp.rows,\n          function (columns, val) {\n            columns[val.column_name] = {\n              type: val.data_type,\n              maxLength: val.character_maximum_length,\n              nullable: val.is_nullable === 'YES',\n              defaultValue: val.column_default,\n            };\n            return columns;\n          },\n          {}\n        );\n        return (column && out[column]) || out;\n      },\n    };\n  }\n\n  distinctOn(value) {\n    return 'distinct on (' + this.formatter.columnize(value) + ') ';\n  }\n}\n\nmodule.exports = QueryCompiler_PG;\n"]},"metadata":{},"sourceType":"script"}