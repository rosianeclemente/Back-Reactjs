{"ast":null,"code":"// MySQL Client\n// -------\nconst defer = require('lodash/defer');\n\nconst map = require('lodash/map');\n\nconst {\n  promisify\n} = require('util');\n\nconst Client = require('../../client');\n\nconst Transaction = require('./transaction');\n\nconst QueryCompiler = require('./query/mysql-querycompiler');\n\nconst SchemaCompiler = require('./schema/mysql-compiler');\n\nconst TableCompiler = require('./schema/mysql-tablecompiler');\n\nconst ColumnCompiler = require('./schema/mysql-columncompiler');\n\nconst {\n  makeEscape\n} = require('../../util/string'); // Always initialize with the \"QueryBuilder\" and \"QueryCompiler\"\n// objects, which extend the base 'lib/query/builder' and\n// 'lib/query/compiler', respectively.\n\n\nclass Client_MySQL extends Client {\n  _driver() {\n    return require('mysql');\n  }\n\n  queryCompiler(builder, formatter) {\n    return new QueryCompiler(this, builder, formatter);\n  }\n\n  schemaCompiler() {\n    return new SchemaCompiler(this, ...arguments);\n  }\n\n  tableCompiler() {\n    return new TableCompiler(this, ...arguments);\n  }\n\n  columnCompiler() {\n    return new ColumnCompiler(this, ...arguments);\n  }\n\n  transaction() {\n    return new Transaction(this, ...arguments);\n  }\n\n  wrapIdentifierImpl(value) {\n    return value !== '*' ? `\\`${value.replace(/`/g, '``')}\\`` : '*';\n  } // Get a raw connection, called by the `pool` whenever a new\n  // connection needs to be added to the pool.\n\n\n  acquireRawConnection() {\n    return new Promise((resolver, rejecter) => {\n      const connection = this.driver.createConnection(this.connectionSettings);\n      connection.on('error', err => {\n        connection.__knex__disposed = err;\n      });\n      connection.connect(err => {\n        if (err) {\n          // if connection is rejected, remove listener that was registered above...\n          connection.removeAllListeners();\n          return rejecter(err);\n        }\n\n        resolver(connection);\n      });\n    });\n  } // Used to explicitly close a connection, called internally by the pool\n  // when a connection times out or the pool is shutdown.\n\n\n  async destroyRawConnection(connection) {\n    try {\n      const end = promisify(cb => connection.end(cb));\n      return await end();\n    } catch (err) {\n      connection.__knex__disposed = err;\n    } finally {\n      // see discussion https://github.com/knex/knex/pull/3483\n      defer(() => connection.removeAllListeners());\n    }\n  }\n\n  validateConnection(connection) {\n    if (connection.state === 'connected' || connection.state === 'authenticated') {\n      return true;\n    }\n\n    return false;\n  } // Grab a connection, run the query via the MySQL streaming interface,\n  // and pass that through to the stream we've sent back to the client.\n\n\n  _stream(connection, obj, stream, options) {\n    if (!obj.sql) throw new Error('The query is empty');\n    options = options || {};\n    const queryOptions = Object.assign({\n      sql: obj.sql\n    }, obj.options);\n    return new Promise((resolver, rejecter) => {\n      stream.on('error', rejecter);\n      stream.on('end', resolver);\n      const queryStream = connection.query(queryOptions, obj.bindings).stream(options);\n      queryStream.on('error', err => {\n        rejecter(err);\n        stream.emit('error', err);\n      });\n      queryStream.pipe(stream);\n    });\n  } // Runs the query on the specified connection, providing the bindings\n  // and any other necessary prep work.\n\n\n  _query(connection, obj) {\n    if (!obj || typeof obj === 'string') obj = {\n      sql: obj\n    };\n    if (!obj.sql) throw new Error('The query is empty');\n    return new Promise(function (resolver, rejecter) {\n      if (!obj.sql) {\n        resolver();\n        return;\n      }\n\n      const queryOptions = Object.assign({\n        sql: obj.sql\n      }, obj.options);\n      connection.query(queryOptions, obj.bindings, function (err, rows, fields) {\n        if (err) return rejecter(err);\n        obj.response = [rows, fields];\n        resolver(obj);\n      });\n    });\n  } // Process the response as returned from the query.\n\n\n  processResponse(obj, runner) {\n    if (obj == null) return;\n    const {\n      response\n    } = obj;\n    const {\n      method\n    } = obj;\n    const rows = response[0];\n    const fields = response[1];\n    if (obj.output) return obj.output.call(runner, rows, fields);\n\n    switch (method) {\n      case 'select':\n        return rows;\n\n      case 'first':\n        return rows[0];\n\n      case 'pluck':\n        return map(rows, obj.pluck);\n\n      case 'insert':\n        return [rows.insertId];\n\n      case 'del':\n      case 'update':\n      case 'counter':\n        return rows.affectedRows;\n\n      default:\n        return response;\n    }\n  }\n\n  async cancelQuery(connectionToKill) {\n    const conn = await this.acquireRawConnection();\n\n    try {\n      return await this._query(conn, {\n        sql: 'KILL QUERY ?',\n        bindings: [connectionToKill.threadId],\n        options: {}\n      });\n    } finally {\n      await this.destroyRawConnection(conn);\n\n      if (conn.__knex__disposed) {\n        this.logger.warn(`Connection Error: ${conn.__knex__disposed}`);\n      }\n    }\n  }\n\n}\n\nObject.assign(Client_MySQL.prototype, {\n  dialect: 'mysql',\n  driverName: 'mysql',\n  _escapeBinding: makeEscape(),\n  canCancelQuery: true\n});\nmodule.exports = Client_MySQL;","map":{"version":3,"sources":["/home/rosiane/back/node_modules/knex/lib/dialects/mysql/index.js"],"names":["defer","require","map","promisify","Client","Transaction","QueryCompiler","SchemaCompiler","TableCompiler","ColumnCompiler","makeEscape","Client_MySQL","_driver","queryCompiler","builder","formatter","schemaCompiler","arguments","tableCompiler","columnCompiler","transaction","wrapIdentifierImpl","value","replace","acquireRawConnection","Promise","resolver","rejecter","connection","driver","createConnection","connectionSettings","on","err","__knex__disposed","connect","removeAllListeners","destroyRawConnection","end","cb","validateConnection","state","_stream","obj","stream","options","sql","Error","queryOptions","Object","assign","queryStream","query","bindings","emit","pipe","_query","rows","fields","response","processResponse","runner","method","output","call","pluck","insertId","affectedRows","cancelQuery","connectionToKill","conn","threadId","logger","warn","prototype","dialect","driverName","_escapeBinding","canCancelQuery","module","exports"],"mappings":"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","sourcesContent":["// MySQL Client\n// -------\nconst defer = require('lodash/defer');\nconst map = require('lodash/map');\nconst { promisify } = require('util');\nconst Client = require('../../client');\n\nconst Transaction = require('./transaction');\nconst QueryCompiler = require('./query/mysql-querycompiler');\nconst SchemaCompiler = require('./schema/mysql-compiler');\nconst TableCompiler = require('./schema/mysql-tablecompiler');\nconst ColumnCompiler = require('./schema/mysql-columncompiler');\n\nconst { makeEscape } = require('../../util/string');\n\n// Always initialize with the \"QueryBuilder\" and \"QueryCompiler\"\n// objects, which extend the base 'lib/query/builder' and\n// 'lib/query/compiler', respectively.\nclass Client_MySQL extends Client {\n  _driver() {\n    return require('mysql');\n  }\n\n  queryCompiler(builder, formatter) {\n    return new QueryCompiler(this, builder, formatter);\n  }\n\n  schemaCompiler() {\n    return new SchemaCompiler(this, ...arguments);\n  }\n\n  tableCompiler() {\n    return new TableCompiler(this, ...arguments);\n  }\n\n  columnCompiler() {\n    return new ColumnCompiler(this, ...arguments);\n  }\n\n  transaction() {\n    return new Transaction(this, ...arguments);\n  }\n\n  wrapIdentifierImpl(value) {\n    return value !== '*' ? `\\`${value.replace(/`/g, '``')}\\`` : '*';\n  }\n\n  // Get a raw connection, called by the `pool` whenever a new\n  // connection needs to be added to the pool.\n  acquireRawConnection() {\n    return new Promise((resolver, rejecter) => {\n      const connection = this.driver.createConnection(this.connectionSettings);\n      connection.on('error', (err) => {\n        connection.__knex__disposed = err;\n      });\n      connection.connect((err) => {\n        if (err) {\n          // if connection is rejected, remove listener that was registered above...\n          connection.removeAllListeners();\n          return rejecter(err);\n        }\n        resolver(connection);\n      });\n    });\n  }\n\n  // Used to explicitly close a connection, called internally by the pool\n  // when a connection times out or the pool is shutdown.\n  async destroyRawConnection(connection) {\n    try {\n      const end = promisify((cb) => connection.end(cb));\n      return await end();\n    } catch (err) {\n      connection.__knex__disposed = err;\n    } finally {\n      // see discussion https://github.com/knex/knex/pull/3483\n      defer(() => connection.removeAllListeners());\n    }\n  }\n\n  validateConnection(connection) {\n    if (\n      connection.state === 'connected' ||\n      connection.state === 'authenticated'\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  // Grab a connection, run the query via the MySQL streaming interface,\n  // and pass that through to the stream we've sent back to the client.\n  _stream(connection, obj, stream, options) {\n    if (!obj.sql) throw new Error('The query is empty');\n\n    options = options || {};\n    const queryOptions = Object.assign({ sql: obj.sql }, obj.options);\n    return new Promise((resolver, rejecter) => {\n      stream.on('error', rejecter);\n      stream.on('end', resolver);\n      const queryStream = connection\n        .query(queryOptions, obj.bindings)\n        .stream(options);\n\n      queryStream.on('error', (err) => {\n        rejecter(err);\n        stream.emit('error', err);\n      });\n\n      queryStream.pipe(stream);\n    });\n  }\n\n  // Runs the query on the specified connection, providing the bindings\n  // and any other necessary prep work.\n  _query(connection, obj) {\n    if (!obj || typeof obj === 'string') obj = { sql: obj };\n    if (!obj.sql) throw new Error('The query is empty');\n\n    return new Promise(function (resolver, rejecter) {\n      if (!obj.sql) {\n        resolver();\n        return;\n      }\n      const queryOptions = Object.assign({ sql: obj.sql }, obj.options);\n      connection.query(\n        queryOptions,\n        obj.bindings,\n        function (err, rows, fields) {\n          if (err) return rejecter(err);\n          obj.response = [rows, fields];\n          resolver(obj);\n        }\n      );\n    });\n  }\n\n  // Process the response as returned from the query.\n  processResponse(obj, runner) {\n    if (obj == null) return;\n    const { response } = obj;\n    const { method } = obj;\n    const rows = response[0];\n    const fields = response[1];\n    if (obj.output) return obj.output.call(runner, rows, fields);\n    switch (method) {\n      case 'select':\n        return rows;\n      case 'first':\n        return rows[0];\n      case 'pluck':\n        return map(rows, obj.pluck);\n      case 'insert':\n        return [rows.insertId];\n      case 'del':\n      case 'update':\n      case 'counter':\n        return rows.affectedRows;\n      default:\n        return response;\n    }\n  }\n\n  async cancelQuery(connectionToKill) {\n    const conn = await this.acquireRawConnection();\n    try {\n      return await this._query(conn, {\n        sql: 'KILL QUERY ?',\n        bindings: [connectionToKill.threadId],\n        options: {},\n      });\n    } finally {\n      await this.destroyRawConnection(conn);\n      if (conn.__knex__disposed) {\n        this.logger.warn(`Connection Error: ${conn.__knex__disposed}`);\n      }\n    }\n  }\n}\n\nObject.assign(Client_MySQL.prototype, {\n  dialect: 'mysql',\n\n  driverName: 'mysql',\n\n  _escapeBinding: makeEscape(),\n\n  canCancelQuery: true,\n});\n\nmodule.exports = Client_MySQL;\n"]},"metadata":{},"sourceType":"script"}