{"ast":null,"code":"const chunk = require('lodash/chunk');\n\nconst flatten = require('lodash/flatten');\n\nconst delay = require('./internal/delay');\n\nconst {\n  isNumber\n} = require('../util/is');\n\nfunction batchInsert(client, tableName, batch, chunkSize = 1000) {\n  let returning = void 0;\n  let transaction = null;\n\n  const runInTransaction = cb => {\n    if (transaction) {\n      return cb(transaction);\n    }\n\n    return client.transaction(cb);\n  };\n\n  return Object.assign(Promise.resolve().then(async () => {\n    if (!isNumber(chunkSize) || chunkSize < 1) {\n      throw new TypeError(`Invalid chunkSize: ${chunkSize}`);\n    }\n\n    if (!Array.isArray(batch)) {\n      throw new TypeError(`Invalid batch: Expected array, got ${typeof batch}`);\n    }\n\n    const chunks = chunk(batch, chunkSize); //Next tick to ensure wrapper functions are called if needed\n\n    await delay(1);\n    return runInTransaction(async tr => {\n      const chunksResults = [];\n\n      for (const items of chunks) {\n        chunksResults.push(await tr(tableName).insert(items, returning));\n      }\n\n      return flatten(chunksResults);\n    });\n  }), {\n    returning(columns) {\n      returning = columns;\n      return this;\n    },\n\n    transacting(tr) {\n      transaction = tr;\n      return this;\n    }\n\n  });\n}\n\nmodule.exports = batchInsert;","map":{"version":3,"sources":["/home/rosiane/Projeto-completo/back/node_modules/knex/lib/execution/batch-insert.js"],"names":["chunk","require","flatten","delay","isNumber","batchInsert","client","tableName","batch","chunkSize","returning","transaction","runInTransaction","cb","Object","assign","Promise","resolve","then","TypeError","Array","isArray","chunks","tr","chunksResults","items","push","insert","columns","transacting","module","exports"],"mappings":"AAAA,MAAMA,KAAK,GAAGC,OAAO,CAAC,cAAD,CAArB;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,gBAAD,CAAvB;;AACA,MAAME,KAAK,GAAGF,OAAO,CAAC,kBAAD,CAArB;;AACA,MAAM;AAAEG,EAAAA;AAAF,IAAeH,OAAO,CAAC,YAAD,CAA5B;;AAEA,SAASI,WAAT,CAAqBC,MAArB,EAA6BC,SAA7B,EAAwCC,KAAxC,EAA+CC,SAAS,GAAG,IAA3D,EAAiE;AAC/D,MAAIC,SAAS,GAAG,KAAK,CAArB;AACA,MAAIC,WAAW,GAAG,IAAlB;;AAEA,QAAMC,gBAAgB,GAAIC,EAAD,IAAQ;AAC/B,QAAIF,WAAJ,EAAiB;AACf,aAAOE,EAAE,CAACF,WAAD,CAAT;AACD;;AACD,WAAOL,MAAM,CAACK,WAAP,CAAmBE,EAAnB,CAAP;AACD,GALD;;AAOA,SAAOC,MAAM,CAACC,MAAP,CACLC,OAAO,CAACC,OAAR,GAAkBC,IAAlB,CAAuB,YAAY;AACjC,QAAI,CAACd,QAAQ,CAACK,SAAD,CAAT,IAAwBA,SAAS,GAAG,CAAxC,EAA2C;AACzC,YAAM,IAAIU,SAAJ,CAAe,sBAAqBV,SAAU,EAA9C,CAAN;AACD;;AAED,QAAI,CAACW,KAAK,CAACC,OAAN,CAAcb,KAAd,CAAL,EAA2B;AACzB,YAAM,IAAIW,SAAJ,CACH,sCAAqC,OAAOX,KAAM,EAD/C,CAAN;AAGD;;AAED,UAAMc,MAAM,GAAGtB,KAAK,CAACQ,KAAD,EAAQC,SAAR,CAApB,CAXiC,CAajC;;AACA,UAAMN,KAAK,CAAC,CAAD,CAAX;AACA,WAAOS,gBAAgB,CAAC,MAAOW,EAAP,IAAc;AACpC,YAAMC,aAAa,GAAG,EAAtB;;AACA,WAAK,MAAMC,KAAX,IAAoBH,MAApB,EAA4B;AAC1BE,QAAAA,aAAa,CAACE,IAAd,CAAmB,MAAMH,EAAE,CAAChB,SAAD,CAAF,CAAcoB,MAAd,CAAqBF,KAArB,EAA4Bf,SAA5B,CAAzB;AACD;;AACD,aAAOR,OAAO,CAACsB,aAAD,CAAd;AACD,KANsB,CAAvB;AAOD,GAtBD,CADK,EAwBL;AACEd,IAAAA,SAAS,CAACkB,OAAD,EAAU;AACjBlB,MAAAA,SAAS,GAAGkB,OAAZ;AAEA,aAAO,IAAP;AACD,KALH;;AAMEC,IAAAA,WAAW,CAACN,EAAD,EAAK;AACdZ,MAAAA,WAAW,GAAGY,EAAd;AAEA,aAAO,IAAP;AACD;;AAVH,GAxBK,CAAP;AAqCD;;AAEDO,MAAM,CAACC,OAAP,GAAiB1B,WAAjB","sourcesContent":["const chunk = require('lodash/chunk');\nconst flatten = require('lodash/flatten');\nconst delay = require('./internal/delay');\nconst { isNumber } = require('../util/is');\n\nfunction batchInsert(client, tableName, batch, chunkSize = 1000) {\n  let returning = void 0;\n  let transaction = null;\n\n  const runInTransaction = (cb) => {\n    if (transaction) {\n      return cb(transaction);\n    }\n    return client.transaction(cb);\n  };\n\n  return Object.assign(\n    Promise.resolve().then(async () => {\n      if (!isNumber(chunkSize) || chunkSize < 1) {\n        throw new TypeError(`Invalid chunkSize: ${chunkSize}`);\n      }\n\n      if (!Array.isArray(batch)) {\n        throw new TypeError(\n          `Invalid batch: Expected array, got ${typeof batch}`\n        );\n      }\n\n      const chunks = chunk(batch, chunkSize);\n\n      //Next tick to ensure wrapper functions are called if needed\n      await delay(1);\n      return runInTransaction(async (tr) => {\n        const chunksResults = [];\n        for (const items of chunks) {\n          chunksResults.push(await tr(tableName).insert(items, returning));\n        }\n        return flatten(chunksResults);\n      });\n    }),\n    {\n      returning(columns) {\n        returning = columns;\n\n        return this;\n      },\n      transacting(tr) {\n        transaction = tr;\n\n        return this;\n      },\n    }\n  );\n}\n\nmodule.exports = batchInsert;\n"]},"metadata":{},"sourceType":"script"}