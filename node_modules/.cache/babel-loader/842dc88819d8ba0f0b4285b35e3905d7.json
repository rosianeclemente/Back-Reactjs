{"ast":null,"code":"const assert = require('assert'); // JoinClause\n// -------\n\n\nfunction getClauseFromArguments(compilerType, bool, first, operator, second) {\n  if (typeof first === 'function') {\n    return {\n      type: 'onWrapped',\n      value: first,\n      bool: bool\n    };\n  }\n\n  switch (arguments.length) {\n    case 3:\n      return {\n        type: 'onRaw',\n        value: first,\n        bool\n      };\n\n    case 4:\n      return {\n        type: compilerType,\n        column: first,\n        operator: '=',\n        value: operator,\n        bool\n      };\n\n    default:\n      return {\n        type: compilerType,\n        column: first,\n        operator,\n        value: second,\n        bool\n      };\n  }\n} // The \"JoinClause\" is an object holding any necessary info about a join,\n// including the type, and any associated tables & columns being joined.\n\n\nclass JoinClause {\n  constructor(table, type, schema) {\n    this.schema = schema;\n    this.table = table;\n    this.joinType = type;\n    this.and = this;\n    this.clauses = [];\n  }\n\n  get or() {\n    return this._bool('or');\n  } // Adds an \"on\" clause to the current join object.\n\n\n  on(first) {\n    if (typeof first === 'object' && typeof first.toSQL !== 'function') {\n      const keys = Object.keys(first);\n      let i = -1;\n      const method = this._bool() === 'or' ? 'orOn' : 'on';\n\n      while (++i < keys.length) {\n        this[method](keys[i], first[keys[i]]);\n      }\n\n      return this;\n    }\n\n    const data = getClauseFromArguments('onBasic', this._bool(), ...arguments);\n\n    if (data) {\n      this.clauses.push(data);\n    }\n\n    return this;\n  } // Adds a \"using\" clause to the current join.\n\n\n  using(column) {\n    return this.clauses.push({\n      type: 'onUsing',\n      column,\n      bool: this._bool()\n    });\n  } // Adds an \"or on\" clause to the current join object.\n\n\n  orOn(first, operator, second) {\n    return this._bool('or').on.apply(this, arguments);\n  }\n\n  onVal(first) {\n    if (typeof first === 'object' && typeof first.toSQL !== 'function') {\n      const keys = Object.keys(first);\n      let i = -1;\n      const method = this._bool() === 'or' ? 'orOnVal' : 'onVal';\n\n      while (++i < keys.length) {\n        this[method](keys[i], first[keys[i]]);\n      }\n\n      return this;\n    }\n\n    const data = getClauseFromArguments('onVal', this._bool(), ...arguments);\n\n    if (data) {\n      this.clauses.push(data);\n    }\n\n    return this;\n  }\n\n  andOnVal() {\n    return this.onVal(...arguments);\n  }\n\n  orOnVal() {\n    return this._bool('or').onVal(...arguments);\n  }\n\n  onBetween(column, values) {\n    assert(Array.isArray(values), 'The second argument to onBetween must be an array.');\n    assert(values.length === 2, 'You must specify 2 values for the onBetween clause');\n    this.clauses.push({\n      type: 'onBetween',\n      column,\n      value: values,\n      bool: this._bool(),\n      not: this._not()\n    });\n    return this;\n  }\n\n  onNotBetween(column, values) {\n    return this._not(true).onBetween(column, values);\n  }\n\n  orOnBetween(column, values) {\n    return this._bool('or').onBetween(column, values);\n  }\n\n  orOnNotBetween(column, values) {\n    return this._bool('or')._not(true).onBetween(column, values);\n  }\n\n  onIn(column, values) {\n    if (Array.isArray(values) && values.length === 0) return this.on(1, '=', 0);\n    this.clauses.push({\n      type: 'onIn',\n      column,\n      value: values,\n      not: this._not(),\n      bool: this._bool()\n    });\n    return this;\n  }\n\n  onNotIn(column, values) {\n    return this._not(true).onIn(column, values);\n  }\n\n  orOnIn(column, values) {\n    return this._bool('or').onIn(column, values);\n  }\n\n  orOnNotIn(column, values) {\n    return this._bool('or')._not(true).onIn(column, values);\n  }\n\n  onNull(column) {\n    this.clauses.push({\n      type: 'onNull',\n      column,\n      not: this._not(),\n      bool: this._bool()\n    });\n    return this;\n  }\n\n  orOnNull(callback) {\n    return this._bool('or').onNull(callback);\n  }\n\n  onNotNull(callback) {\n    return this._not(true).onNull(callback);\n  }\n\n  orOnNotNull(callback) {\n    return this._not(true)._bool('or').onNull(callback);\n  }\n\n  onExists(callback) {\n    this.clauses.push({\n      type: 'onExists',\n      value: callback,\n      not: this._not(),\n      bool: this._bool()\n    });\n    return this;\n  }\n\n  orOnExists(callback) {\n    return this._bool('or').onExists(callback);\n  }\n\n  onNotExists(callback) {\n    return this._not(true).onExists(callback);\n  }\n\n  orOnNotExists(callback) {\n    return this._not(true)._bool('or').onExists(callback);\n  } // Explicitly set the type of join, useful within a function when creating a grouped join.\n\n\n  type(type) {\n    this.joinType = type;\n    return this;\n  }\n\n  _bool(bool) {\n    if (arguments.length === 1) {\n      this._boolFlag = bool;\n      return this;\n    }\n\n    const ret = this._boolFlag || 'and';\n    this._boolFlag = 'and';\n    return ret;\n  }\n\n  _not(val) {\n    if (arguments.length === 1) {\n      this._notFlag = val;\n      return this;\n    }\n\n    const ret = this._notFlag;\n    this._notFlag = false;\n    return ret;\n  }\n\n}\n\nObject.assign(JoinClause.prototype, {\n  grouping: 'join'\n});\nJoinClause.prototype.andOn = JoinClause.prototype.on;\nJoinClause.prototype.andOnIn = JoinClause.prototype.onIn;\nJoinClause.prototype.andOnNotIn = JoinClause.prototype.onNotIn;\nJoinClause.prototype.andOnNull = JoinClause.prototype.onNull;\nJoinClause.prototype.andOnNotNull = JoinClause.prototype.onNotNull;\nJoinClause.prototype.andOnExists = JoinClause.prototype.onExists;\nJoinClause.prototype.andOnNotExists = JoinClause.prototype.onNotExists;\nJoinClause.prototype.andOnBetween = JoinClause.prototype.onBetween;\nJoinClause.prototype.andOnNotBetween = JoinClause.prototype.onNotBetween;\nmodule.exports = JoinClause;","map":{"version":3,"sources":["/home/rosiane/back/node_modules/knex/lib/query/joinclause.js"],"names":["assert","require","getClauseFromArguments","compilerType","bool","first","operator","second","type","value","arguments","length","column","JoinClause","constructor","table","schema","joinType","and","clauses","or","_bool","on","toSQL","keys","Object","i","method","data","push","using","orOn","apply","onVal","andOnVal","orOnVal","onBetween","values","Array","isArray","not","_not","onNotBetween","orOnBetween","orOnNotBetween","onIn","onNotIn","orOnIn","orOnNotIn","onNull","orOnNull","callback","onNotNull","orOnNotNull","onExists","orOnExists","onNotExists","orOnNotExists","_boolFlag","ret","val","_notFlag","assign","prototype","grouping","andOn","andOnIn","andOnNotIn","andOnNull","andOnNotNull","andOnExists","andOnNotExists","andOnBetween","andOnNotBetween","module","exports"],"mappings":"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","sourcesContent":["const assert = require('assert');\n\n// JoinClause\n// -------\n\nfunction getClauseFromArguments(compilerType, bool, first, operator, second) {\n  if (typeof first === 'function') {\n    return {\n      type: 'onWrapped',\n      value: first,\n      bool: bool,\n    };\n  }\n\n  switch (arguments.length) {\n    case 3:\n      return { type: 'onRaw', value: first, bool };\n    case 4:\n      return {\n        type: compilerType,\n        column: first,\n        operator: '=',\n        value: operator,\n        bool,\n      };\n    default:\n      return {\n        type: compilerType,\n        column: first,\n        operator,\n        value: second,\n        bool,\n      };\n  }\n}\n\n// The \"JoinClause\" is an object holding any necessary info about a join,\n// including the type, and any associated tables & columns being joined.\nclass JoinClause {\n  constructor(table, type, schema) {\n    this.schema = schema;\n    this.table = table;\n    this.joinType = type;\n    this.and = this;\n    this.clauses = [];\n  }\n\n  get or() {\n    return this._bool('or');\n  }\n\n  // Adds an \"on\" clause to the current join object.\n  on(first) {\n    if (typeof first === 'object' && typeof first.toSQL !== 'function') {\n      const keys = Object.keys(first);\n      let i = -1;\n      const method = this._bool() === 'or' ? 'orOn' : 'on';\n      while (++i < keys.length) {\n        this[method](keys[i], first[keys[i]]);\n      }\n      return this;\n    }\n\n    const data = getClauseFromArguments('onBasic', this._bool(), ...arguments);\n\n    if (data) {\n      this.clauses.push(data);\n    }\n\n    return this;\n  }\n\n  // Adds a \"using\" clause to the current join.\n  using(column) {\n    return this.clauses.push({ type: 'onUsing', column, bool: this._bool() });\n  }\n\n  // Adds an \"or on\" clause to the current join object.\n  orOn(first, operator, second) {\n    return this._bool('or').on.apply(this, arguments);\n  }\n\n  onVal(first) {\n    if (typeof first === 'object' && typeof first.toSQL !== 'function') {\n      const keys = Object.keys(first);\n      let i = -1;\n      const method = this._bool() === 'or' ? 'orOnVal' : 'onVal';\n      while (++i < keys.length) {\n        this[method](keys[i], first[keys[i]]);\n      }\n      return this;\n    }\n\n    const data = getClauseFromArguments('onVal', this._bool(), ...arguments);\n\n    if (data) {\n      this.clauses.push(data);\n    }\n\n    return this;\n  }\n\n  andOnVal() {\n    return this.onVal(...arguments);\n  }\n\n  orOnVal() {\n    return this._bool('or').onVal(...arguments);\n  }\n\n  onBetween(column, values) {\n    assert(\n      Array.isArray(values),\n      'The second argument to onBetween must be an array.'\n    );\n    assert(\n      values.length === 2,\n      'You must specify 2 values for the onBetween clause'\n    );\n    this.clauses.push({\n      type: 'onBetween',\n      column,\n      value: values,\n      bool: this._bool(),\n      not: this._not(),\n    });\n    return this;\n  }\n\n  onNotBetween(column, values) {\n    return this._not(true).onBetween(column, values);\n  }\n\n  orOnBetween(column, values) {\n    return this._bool('or').onBetween(column, values);\n  }\n\n  orOnNotBetween(column, values) {\n    return this._bool('or')._not(true).onBetween(column, values);\n  }\n\n  onIn(column, values) {\n    if (Array.isArray(values) && values.length === 0) return this.on(1, '=', 0);\n    this.clauses.push({\n      type: 'onIn',\n      column,\n      value: values,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  onNotIn(column, values) {\n    return this._not(true).onIn(column, values);\n  }\n\n  orOnIn(column, values) {\n    return this._bool('or').onIn(column, values);\n  }\n\n  orOnNotIn(column, values) {\n    return this._bool('or')._not(true).onIn(column, values);\n  }\n\n  onNull(column) {\n    this.clauses.push({\n      type: 'onNull',\n      column,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  orOnNull(callback) {\n    return this._bool('or').onNull(callback);\n  }\n\n  onNotNull(callback) {\n    return this._not(true).onNull(callback);\n  }\n\n  orOnNotNull(callback) {\n    return this._not(true)._bool('or').onNull(callback);\n  }\n\n  onExists(callback) {\n    this.clauses.push({\n      type: 'onExists',\n      value: callback,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  orOnExists(callback) {\n    return this._bool('or').onExists(callback);\n  }\n\n  onNotExists(callback) {\n    return this._not(true).onExists(callback);\n  }\n\n  orOnNotExists(callback) {\n    return this._not(true)._bool('or').onExists(callback);\n  }\n\n  // Explicitly set the type of join, useful within a function when creating a grouped join.\n  type(type) {\n    this.joinType = type;\n    return this;\n  }\n\n  _bool(bool) {\n    if (arguments.length === 1) {\n      this._boolFlag = bool;\n      return this;\n    }\n    const ret = this._boolFlag || 'and';\n    this._boolFlag = 'and';\n    return ret;\n  }\n\n  _not(val) {\n    if (arguments.length === 1) {\n      this._notFlag = val;\n      return this;\n    }\n    const ret = this._notFlag;\n    this._notFlag = false;\n    return ret;\n  }\n}\n\nObject.assign(JoinClause.prototype, {\n  grouping: 'join',\n});\n\nJoinClause.prototype.andOn = JoinClause.prototype.on;\nJoinClause.prototype.andOnIn = JoinClause.prototype.onIn;\nJoinClause.prototype.andOnNotIn = JoinClause.prototype.onNotIn;\nJoinClause.prototype.andOnNull = JoinClause.prototype.onNull;\nJoinClause.prototype.andOnNotNull = JoinClause.prototype.onNotNull;\nJoinClause.prototype.andOnExists = JoinClause.prototype.onExists;\nJoinClause.prototype.andOnNotExists = JoinClause.prototype.onNotExists;\nJoinClause.prototype.andOnBetween = JoinClause.prototype.onBetween;\nJoinClause.prototype.andOnNotBetween = JoinClause.prototype.onNotBetween;\n\nmodule.exports = JoinClause;\n"]},"metadata":{},"sourceType":"script"}