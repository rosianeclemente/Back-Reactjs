{"ast":null,"code":"const isPlainObject = require('lodash/isPlainObject');\n\nconst isTypedArray = require('lodash/isTypedArray');\n\nconst {\n  CLIENT_ALIASES\n} = require('../constants');\n\nconst {\n  isFunction\n} = require('./is'); // Check if the first argument is an array, otherwise uses all arguments as an\n// array.\n\n\nfunction normalizeArr(...args) {\n  if (Array.isArray(args[0])) {\n    return args[0];\n  }\n\n  return args;\n}\n\nfunction containsUndefined(mixed) {\n  let argContainsUndefined = false;\n  if (isTypedArray(mixed)) return false;\n\n  if (mixed && isFunction(mixed.toSQL)) {\n    //Any QueryBuilder or Raw will automatically be validated during compile.\n    return argContainsUndefined;\n  }\n\n  if (Array.isArray(mixed)) {\n    for (let i = 0; i < mixed.length; i++) {\n      if (argContainsUndefined) break;\n      argContainsUndefined = containsUndefined(mixed[i]);\n    }\n  } else if (isPlainObject(mixed)) {\n    Object.keys(mixed).forEach(key => {\n      if (!argContainsUndefined) {\n        argContainsUndefined = containsUndefined(mixed[key]);\n      }\n    });\n  } else {\n    argContainsUndefined = mixed === undefined;\n  }\n\n  return argContainsUndefined;\n}\n\nfunction getUndefinedIndices(mixed) {\n  const indices = [];\n\n  if (Array.isArray(mixed)) {\n    mixed.forEach((item, index) => {\n      if (containsUndefined(item)) {\n        indices.push(index);\n      }\n    });\n  } else if (isPlainObject(mixed)) {\n    Object.keys(mixed).forEach(key => {\n      if (containsUndefined(mixed[key])) {\n        indices.push(key);\n      }\n    });\n  } else {\n    indices.push(0);\n  }\n\n  return indices;\n}\n\nfunction addQueryContext(Target) {\n  // Stores or returns (if called with no arguments) context passed to\n  // wrapIdentifier and postProcessResponse hooks\n  Target.prototype.queryContext = function (context) {\n    if (context === undefined) {\n      return this._queryContext;\n    }\n\n    this._queryContext = context;\n    return this;\n  };\n}\n\nfunction resolveClientNameWithAliases(clientName) {\n  return CLIENT_ALIASES[clientName] || clientName;\n}\n\nfunction toNumber(val, fallback) {\n  if (val === undefined || val === null) return fallback;\n  const number = parseInt(val, 10);\n  return isNaN(number) ? fallback : number;\n}\n\nmodule.exports = {\n  addQueryContext,\n  containsUndefined,\n  getUndefinedIndices,\n  normalizeArr,\n  resolveClientNameWithAliases,\n  toNumber\n};","map":{"version":3,"sources":["/home/rosiane/Projeto-completo/back/node_modules/knex/lib/util/helpers.js"],"names":["isPlainObject","require","isTypedArray","CLIENT_ALIASES","isFunction","normalizeArr","args","Array","isArray","containsUndefined","mixed","argContainsUndefined","toSQL","i","length","Object","keys","forEach","key","undefined","getUndefinedIndices","indices","item","index","push","addQueryContext","Target","prototype","queryContext","context","_queryContext","resolveClientNameWithAliases","clientName","toNumber","val","fallback","number","parseInt","isNaN","module","exports"],"mappings":"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","sourcesContent":["const isPlainObject = require('lodash/isPlainObject');\nconst isTypedArray = require('lodash/isTypedArray');\nconst { CLIENT_ALIASES } = require('../constants');\nconst { isFunction } = require('./is');\n\n// Check if the first argument is an array, otherwise uses all arguments as an\n// array.\nfunction normalizeArr(...args) {\n  if (Array.isArray(args[0])) {\n    return args[0];\n  }\n\n  return args;\n}\n\nfunction containsUndefined(mixed) {\n  let argContainsUndefined = false;\n\n  if (isTypedArray(mixed)) return false;\n\n  if (mixed && isFunction(mixed.toSQL)) {\n    //Any QueryBuilder or Raw will automatically be validated during compile.\n    return argContainsUndefined;\n  }\n\n  if (Array.isArray(mixed)) {\n    for (let i = 0; i < mixed.length; i++) {\n      if (argContainsUndefined) break;\n      argContainsUndefined = containsUndefined(mixed[i]);\n    }\n  } else if (isPlainObject(mixed)) {\n    Object.keys(mixed).forEach((key) => {\n      if (!argContainsUndefined) {\n        argContainsUndefined = containsUndefined(mixed[key]);\n      }\n    });\n  } else {\n    argContainsUndefined = mixed === undefined;\n  }\n\n  return argContainsUndefined;\n}\n\nfunction getUndefinedIndices(mixed) {\n  const indices = [];\n\n  if (Array.isArray(mixed)) {\n    mixed.forEach((item, index) => {\n      if (containsUndefined(item)) {\n        indices.push(index);\n      }\n    });\n  } else if (isPlainObject(mixed)) {\n    Object.keys(mixed).forEach((key) => {\n      if (containsUndefined(mixed[key])) {\n        indices.push(key);\n      }\n    });\n  } else {\n    indices.push(0);\n  }\n\n  return indices;\n}\n\nfunction addQueryContext(Target) {\n  // Stores or returns (if called with no arguments) context passed to\n  // wrapIdentifier and postProcessResponse hooks\n  Target.prototype.queryContext = function (context) {\n    if (context === undefined) {\n      return this._queryContext;\n    }\n    this._queryContext = context;\n    return this;\n  };\n}\n\nfunction resolveClientNameWithAliases(clientName) {\n  return CLIENT_ALIASES[clientName] || clientName;\n}\n\nfunction toNumber(val, fallback) {\n  if (val === undefined || val === null) return fallback;\n  const number = parseInt(val, 10);\n  return isNaN(number) ? fallback : number;\n}\n\nmodule.exports = {\n  addQueryContext,\n  containsUndefined,\n  getUndefinedIndices,\n  normalizeArr,\n  resolveClientNameWithAliases,\n  toNumber,\n};\n"]},"metadata":{},"sourceType":"script"}