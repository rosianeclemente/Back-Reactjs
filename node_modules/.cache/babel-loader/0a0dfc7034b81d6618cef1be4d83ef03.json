{"ast":null,"code":"// Query Compiler\n// -------\nconst helpers = require('../util/helpers');\n\nconst Raw = require('../raw');\n\nconst QueryBuilder = require('./querybuilder');\n\nconst JoinClause = require('./joinclause');\n\nconst debug = require('debug');\n\nconst assign = require('lodash/assign');\n\nconst compact = require('lodash/compact');\n\nconst groupBy = require('lodash/groupBy');\n\nconst has = require('lodash/has');\n\nconst isEmpty = require('lodash/isEmpty');\n\nconst map = require('lodash/map');\n\nconst omitBy = require('lodash/omitBy');\n\nconst reduce = require('lodash/reduce');\n\nconst {\n  nanoid\n} = require('../util/nanoid');\n\nconst {\n  isString,\n  isUndefined\n} = require('../util/is');\n\nconst {\n  columnize: columnize_,\n  direction: direction_,\n  operator: operator_,\n  wrap: wrap_,\n  unwrapRaw: unwrapRaw_,\n  rawOrFn: rawOrFn_\n} = require('../formatter/wrappingFormatter');\n\nconst debugBindings = debug('knex:bindings');\nconst components = ['columns', 'join', 'where', 'union', 'group', 'having', 'order', 'limit', 'offset', 'lock', 'waitMode']; // The \"QueryCompiler\" takes all of the query statements which\n// have been gathered in the \"QueryBuilder\" and turns them into a\n// properly formatted / bound query string.\n\nclass QueryCompiler {\n  constructor(client, builder, bindings) {\n    this.client = client;\n    this.method = builder._method || 'select';\n    this.options = builder._options;\n    this.single = builder._single;\n    this.timeout = builder._timeout || false;\n    this.cancelOnTimeout = builder._cancelOnTimeout || false;\n    this.grouped = groupBy(builder._statements, 'grouping');\n    this.formatter = client.formatter(builder); // Used when the insert call is empty.\n\n    this._emptyInsertValue = 'default values';\n    this.first = this.select;\n    this.bindings = bindings || [];\n    this.formatter.bindings = this.bindings;\n    this.bindingsHolder = this;\n    this.builder = this.formatter.builder;\n  } // Collapse the builder into a single object\n\n\n  toSQL(method, tz) {\n    this._undefinedInWhereClause = false;\n    this.undefinedBindingsInfo = [];\n    method = method || this.method;\n    const val = this[method]() || '';\n    const query = {\n      method,\n      options: reduce(this.options, assign, {}),\n      timeout: this.timeout,\n      cancelOnTimeout: this.cancelOnTimeout,\n      bindings: this.bindingsHolder.bindings || [],\n      __knexQueryUid: nanoid()\n    };\n    Object.defineProperties(query, {\n      toNative: {\n        value: () => {\n          return {\n            sql: this.client.positionBindings(query.sql),\n            bindings: this.client.prepBindings(query.bindings)\n          };\n        },\n        enumerable: false\n      }\n    });\n\n    if (isString(val)) {\n      query.sql = val;\n    } else {\n      assign(query, val);\n    }\n\n    if (method === 'select' || method === 'first') {\n      if (this.single.as) {\n        query.as = this.single.as;\n      }\n    }\n\n    if (this._undefinedInWhereClause) {\n      debugBindings(query.bindings);\n      throw new Error(`Undefined binding(s) detected when compiling ` + `${method.toUpperCase()}. Undefined column(s): [${this.undefinedBindingsInfo.join(', ')}] query: ${query.sql}`);\n    }\n\n    return query;\n  } // Compiles the `select` statement, or nested sub-selects by calling each of\n  // the component compilers, trimming out the empties, and returning a\n  // generated query string.\n\n\n  select() {\n    let sql = this.with();\n    const statements = components.map(component => this[component](this));\n    sql += compact(statements).join(' ');\n    return sql;\n  }\n\n  pluck() {\n    let toPluck = this.single.pluck;\n\n    if (toPluck.indexOf('.') !== -1) {\n      toPluck = toPluck.split('.').slice(-1)[0];\n    }\n\n    return {\n      sql: this.select(),\n      pluck: toPluck\n    };\n  } // Compiles an \"insert\" query, allowing for multiple\n  // inserts using a single query statement.\n\n\n  insert() {\n    const insertValues = this.single.insert || [];\n    let sql = this.with() + `insert into ${this.tableName} `;\n\n    if (Array.isArray(insertValues)) {\n      if (insertValues.length === 0) {\n        return '';\n      }\n    } else if (typeof insertValues === 'object' && isEmpty(insertValues)) {\n      return sql + this._emptyInsertValue;\n    }\n\n    const insertData = this._prepInsert(insertValues);\n\n    if (typeof insertData === 'string') {\n      sql += insertData;\n    } else {\n      if (insertData.columns.length) {\n        sql += `(${columnize_(insertData.columns, this.builder, this.client, this.bindingsHolder)}`;\n        sql += ') values (';\n        let i = -1;\n\n        while (++i < insertData.values.length) {\n          if (i !== 0) sql += '), (';\n          sql += this.client.parameterize(insertData.values[i], this.client.valueForUndefined, this.builder, this.bindingsHolder);\n        }\n\n        sql += ')';\n      } else if (insertValues.length === 1 && insertValues[0]) {\n        sql += this._emptyInsertValue;\n      } else {\n        sql = '';\n      }\n    }\n\n    return sql;\n  } // Compiles the \"update\" query.\n\n\n  update() {\n    // Make sure tableName is processed by the formatter first.\n    const withSQL = this.with();\n    const {\n      tableName\n    } = this;\n\n    const updateData = this._prepUpdate(this.single.update);\n\n    const wheres = this.where();\n    return withSQL + `update ${this.single.only ? 'only ' : ''}${tableName}` + ' set ' + updateData.join(', ') + (wheres ? ` ${wheres}` : '');\n  }\n\n  _hintComments() {\n    let hints = this.grouped.hintComments || [];\n    hints = hints.map(hint => compact(hint.value).join(' '));\n    hints = compact(hints).join(' ');\n    return hints ? `/*+ ${hints} */ ` : '';\n  } // Compiles the columns in the query, specifying if an item was distinct.\n\n\n  columns() {\n    let distinctClause = '';\n    if (this.onlyUnions()) return '';\n\n    const hints = this._hintComments();\n\n    const columns = this.grouped.columns || [];\n    let i = -1,\n        sql = [];\n\n    if (columns) {\n      while (++i < columns.length) {\n        const stmt = columns[i];\n        if (stmt.distinct) distinctClause = 'distinct ';\n\n        if (stmt.distinctOn) {\n          distinctClause = this.distinctOn(stmt.value);\n          continue;\n        }\n\n        if (stmt.type === 'aggregate') {\n          sql.push(...this.aggregate(stmt));\n        } else if (stmt.type === 'aggregateRaw') {\n          sql.push(this.aggregateRaw(stmt));\n        } else if (stmt.type === 'analytic') {\n          sql.push(this.analytic(stmt));\n        } else if (stmt.value && stmt.value.length > 0) {\n          sql.push(columnize_(stmt.value, this.builder, this.client, this.bindingsHolder));\n        }\n      }\n    }\n\n    if (sql.length === 0) sql = ['*'];\n    return `select ${hints}${distinctClause}` + sql.join(', ') + (this.tableName ? ` from ${this.single.only ? 'only ' : ''}${this.tableName}` : '');\n  }\n\n  _aggregate(stmt, {\n    aliasSeparator = ' as ',\n    distinctParentheses\n  } = {}) {\n    const value = stmt.value;\n    const method = stmt.method;\n    const distinct = stmt.aggregateDistinct ? 'distinct ' : '';\n\n    const wrap = identifier => wrap_(identifier, undefined, this.builder, this.client, this.bindingsHolder);\n\n    const addAlias = (value, alias) => {\n      if (alias) {\n        return value + aliasSeparator + wrap(alias);\n      }\n\n      return value;\n    };\n\n    const aggregateArray = (value, alias) => {\n      let columns = value.map(wrap).join(', ');\n\n      if (distinct) {\n        const openParen = distinctParentheses ? '(' : ' ';\n        const closeParen = distinctParentheses ? ')' : '';\n        columns = distinct.trim() + openParen + columns + closeParen;\n      }\n\n      const aggregated = `${method}(${columns})`;\n      return addAlias(aggregated, alias);\n    };\n\n    const aggregateString = (value, alias) => {\n      const aggregated = `${method}(${distinct + wrap(value)})`;\n      return addAlias(aggregated, alias);\n    };\n\n    if (Array.isArray(value)) {\n      return [aggregateArray(value)];\n    }\n\n    if (typeof value === 'object') {\n      if (stmt.alias) {\n        throw new Error('When using an object explicit alias can not be used');\n      }\n\n      return Object.entries(value).map(([alias, column]) => {\n        if (Array.isArray(column)) {\n          return aggregateArray(column, alias);\n        }\n\n        return aggregateString(column, alias);\n      });\n    } // Allows us to speciy an alias for the aggregate types.\n\n\n    const splitOn = value.toLowerCase().indexOf(' as ');\n    let column = value;\n    let {\n      alias\n    } = stmt;\n\n    if (splitOn !== -1) {\n      column = value.slice(0, splitOn);\n\n      if (alias) {\n        throw new Error(`Found multiple aliases for same column: ${column}`);\n      }\n\n      alias = value.slice(splitOn + 4);\n    }\n\n    return [aggregateString(column, alias)];\n  }\n\n  aggregate(stmt) {\n    return this._aggregate(stmt);\n  }\n\n  aggregateRaw(stmt) {\n    const distinct = stmt.aggregateDistinct ? 'distinct ' : '';\n    return `${stmt.method}(${distinct + unwrapRaw_(stmt.value, undefined, this.builder, this.client, this.bindingsHolder)})`;\n  } // Compiles all each of the `join` clauses on the query,\n  // including any nested join queries.\n\n\n  join() {\n    let sql = '';\n    let i = -1;\n    const joins = this.grouped.join;\n    if (!joins) return '';\n\n    while (++i < joins.length) {\n      const join = joins[i];\n      const table = join.schema && !(join.table instanceof Raw) ? `${join.schema}.${join.table}` : join.table;\n      if (i > 0) sql += ' ';\n\n      if (join.joinType === 'raw') {\n        sql += unwrapRaw_(join.table, undefined, this.builder, this.client, this.bindingsHolder);\n      } else {\n        sql += join.joinType + ' join ' + wrap_(table, undefined, this.builder, this.client, this.bindingsHolder);\n        let ii = -1;\n\n        while (++ii < join.clauses.length) {\n          const clause = join.clauses[ii];\n\n          if (ii > 0) {\n            sql += ` ${clause.bool} `;\n          } else {\n            sql += ` ${clause.type === 'onUsing' ? 'using' : 'on'} `;\n          }\n\n          const val = this[clause.type](clause);\n\n          if (val) {\n            sql += val;\n          }\n        }\n      }\n    }\n\n    return sql;\n  }\n\n  onBetween(statement) {\n    return wrap_(statement.column, undefined, this.builder, this.client, this.bindingsHolder) + ' ' + this._not(statement, 'between') + ' ' + statement.value.map(value => this.client.parameter(value, this.builder, this.bindingsHolder)).join(' and ');\n  }\n\n  onNull(statement) {\n    return wrap_(statement.column, undefined, this.builder, this.client, this.bindingsHolder) + ' is ' + this._not(statement, 'null');\n  }\n\n  onExists(statement) {\n    return this._not(statement, 'exists') + ' (' + rawOrFn_(statement.value, undefined, this.builder, this.client, this.bindingsHolder) + ')';\n  }\n\n  onIn(statement) {\n    if (Array.isArray(statement.column)) return this.multiOnIn(statement);\n    return wrap_(statement.column, undefined, this.builder, this.client, this.bindingsHolder) + ' ' + this._not(statement, 'in ') + this.wrap(this.client.parameterize(statement.value, undefined, this.builder, this.bindingsHolder));\n  }\n\n  multiOnIn(statement) {\n    let i = -1,\n        sql = `(${columnize_(statement.column, this.builder, this.client, this.bindingsHolder)}) `;\n    sql += this._not(statement, 'in ') + '((';\n\n    while (++i < statement.value.length) {\n      if (i !== 0) sql += '),(';\n      sql += this.client.parameterize(statement.value[i], undefined, this.builder, this.bindingsHolder);\n    }\n\n    return sql + '))';\n  } // Compiles all `where` statements on the query.\n\n\n  where() {\n    const wheres = this.grouped.where;\n    if (!wheres) return;\n    const sql = [];\n    let i = -1;\n\n    while (++i < wheres.length) {\n      const stmt = wheres[i];\n\n      if (Object.prototype.hasOwnProperty.call(stmt, 'value') && helpers.containsUndefined(stmt.value)) {\n        this.undefinedBindingsInfo.push(stmt.column);\n        this._undefinedInWhereClause = true;\n      }\n\n      const val = this[stmt.type](stmt);\n\n      if (val) {\n        if (sql.length === 0) {\n          sql[0] = 'where';\n        } else {\n          sql.push(stmt.bool);\n        }\n\n        sql.push(val);\n      }\n    }\n\n    return sql.length > 1 ? sql.join(' ') : '';\n  }\n\n  group() {\n    return this._groupsOrders('group');\n  }\n\n  order() {\n    return this._groupsOrders('order');\n  } // Compiles the `having` statements.\n\n\n  having() {\n    const havings = this.grouped.having;\n    if (!havings) return '';\n    const sql = ['having'];\n\n    for (let i = 0, l = havings.length; i < l; i++) {\n      const s = havings[i];\n      const val = this[s.type](s);\n\n      if (val) {\n        if (sql.length === 0) {\n          sql[0] = 'where';\n        }\n\n        if (sql.length > 1 || sql.length === 1 && sql[0] !== 'having') {\n          sql.push(s.bool);\n        }\n\n        sql.push(val);\n      }\n    }\n\n    return sql.length > 1 ? sql.join(' ') : '';\n  }\n\n  havingRaw(statement) {\n    return this._not(statement, '') + unwrapRaw_(statement.value, undefined, this.builder, this.client, this.bindingsHolder);\n  }\n\n  havingWrapped(statement) {\n    const val = rawOrFn_(statement.value, 'where', this.builder, this.client, this.bindingsHolder);\n    return val && this._not(statement, '') + '(' + val.slice(6) + ')' || '';\n  }\n\n  havingBasic(statement) {\n    return this._not(statement, '') + wrap_(statement.column, undefined, this.builder, this.client, this.bindingsHolder) + ' ' + operator_(statement.operator, this.builder, this.client, this.bindingsHolder) + ' ' + this.client.parameter(statement.value, this.builder, this.bindingsHolder);\n  }\n\n  havingNull(statement) {\n    return wrap_(statement.column, undefined, this.builder, this.client, this.bindingsHolder) + ' is ' + this._not(statement, 'null');\n  }\n\n  havingExists(statement) {\n    return this._not(statement, 'exists') + ' (' + rawOrFn_(statement.value, undefined, this.builder, this.client, this.bindingsHolder) + ')';\n  }\n\n  havingBetween(statement) {\n    return wrap_(statement.column, undefined, this.builder, this.client, this.bindingsHolder) + ' ' + this._not(statement, 'between') + ' ' + statement.value.map(value => this.client.parameter(value, this.builder, this.bindingsHolder)).join(' and ');\n  }\n\n  havingIn(statement) {\n    if (Array.isArray(statement.column)) return this.multiHavingIn(statement);\n    return wrap_(statement.column, undefined, this.builder, this.client, this.bindingsHolder) + ' ' + this._not(statement, 'in ') + this.wrap(this.client.parameterize(statement.value, undefined, this.builder, this.bindingsHolder));\n  }\n\n  multiHavingIn(statement) {\n    let i = -1,\n        sql = `(${columnize_(statement.column, this.builder, this.client, this.bindingsHolder)}) `;\n    sql += this._not(statement, 'in ') + '((';\n\n    while (++i < statement.value.length) {\n      if (i !== 0) sql += '),(';\n      sql += this.client.parameterize(statement.value[i], undefined, this.builder, this.bindingsHolder);\n    }\n\n    return sql + '))';\n  } // Compile the \"union\" queries attached to the main query.\n\n\n  union() {\n    const onlyUnions = this.onlyUnions();\n    const unions = this.grouped.union;\n    if (!unions) return '';\n    let sql = '';\n\n    for (let i = 0, l = unions.length; i < l; i++) {\n      const union = unions[i];\n      if (i > 0) sql += ' ';\n      if (i > 0 || !onlyUnions) sql += union.clause + ' ';\n      const statement = rawOrFn_(union.value, undefined, this.builder, this.client, this.bindingsHolder);\n\n      if (statement) {\n        if (union.wrap) sql += '(';\n        sql += statement;\n        if (union.wrap) sql += ')';\n      }\n    }\n\n    return sql;\n  } // If we haven't specified any columns or a `tableName`, we're assuming this\n  // is only being used for unions.\n\n\n  onlyUnions() {\n    return !this.grouped.columns && this.grouped.union && !this.tableName;\n  }\n\n  limit() {\n    const noLimit = !this.single.limit && this.single.limit !== 0;\n    if (noLimit) return '';\n    return `limit ${this.client.parameter(this.single.limit, this.builder, this.bindingsHolder)}`;\n  }\n\n  offset() {\n    if (!this.single.offset) return '';\n    return `offset ${this.client.parameter(this.single.offset, this.builder, this.bindingsHolder)}`;\n  } // Compiles a `delete` query.\n\n\n  del() {\n    // Make sure tableName is processed by the formatter first.\n    const {\n      tableName\n    } = this;\n    const withSQL = this.with();\n    const wheres = this.where();\n    return withSQL + `delete from ${this.single.only ? 'only ' : ''}${tableName}` + (wheres ? ` ${wheres}` : '');\n  } // Compiles a `truncate` query.\n\n\n  truncate() {\n    return `truncate ${this.tableName}`;\n  } // Compiles the \"locks\".\n\n\n  lock() {\n    if (this.single.lock) {\n      return this[this.single.lock]();\n    }\n  } // Compiles the wait mode on the locks.\n\n\n  waitMode() {\n    if (this.single.waitMode) {\n      return this[this.single.waitMode]();\n    }\n  } // Fail on unsupported databases\n\n\n  skipLocked() {\n    throw new Error('.skipLocked() is currently only supported on MySQL 8.0+ and PostgreSQL 9.5+');\n  } // Fail on unsupported databases\n\n\n  noWait() {\n    throw new Error('.noWait() is currently only supported on MySQL 8.0+, MariaDB 10.3.0+ and PostgreSQL 9.5+');\n  }\n\n  distinctOn(value) {\n    throw new Error('.distinctOn() is currently only supported on PostgreSQL');\n  } // On Clause\n  // ------\n\n\n  onWrapped(clause) {\n    const self = this;\n    const wrapJoin = new JoinClause();\n    clause.value.call(wrapJoin, wrapJoin);\n    let sql = '';\n\n    for (let ii = 0; ii < wrapJoin.clauses.length; ii++) {\n      const wrapClause = wrapJoin.clauses[ii];\n\n      if (ii > 0) {\n        sql += ` ${wrapClause.bool} `;\n      }\n\n      const val = self[wrapClause.type](wrapClause);\n\n      if (val) {\n        sql += val;\n      }\n    }\n\n    if (sql.length) {\n      return `(${sql})`;\n    }\n\n    return '';\n  }\n\n  onBasic(clause) {\n    return wrap_(clause.column, undefined, this.builder, this.client, this.bindingsHolder) + ' ' + operator_(clause.operator, this.builder, this.client, this.bindingsHolder) + ' ' + wrap_(clause.value, undefined, this.builder, this.client, this.bindingsHolder);\n  }\n\n  onVal(clause) {\n    return wrap_(clause.column, undefined, this.builder, this.client, this.bindingsHolder) + ' ' + operator_(clause.operator, this.builder, this.client, this.bindingsHolder) + ' ' + this.client.parameter(clause.value, this.builder, this.bindingsHolder);\n  }\n\n  onRaw(clause) {\n    return unwrapRaw_(clause.value, undefined, this.builder, this.client, this.bindingsHolder);\n  }\n\n  onUsing(clause) {\n    return '(' + columnize_(clause.column, this.builder, this.client, this.bindingsHolder) + ')';\n  } // Where Clause\n  // ------\n\n\n  whereIn(statement) {\n    let columns;\n\n    if (Array.isArray(statement.column)) {\n      columns = `(${columnize_(statement.column, this.builder, this.client, this.bindingsHolder)})`;\n    } else {\n      columns = wrap_(statement.column, undefined, this.builder, this.client, this.bindingsHolder);\n    }\n\n    const values = this.client.values(statement.value, this.builder, this.bindingsHolder);\n    return `${columns} ${this._not(statement, 'in ')}${values}`;\n  }\n\n  whereNull(statement) {\n    return wrap_(statement.column, undefined, this.builder, this.client, this.bindingsHolder) + ' is ' + this._not(statement, 'null');\n  } // Compiles a basic \"where\" clause.\n\n\n  whereBasic(statement) {\n    return this._not(statement, '') + wrap_(statement.column, undefined, this.builder, this.client, this.bindingsHolder) + ' ' + operator_(statement.operator, this.builder, this.client, this.bindingsHolder) + ' ' + (statement.asColumn ? wrap_(statement.value, undefined, this.builder, this.client, this.bindingsHolder) : this.client.parameter(statement.value, this.builder, this.bindingsHolder));\n  }\n\n  whereExists(statement) {\n    return this._not(statement, 'exists') + ' (' + rawOrFn_(statement.value, undefined, this.builder, this.client, this.bindingsHolder) + ')';\n  }\n\n  whereWrapped(statement) {\n    const val = rawOrFn_(statement.value, 'where', this.builder, this.client, this.bindingsHolder);\n    return val && this._not(statement, '') + '(' + val.slice(6) + ')' || '';\n  }\n\n  whereBetween(statement) {\n    return wrap_(statement.column, undefined, this.builder, this.client, this.bindingsHolder) + ' ' + this._not(statement, 'between') + ' ' + statement.value.map(value => this.client.parameter(value, this.builder, this.bindingsHolder)).join(' and ');\n  } // Compiles a \"whereRaw\" query.\n\n\n  whereRaw(statement) {\n    return this._not(statement, '') + unwrapRaw_(statement.value, undefined, this.builder, this.client, this.bindingsHolder);\n  }\n\n  wrap(str) {\n    if (str.charAt(0) !== '(') return `(${str})`;\n    return str;\n  }\n\n  analytic(stmt) {\n    let sql = '';\n    const self = this;\n    sql += stmt.method + '() over (';\n\n    if (stmt.raw) {\n      sql += stmt.raw;\n    } else {\n      if (stmt.partitions.length) {\n        sql += 'partition by ';\n        sql += map(stmt.partitions, function (partition) {\n          return self.formatter.columnize(partition);\n        }).join(', ') + ' ';\n      }\n\n      sql += 'order by ';\n      sql += map(stmt.order, function (order) {\n        return self.formatter.columnize(order);\n      }).join(', ');\n    }\n\n    sql += ')';\n\n    if (stmt.alias) {\n      sql += ' as ' + stmt.alias;\n    }\n\n    return sql;\n  } // Compiles all `with` statements on the query.\n\n\n  with() {\n    if (!this.grouped.with || !this.grouped.with.length) {\n      return '';\n    }\n\n    const withs = this.grouped.with;\n    if (!withs) return;\n    const sql = [];\n    let i = -1;\n    let isRecursive = false;\n\n    while (++i < withs.length) {\n      const stmt = withs[i];\n\n      if (stmt.recursive) {\n        isRecursive = true;\n      }\n\n      const val = this[stmt.type](stmt);\n      sql.push(val);\n    }\n\n    return `with ${isRecursive ? 'recursive ' : ''}${sql.join(', ')} `;\n  }\n\n  withWrapped(statement) {\n    const val = rawOrFn_(statement.value, undefined, this.builder, this.client, this.bindingsHolder);\n    return val && columnize_(statement.alias, this.builder, this.client, this.bindingsHolder) + ' as (' + val + ')' || '';\n  } // Determines whether to add a \"not\" prefix to the where clause.\n\n\n  _not(statement, str) {\n    if (statement.not) return `not ${str}`;\n    return str;\n  }\n\n  _prepInsert(data) {\n    const isRaw = rawOrFn_(data, undefined, this.builder, this.client, this.bindingsHolder);\n    if (isRaw) return isRaw;\n    let columns = [];\n    const values = [];\n    if (!Array.isArray(data)) data = data ? [data] : [];\n    let i = -1;\n\n    while (++i < data.length) {\n      if (data[i] == null) break;\n      if (i === 0) columns = Object.keys(data[i]).sort();\n      const row = new Array(columns.length);\n      const keys = Object.keys(data[i]);\n      let j = -1;\n\n      while (++j < keys.length) {\n        const key = keys[j];\n        let idx = columns.indexOf(key);\n\n        if (idx === -1) {\n          columns = columns.concat(key).sort();\n          idx = columns.indexOf(key);\n          let k = -1;\n\n          while (++k < values.length) {\n            values[k].splice(idx, 0, undefined);\n          }\n\n          row.splice(idx, 0, undefined);\n        }\n\n        row[idx] = data[i][key];\n      }\n\n      values.push(row);\n    }\n\n    return {\n      columns,\n      values\n    };\n  } // \"Preps\" the update.\n\n\n  _prepUpdate(data = {}) {\n    const {\n      counter = {}\n    } = this.single;\n\n    for (const column of Object.keys(counter)) {\n      //Skip?\n      if (has(data, column)) {\n        //Needed?\n        this.client.logger.warn(`increment/decrement called for a column that has already been specified in main .update() call. Ignoring increment/decrement and using value from .update() call.`);\n        continue;\n      }\n\n      let value = counter[column];\n      const symbol = value < 0 ? '-' : '+';\n\n      if (symbol === '-') {\n        value = -value;\n      }\n\n      data[column] = this.client.raw(`?? ${symbol} ?`, [column, value]);\n    }\n\n    data = omitBy(data, isUndefined);\n    const vals = [];\n    const columns = Object.keys(data);\n    let i = -1;\n\n    while (++i < columns.length) {\n      vals.push(wrap_(columns[i], undefined, this.builder, this.client, this.bindingsHolder) + ' = ' + this.client.parameter(data[columns[i]], this.builder, this.bindingsHolder));\n    }\n\n    if (isEmpty(vals)) {\n      throw new Error(['Empty .update() call detected!', 'Update data does not contain any values to update.', 'This will result in a faulty query.', this.single.table ? `Table: ${this.single.table}.` : '', this.single.update ? `Columns: ${Object.keys(this.single.update)}.` : ''].join(' '));\n    }\n\n    return vals;\n  }\n\n  _formatGroupsItemValue(value) {\n    const {\n      formatter\n    } = this;\n\n    if (value instanceof Raw) {\n      return unwrapRaw_(value, undefined, this.builder, this.client, this.bindingsHolder);\n    } else if (value instanceof QueryBuilder) {\n      return '(' + formatter.columnize(value) + ')';\n    } else {\n      return formatter.columnize(value);\n    }\n  } // Compiles the `order by` statements.\n\n\n  _groupsOrders(type) {\n    const items = this.grouped[type];\n    if (!items) return '';\n    const sql = items.map(item => {\n      const column = this._formatGroupsItemValue(item.value);\n\n      const direction = type === 'order' && item.type !== 'orderByRaw' ? ` ${direction_(item.direction, this.builder, this.client, this.bindingsHolder)}` : '';\n      return column + direction;\n    });\n    return sql.length ? type + ' by ' + sql.join(', ') : '';\n  } // Get the table name, wrapping it if necessary.\n  // Implemented as a property to prevent ordering issues as described in #704.\n\n\n  get tableName() {\n    if (!this._tableName) {\n      // Only call this.formatter.wrap() the first time this property is accessed.\n      let tableName = this.single.table;\n      const schemaName = this.single.schema;\n\n      if (tableName && schemaName) {\n        const isQueryBuilder = tableName instanceof QueryBuilder;\n        const isRawQuery = tableName instanceof Raw;\n        const isFunction = typeof tableName === 'function';\n\n        if (!isQueryBuilder && !isRawQuery && !isFunction) {\n          tableName = `${schemaName}.${tableName}`;\n        }\n      }\n\n      this._tableName = tableName ? // Wrap subQuery with parenthesis, #3485\n      wrap_(tableName, tableName instanceof QueryBuilder, this.builder, this.client, this.bindingsHolder) : '';\n    }\n\n    return this._tableName;\n  }\n\n}\n\nmodule.exports = QueryCompiler;","map":{"version":3,"sources":["/home/rosiane/back/node_modules/knex/lib/query/querycompiler.js"],"names":["helpers","require","Raw","QueryBuilder","JoinClause","debug","assign","compact","groupBy","has","isEmpty","map","omitBy","reduce","nanoid","isString","isUndefined","columnize","columnize_","direction","direction_","operator","operator_","wrap","wrap_","unwrapRaw","unwrapRaw_","rawOrFn","rawOrFn_","debugBindings","components","QueryCompiler","constructor","client","builder","bindings","method","_method","options","_options","single","_single","timeout","_timeout","cancelOnTimeout","_cancelOnTimeout","grouped","_statements","formatter","_emptyInsertValue","first","select","bindingsHolder","toSQL","tz","_undefinedInWhereClause","undefinedBindingsInfo","val","query","__knexQueryUid","Object","defineProperties","toNative","value","sql","positionBindings","prepBindings","enumerable","as","Error","toUpperCase","join","with","statements","component","pluck","toPluck","indexOf","split","slice","insert","insertValues","tableName","Array","isArray","length","insertData","_prepInsert","columns","i","values","parameterize","valueForUndefined","update","withSQL","updateData","_prepUpdate","wheres","where","only","_hintComments","hints","hintComments","hint","distinctClause","onlyUnions","stmt","distinct","distinctOn","type","push","aggregate","aggregateRaw","analytic","_aggregate","aliasSeparator","distinctParentheses","aggregateDistinct","identifier","undefined","addAlias","alias","aggregateArray","openParen","closeParen","trim","aggregated","aggregateString","entries","column","splitOn","toLowerCase","joins","table","schema","joinType","ii","clauses","clause","bool","onBetween","statement","_not","parameter","onNull","onExists","onIn","multiOnIn","prototype","hasOwnProperty","call","containsUndefined","group","_groupsOrders","order","having","havings","l","s","havingRaw","havingWrapped","havingBasic","havingNull","havingExists","havingBetween","havingIn","multiHavingIn","union","unions","limit","noLimit","offset","del","truncate","lock","waitMode","skipLocked","noWait","onWrapped","self","wrapJoin","wrapClause","onBasic","onVal","onRaw","onUsing","whereIn","whereNull","whereBasic","asColumn","whereExists","whereWrapped","whereBetween","whereRaw","str","charAt","raw","partitions","partition","withs","isRecursive","recursive","withWrapped","not","data","isRaw","keys","sort","row","j","key","idx","concat","k","splice","counter","logger","warn","symbol","vals","_formatGroupsItemValue","items","item","_tableName","schemaName","isQueryBuilder","isRawQuery","isFunction","module","exports"],"mappings":"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","sourcesContent":["// Query Compiler\n// -------\nconst helpers = require('../util/helpers');\nconst Raw = require('../raw');\nconst QueryBuilder = require('./querybuilder');\nconst JoinClause = require('./joinclause');\nconst debug = require('debug');\n\nconst assign = require('lodash/assign');\nconst compact = require('lodash/compact');\nconst groupBy = require('lodash/groupBy');\nconst has = require('lodash/has');\nconst isEmpty = require('lodash/isEmpty');\nconst map = require('lodash/map');\nconst omitBy = require('lodash/omitBy');\nconst reduce = require('lodash/reduce');\nconst { nanoid } = require('../util/nanoid');\nconst { isString, isUndefined } = require('../util/is');\nconst {\n  columnize: columnize_,\n  direction: direction_,\n  operator: operator_,\n  wrap: wrap_,\n  unwrapRaw: unwrapRaw_,\n  rawOrFn: rawOrFn_,\n} = require('../formatter/wrappingFormatter');\n\nconst debugBindings = debug('knex:bindings');\n\nconst components = [\n  'columns',\n  'join',\n  'where',\n  'union',\n  'group',\n  'having',\n  'order',\n  'limit',\n  'offset',\n  'lock',\n  'waitMode',\n];\n\n// The \"QueryCompiler\" takes all of the query statements which\n// have been gathered in the \"QueryBuilder\" and turns them into a\n// properly formatted / bound query string.\nclass QueryCompiler {\n  constructor(client, builder, bindings) {\n    this.client = client;\n    this.method = builder._method || 'select';\n    this.options = builder._options;\n    this.single = builder._single;\n    this.timeout = builder._timeout || false;\n    this.cancelOnTimeout = builder._cancelOnTimeout || false;\n    this.grouped = groupBy(builder._statements, 'grouping');\n    this.formatter = client.formatter(builder);\n    // Used when the insert call is empty.\n    this._emptyInsertValue = 'default values';\n    this.first = this.select;\n\n    this.bindings = bindings || [];\n    this.formatter.bindings = this.bindings;\n    this.bindingsHolder = this;\n    this.builder = this.formatter.builder;\n  }\n\n  // Collapse the builder into a single object\n  toSQL(method, tz) {\n    this._undefinedInWhereClause = false;\n    this.undefinedBindingsInfo = [];\n\n    method = method || this.method;\n    const val = this[method]() || '';\n\n    const query = {\n      method,\n      options: reduce(this.options, assign, {}),\n      timeout: this.timeout,\n      cancelOnTimeout: this.cancelOnTimeout,\n      bindings: this.bindingsHolder.bindings || [],\n      __knexQueryUid: nanoid(),\n    };\n\n    Object.defineProperties(query, {\n      toNative: {\n        value: () => {\n          return {\n            sql: this.client.positionBindings(query.sql),\n            bindings: this.client.prepBindings(query.bindings),\n          };\n        },\n        enumerable: false,\n      },\n    });\n\n    if (isString(val)) {\n      query.sql = val;\n    } else {\n      assign(query, val);\n    }\n\n    if (method === 'select' || method === 'first') {\n      if (this.single.as) {\n        query.as = this.single.as;\n      }\n    }\n\n    if (this._undefinedInWhereClause) {\n      debugBindings(query.bindings);\n      throw new Error(\n        `Undefined binding(s) detected when compiling ` +\n          `${method.toUpperCase()}. Undefined column(s): [${this.undefinedBindingsInfo.join(\n            ', '\n          )}] query: ${query.sql}`\n      );\n    }\n\n    return query;\n  }\n\n  // Compiles the `select` statement, or nested sub-selects by calling each of\n  // the component compilers, trimming out the empties, and returning a\n  // generated query string.\n  select() {\n    let sql = this.with();\n\n    const statements = components.map((component) => this[component](this));\n    sql += compact(statements).join(' ');\n    return sql;\n  }\n\n  pluck() {\n    let toPluck = this.single.pluck;\n    if (toPluck.indexOf('.') !== -1) {\n      toPluck = toPluck.split('.').slice(-1)[0];\n    }\n    return {\n      sql: this.select(),\n      pluck: toPluck,\n    };\n  }\n\n  // Compiles an \"insert\" query, allowing for multiple\n  // inserts using a single query statement.\n  insert() {\n    const insertValues = this.single.insert || [];\n    let sql = this.with() + `insert into ${this.tableName} `;\n    if (Array.isArray(insertValues)) {\n      if (insertValues.length === 0) {\n        return '';\n      }\n    } else if (typeof insertValues === 'object' && isEmpty(insertValues)) {\n      return sql + this._emptyInsertValue;\n    }\n\n    const insertData = this._prepInsert(insertValues);\n    if (typeof insertData === 'string') {\n      sql += insertData;\n    } else {\n      if (insertData.columns.length) {\n        sql += `(${columnize_(\n          insertData.columns,\n          this.builder,\n          this.client,\n          this.bindingsHolder\n        )}`;\n        sql += ') values (';\n        let i = -1;\n        while (++i < insertData.values.length) {\n          if (i !== 0) sql += '), (';\n          sql += this.client.parameterize(\n            insertData.values[i],\n            this.client.valueForUndefined,\n            this.builder,\n            this.bindingsHolder\n          );\n        }\n        sql += ')';\n      } else if (insertValues.length === 1 && insertValues[0]) {\n        sql += this._emptyInsertValue;\n      } else {\n        sql = '';\n      }\n    }\n    return sql;\n  }\n\n  // Compiles the \"update\" query.\n  update() {\n    // Make sure tableName is processed by the formatter first.\n    const withSQL = this.with();\n    const { tableName } = this;\n    const updateData = this._prepUpdate(this.single.update);\n    const wheres = this.where();\n    return (\n      withSQL +\n      `update ${this.single.only ? 'only ' : ''}${tableName}` +\n      ' set ' +\n      updateData.join(', ') +\n      (wheres ? ` ${wheres}` : '')\n    );\n  }\n\n  _hintComments() {\n    let hints = this.grouped.hintComments || [];\n    hints = hints.map((hint) => compact(hint.value).join(' '));\n    hints = compact(hints).join(' ');\n    return hints ? `/*+ ${hints} */ ` : '';\n  }\n\n  // Compiles the columns in the query, specifying if an item was distinct.\n  columns() {\n    let distinctClause = '';\n    if (this.onlyUnions()) return '';\n    const hints = this._hintComments();\n    const columns = this.grouped.columns || [];\n    let i = -1,\n      sql = [];\n    if (columns) {\n      while (++i < columns.length) {\n        const stmt = columns[i];\n        if (stmt.distinct) distinctClause = 'distinct ';\n        if (stmt.distinctOn) {\n          distinctClause = this.distinctOn(stmt.value);\n          continue;\n        }\n        if (stmt.type === 'aggregate') {\n          sql.push(...this.aggregate(stmt));\n        } else if (stmt.type === 'aggregateRaw') {\n          sql.push(this.aggregateRaw(stmt));\n        } else if (stmt.type === 'analytic') {\n          sql.push(this.analytic(stmt));\n        } else if (stmt.value && stmt.value.length > 0) {\n          sql.push(\n            columnize_(\n              stmt.value,\n              this.builder,\n              this.client,\n              this.bindingsHolder\n            )\n          );\n        }\n      }\n    }\n    if (sql.length === 0) sql = ['*'];\n    return (\n      `select ${hints}${distinctClause}` +\n      sql.join(', ') +\n      (this.tableName\n        ? ` from ${this.single.only ? 'only ' : ''}${this.tableName}`\n        : '')\n    );\n  }\n\n  _aggregate(stmt, { aliasSeparator = ' as ', distinctParentheses } = {}) {\n    const value = stmt.value;\n    const method = stmt.method;\n    const distinct = stmt.aggregateDistinct ? 'distinct ' : '';\n    const wrap = (identifier) =>\n      wrap_(\n        identifier,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      );\n    const addAlias = (value, alias) => {\n      if (alias) {\n        return value + aliasSeparator + wrap(alias);\n      }\n      return value;\n    };\n    const aggregateArray = (value, alias) => {\n      let columns = value.map(wrap).join(', ');\n      if (distinct) {\n        const openParen = distinctParentheses ? '(' : ' ';\n        const closeParen = distinctParentheses ? ')' : '';\n        columns = distinct.trim() + openParen + columns + closeParen;\n      }\n      const aggregated = `${method}(${columns})`;\n      return addAlias(aggregated, alias);\n    };\n    const aggregateString = (value, alias) => {\n      const aggregated = `${method}(${distinct + wrap(value)})`;\n      return addAlias(aggregated, alias);\n    };\n\n    if (Array.isArray(value)) {\n      return [aggregateArray(value)];\n    }\n\n    if (typeof value === 'object') {\n      if (stmt.alias) {\n        throw new Error('When using an object explicit alias can not be used');\n      }\n      return Object.entries(value).map(([alias, column]) => {\n        if (Array.isArray(column)) {\n          return aggregateArray(column, alias);\n        }\n        return aggregateString(column, alias);\n      });\n    }\n\n    // Allows us to speciy an alias for the aggregate types.\n    const splitOn = value.toLowerCase().indexOf(' as ');\n    let column = value;\n    let { alias } = stmt;\n    if (splitOn !== -1) {\n      column = value.slice(0, splitOn);\n      if (alias) {\n        throw new Error(`Found multiple aliases for same column: ${column}`);\n      }\n      alias = value.slice(splitOn + 4);\n    }\n    return [aggregateString(column, alias)];\n  }\n\n  aggregate(stmt) {\n    return this._aggregate(stmt);\n  }\n\n  aggregateRaw(stmt) {\n    const distinct = stmt.aggregateDistinct ? 'distinct ' : '';\n    return `${stmt.method}(${\n      distinct +\n      unwrapRaw_(\n        stmt.value,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      )\n    })`;\n  }\n\n  // Compiles all each of the `join` clauses on the query,\n  // including any nested join queries.\n  join() {\n    let sql = '';\n    let i = -1;\n    const joins = this.grouped.join;\n    if (!joins) return '';\n    while (++i < joins.length) {\n      const join = joins[i];\n      const table =\n        join.schema && !(join.table instanceof Raw)\n          ? `${join.schema}.${join.table}`\n          : join.table;\n      if (i > 0) sql += ' ';\n      if (join.joinType === 'raw') {\n        sql += unwrapRaw_(\n          join.table,\n          undefined,\n          this.builder,\n          this.client,\n          this.bindingsHolder\n        );\n      } else {\n        sql +=\n          join.joinType +\n          ' join ' +\n          wrap_(\n            table,\n            undefined,\n            this.builder,\n            this.client,\n            this.bindingsHolder\n          );\n        let ii = -1;\n        while (++ii < join.clauses.length) {\n          const clause = join.clauses[ii];\n          if (ii > 0) {\n            sql += ` ${clause.bool} `;\n          } else {\n            sql += ` ${clause.type === 'onUsing' ? 'using' : 'on'} `;\n          }\n          const val = this[clause.type](clause);\n          if (val) {\n            sql += val;\n          }\n        }\n      }\n    }\n    return sql;\n  }\n\n  onBetween(statement) {\n    return (\n      wrap_(\n        statement.column,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ' ' +\n      this._not(statement, 'between') +\n      ' ' +\n      statement.value\n        .map((value) =>\n          this.client.parameter(value, this.builder, this.bindingsHolder)\n        )\n        .join(' and ')\n    );\n  }\n\n  onNull(statement) {\n    return (\n      wrap_(\n        statement.column,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ' is ' +\n      this._not(statement, 'null')\n    );\n  }\n\n  onExists(statement) {\n    return (\n      this._not(statement, 'exists') +\n      ' (' +\n      rawOrFn_(\n        statement.value,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ')'\n    );\n  }\n\n  onIn(statement) {\n    if (Array.isArray(statement.column)) return this.multiOnIn(statement);\n    return (\n      wrap_(\n        statement.column,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ' ' +\n      this._not(statement, 'in ') +\n      this.wrap(\n        this.client.parameterize(\n          statement.value,\n          undefined,\n          this.builder,\n          this.bindingsHolder\n        )\n      )\n    );\n  }\n\n  multiOnIn(statement) {\n    let i = -1,\n      sql = `(${columnize_(\n        statement.column,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      )}) `;\n    sql += this._not(statement, 'in ') + '((';\n    while (++i < statement.value.length) {\n      if (i !== 0) sql += '),(';\n      sql += this.client.parameterize(\n        statement.value[i],\n        undefined,\n        this.builder,\n        this.bindingsHolder\n      );\n    }\n    return sql + '))';\n  }\n\n  // Compiles all `where` statements on the query.\n  where() {\n    const wheres = this.grouped.where;\n    if (!wheres) return;\n    const sql = [];\n    let i = -1;\n    while (++i < wheres.length) {\n      const stmt = wheres[i];\n      if (\n        Object.prototype.hasOwnProperty.call(stmt, 'value') &&\n        helpers.containsUndefined(stmt.value)\n      ) {\n        this.undefinedBindingsInfo.push(stmt.column);\n        this._undefinedInWhereClause = true;\n      }\n      const val = this[stmt.type](stmt);\n      if (val) {\n        if (sql.length === 0) {\n          sql[0] = 'where';\n        } else {\n          sql.push(stmt.bool);\n        }\n        sql.push(val);\n      }\n    }\n    return sql.length > 1 ? sql.join(' ') : '';\n  }\n\n  group() {\n    return this._groupsOrders('group');\n  }\n\n  order() {\n    return this._groupsOrders('order');\n  }\n\n  // Compiles the `having` statements.\n  having() {\n    const havings = this.grouped.having;\n    if (!havings) return '';\n    const sql = ['having'];\n    for (let i = 0, l = havings.length; i < l; i++) {\n      const s = havings[i];\n      const val = this[s.type](s);\n      if (val) {\n        if (sql.length === 0) {\n          sql[0] = 'where';\n        }\n        if (sql.length > 1 || (sql.length === 1 && sql[0] !== 'having')) {\n          sql.push(s.bool);\n        }\n        sql.push(val);\n      }\n    }\n    return sql.length > 1 ? sql.join(' ') : '';\n  }\n\n  havingRaw(statement) {\n    return (\n      this._not(statement, '') +\n      unwrapRaw_(\n        statement.value,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      )\n    );\n  }\n\n  havingWrapped(statement) {\n    const val = rawOrFn_(\n      statement.value,\n      'where',\n      this.builder,\n      this.client,\n      this.bindingsHolder\n    );\n    return (val && this._not(statement, '') + '(' + val.slice(6) + ')') || '';\n  }\n\n  havingBasic(statement) {\n    return (\n      this._not(statement, '') +\n      wrap_(\n        statement.column,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ' ' +\n      operator_(\n        statement.operator,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ' ' +\n      this.client.parameter(statement.value, this.builder, this.bindingsHolder)\n    );\n  }\n\n  havingNull(statement) {\n    return (\n      wrap_(\n        statement.column,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ' is ' +\n      this._not(statement, 'null')\n    );\n  }\n\n  havingExists(statement) {\n    return (\n      this._not(statement, 'exists') +\n      ' (' +\n      rawOrFn_(\n        statement.value,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ')'\n    );\n  }\n\n  havingBetween(statement) {\n    return (\n      wrap_(\n        statement.column,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ' ' +\n      this._not(statement, 'between') +\n      ' ' +\n      statement.value\n        .map((value) =>\n          this.client.parameter(value, this.builder, this.bindingsHolder)\n        )\n        .join(' and ')\n    );\n  }\n\n  havingIn(statement) {\n    if (Array.isArray(statement.column)) return this.multiHavingIn(statement);\n    return (\n      wrap_(\n        statement.column,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ' ' +\n      this._not(statement, 'in ') +\n      this.wrap(\n        this.client.parameterize(\n          statement.value,\n          undefined,\n          this.builder,\n          this.bindingsHolder\n        )\n      )\n    );\n  }\n\n  multiHavingIn(statement) {\n    let i = -1,\n      sql = `(${columnize_(\n        statement.column,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      )}) `;\n    sql += this._not(statement, 'in ') + '((';\n    while (++i < statement.value.length) {\n      if (i !== 0) sql += '),(';\n      sql += this.client.parameterize(\n        statement.value[i],\n        undefined,\n        this.builder,\n        this.bindingsHolder\n      );\n    }\n    return sql + '))';\n  }\n\n  // Compile the \"union\" queries attached to the main query.\n  union() {\n    const onlyUnions = this.onlyUnions();\n    const unions = this.grouped.union;\n    if (!unions) return '';\n    let sql = '';\n    for (let i = 0, l = unions.length; i < l; i++) {\n      const union = unions[i];\n      if (i > 0) sql += ' ';\n      if (i > 0 || !onlyUnions) sql += union.clause + ' ';\n      const statement = rawOrFn_(\n        union.value,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      );\n      if (statement) {\n        if (union.wrap) sql += '(';\n        sql += statement;\n        if (union.wrap) sql += ')';\n      }\n    }\n    return sql;\n  }\n\n  // If we haven't specified any columns or a `tableName`, we're assuming this\n  // is only being used for unions.\n  onlyUnions() {\n    return !this.grouped.columns && this.grouped.union && !this.tableName;\n  }\n\n  limit() {\n    const noLimit = !this.single.limit && this.single.limit !== 0;\n    if (noLimit) return '';\n    return `limit ${this.client.parameter(\n      this.single.limit,\n      this.builder,\n      this.bindingsHolder\n    )}`;\n  }\n\n  offset() {\n    if (!this.single.offset) return '';\n    return `offset ${this.client.parameter(\n      this.single.offset,\n      this.builder,\n      this.bindingsHolder\n    )}`;\n  }\n\n  // Compiles a `delete` query.\n  del() {\n    // Make sure tableName is processed by the formatter first.\n    const { tableName } = this;\n    const withSQL = this.with();\n    const wheres = this.where();\n    return (\n      withSQL +\n      `delete from ${this.single.only ? 'only ' : ''}${tableName}` +\n      (wheres ? ` ${wheres}` : '')\n    );\n  }\n\n  // Compiles a `truncate` query.\n  truncate() {\n    return `truncate ${this.tableName}`;\n  }\n\n  // Compiles the \"locks\".\n  lock() {\n    if (this.single.lock) {\n      return this[this.single.lock]();\n    }\n  }\n\n  // Compiles the wait mode on the locks.\n  waitMode() {\n    if (this.single.waitMode) {\n      return this[this.single.waitMode]();\n    }\n  }\n\n  // Fail on unsupported databases\n  skipLocked() {\n    throw new Error(\n      '.skipLocked() is currently only supported on MySQL 8.0+ and PostgreSQL 9.5+'\n    );\n  }\n\n  // Fail on unsupported databases\n  noWait() {\n    throw new Error(\n      '.noWait() is currently only supported on MySQL 8.0+, MariaDB 10.3.0+ and PostgreSQL 9.5+'\n    );\n  }\n\n  distinctOn(value) {\n    throw new Error('.distinctOn() is currently only supported on PostgreSQL');\n  }\n\n  // On Clause\n  // ------\n\n  onWrapped(clause) {\n    const self = this;\n\n    const wrapJoin = new JoinClause();\n    clause.value.call(wrapJoin, wrapJoin);\n\n    let sql = '';\n\n    for (let ii = 0; ii < wrapJoin.clauses.length; ii++) {\n      const wrapClause = wrapJoin.clauses[ii];\n      if (ii > 0) {\n        sql += ` ${wrapClause.bool} `;\n      }\n      const val = self[wrapClause.type](wrapClause);\n      if (val) {\n        sql += val;\n      }\n    }\n\n    if (sql.length) {\n      return `(${sql})`;\n    }\n    return '';\n  }\n\n  onBasic(clause) {\n    return (\n      wrap_(\n        clause.column,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ' ' +\n      operator_(\n        clause.operator,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ' ' +\n      wrap_(\n        clause.value,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      )\n    );\n  }\n\n  onVal(clause) {\n    return (\n      wrap_(\n        clause.column,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ' ' +\n      operator_(\n        clause.operator,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ' ' +\n      this.client.parameter(clause.value, this.builder, this.bindingsHolder)\n    );\n  }\n\n  onRaw(clause) {\n    return unwrapRaw_(\n      clause.value,\n      undefined,\n      this.builder,\n      this.client,\n      this.bindingsHolder\n    );\n  }\n\n  onUsing(clause) {\n    return (\n      '(' +\n      columnize_(\n        clause.column,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ')'\n    );\n  }\n\n  // Where Clause\n  // ------\n\n  whereIn(statement) {\n    let columns;\n    if (Array.isArray(statement.column)) {\n      columns = `(${columnize_(\n        statement.column,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      )})`;\n    } else {\n      columns = wrap_(\n        statement.column,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      );\n    }\n\n    const values = this.client.values(\n      statement.value,\n      this.builder,\n      this.bindingsHolder\n    );\n    return `${columns} ${this._not(statement, 'in ')}${values}`;\n  }\n\n  whereNull(statement) {\n    return (\n      wrap_(\n        statement.column,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ' is ' +\n      this._not(statement, 'null')\n    );\n  }\n\n  // Compiles a basic \"where\" clause.\n  whereBasic(statement) {\n    return (\n      this._not(statement, '') +\n      wrap_(\n        statement.column,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ' ' +\n      operator_(\n        statement.operator,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ' ' +\n      (statement.asColumn\n        ? wrap_(\n            statement.value,\n            undefined,\n            this.builder,\n            this.client,\n            this.bindingsHolder\n          )\n        : this.client.parameter(\n            statement.value,\n            this.builder,\n            this.bindingsHolder\n          ))\n    );\n  }\n\n  whereExists(statement) {\n    return (\n      this._not(statement, 'exists') +\n      ' (' +\n      rawOrFn_(\n        statement.value,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ')'\n    );\n  }\n\n  whereWrapped(statement) {\n    const val = rawOrFn_(\n      statement.value,\n      'where',\n      this.builder,\n      this.client,\n      this.bindingsHolder\n    );\n    return (val && this._not(statement, '') + '(' + val.slice(6) + ')') || '';\n  }\n\n  whereBetween(statement) {\n    return (\n      wrap_(\n        statement.column,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      ) +\n      ' ' +\n      this._not(statement, 'between') +\n      ' ' +\n      statement.value\n        .map((value) =>\n          this.client.parameter(value, this.builder, this.bindingsHolder)\n        )\n        .join(' and ')\n    );\n  }\n\n  // Compiles a \"whereRaw\" query.\n  whereRaw(statement) {\n    return (\n      this._not(statement, '') +\n      unwrapRaw_(\n        statement.value,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      )\n    );\n  }\n\n  wrap(str) {\n    if (str.charAt(0) !== '(') return `(${str})`;\n    return str;\n  }\n\n  analytic(stmt) {\n    let sql = '';\n    const self = this;\n    sql += stmt.method + '() over (';\n\n    if (stmt.raw) {\n      sql += stmt.raw;\n    } else {\n      if (stmt.partitions.length) {\n        sql += 'partition by ';\n        sql +=\n          map(stmt.partitions, function (partition) {\n            return self.formatter.columnize(partition);\n          }).join(', ') + ' ';\n      }\n\n      sql += 'order by ';\n      sql += map(stmt.order, function (order) {\n        return self.formatter.columnize(order);\n      }).join(', ');\n    }\n\n    sql += ')';\n\n    if (stmt.alias) {\n      sql += ' as ' + stmt.alias;\n    }\n\n    return sql;\n  }\n\n  // Compiles all `with` statements on the query.\n  with() {\n    if (!this.grouped.with || !this.grouped.with.length) {\n      return '';\n    }\n    const withs = this.grouped.with;\n    if (!withs) return;\n    const sql = [];\n    let i = -1;\n    let isRecursive = false;\n    while (++i < withs.length) {\n      const stmt = withs[i];\n      if (stmt.recursive) {\n        isRecursive = true;\n      }\n      const val = this[stmt.type](stmt);\n      sql.push(val);\n    }\n    return `with ${isRecursive ? 'recursive ' : ''}${sql.join(', ')} `;\n  }\n\n  withWrapped(statement) {\n    const val = rawOrFn_(\n      statement.value,\n      undefined,\n      this.builder,\n      this.client,\n      this.bindingsHolder\n    );\n    return (\n      (val &&\n        columnize_(\n          statement.alias,\n          this.builder,\n          this.client,\n          this.bindingsHolder\n        ) +\n          ' as (' +\n          val +\n          ')') ||\n      ''\n    );\n  }\n\n  // Determines whether to add a \"not\" prefix to the where clause.\n  _not(statement, str) {\n    if (statement.not) return `not ${str}`;\n    return str;\n  }\n\n  _prepInsert(data) {\n    const isRaw = rawOrFn_(\n      data,\n      undefined,\n      this.builder,\n      this.client,\n      this.bindingsHolder\n    );\n    if (isRaw) return isRaw;\n    let columns = [];\n    const values = [];\n    if (!Array.isArray(data)) data = data ? [data] : [];\n    let i = -1;\n    while (++i < data.length) {\n      if (data[i] == null) break;\n      if (i === 0) columns = Object.keys(data[i]).sort();\n      const row = new Array(columns.length);\n      const keys = Object.keys(data[i]);\n      let j = -1;\n      while (++j < keys.length) {\n        const key = keys[j];\n        let idx = columns.indexOf(key);\n        if (idx === -1) {\n          columns = columns.concat(key).sort();\n          idx = columns.indexOf(key);\n          let k = -1;\n          while (++k < values.length) {\n            values[k].splice(idx, 0, undefined);\n          }\n          row.splice(idx, 0, undefined);\n        }\n        row[idx] = data[i][key];\n      }\n      values.push(row);\n    }\n    return {\n      columns,\n      values,\n    };\n  }\n\n  // \"Preps\" the update.\n  _prepUpdate(data = {}) {\n    const { counter = {} } = this.single;\n\n    for (const column of Object.keys(counter)) {\n      //Skip?\n      if (has(data, column)) {\n        //Needed?\n        this.client.logger.warn(\n          `increment/decrement called for a column that has already been specified in main .update() call. Ignoring increment/decrement and using value from .update() call.`\n        );\n        continue;\n      }\n\n      let value = counter[column];\n\n      const symbol = value < 0 ? '-' : '+';\n\n      if (symbol === '-') {\n        value = -value;\n      }\n\n      data[column] = this.client.raw(`?? ${symbol} ?`, [column, value]);\n    }\n\n    data = omitBy(data, isUndefined);\n\n    const vals = [];\n    const columns = Object.keys(data);\n    let i = -1;\n\n    while (++i < columns.length) {\n      vals.push(\n        wrap_(\n          columns[i],\n          undefined,\n          this.builder,\n          this.client,\n          this.bindingsHolder\n        ) +\n          ' = ' +\n          this.client.parameter(\n            data[columns[i]],\n            this.builder,\n            this.bindingsHolder\n          )\n      );\n    }\n\n    if (isEmpty(vals)) {\n      throw new Error(\n        [\n          'Empty .update() call detected!',\n          'Update data does not contain any values to update.',\n          'This will result in a faulty query.',\n          this.single.table ? `Table: ${this.single.table}.` : '',\n          this.single.update\n            ? `Columns: ${Object.keys(this.single.update)}.`\n            : '',\n        ].join(' ')\n      );\n    }\n\n    return vals;\n  }\n\n  _formatGroupsItemValue(value) {\n    const { formatter } = this;\n    if (value instanceof Raw) {\n      return unwrapRaw_(\n        value,\n        undefined,\n        this.builder,\n        this.client,\n        this.bindingsHolder\n      );\n    } else if (value instanceof QueryBuilder) {\n      return '(' + formatter.columnize(value) + ')';\n    } else {\n      return formatter.columnize(value);\n    }\n  }\n\n  // Compiles the `order by` statements.\n  _groupsOrders(type) {\n    const items = this.grouped[type];\n    if (!items) return '';\n    const sql = items.map((item) => {\n      const column = this._formatGroupsItemValue(item.value);\n      const direction =\n        type === 'order' && item.type !== 'orderByRaw'\n          ? ` ${direction_(\n              item.direction,\n              this.builder,\n              this.client,\n              this.bindingsHolder\n            )}`\n          : '';\n      return column + direction;\n    });\n    return sql.length ? type + ' by ' + sql.join(', ') : '';\n  }\n\n  // Get the table name, wrapping it if necessary.\n  // Implemented as a property to prevent ordering issues as described in #704.\n  get tableName() {\n    if (!this._tableName) {\n      // Only call this.formatter.wrap() the first time this property is accessed.\n      let tableName = this.single.table;\n      const schemaName = this.single.schema;\n\n      if (tableName && schemaName) {\n        const isQueryBuilder = tableName instanceof QueryBuilder;\n        const isRawQuery = tableName instanceof Raw;\n        const isFunction = typeof tableName === 'function';\n\n        if (!isQueryBuilder && !isRawQuery && !isFunction) {\n          tableName = `${schemaName}.${tableName}`;\n        }\n      }\n\n      this._tableName = tableName\n        ? // Wrap subQuery with parenthesis, #3485\n          wrap_(\n            tableName,\n            tableName instanceof QueryBuilder,\n            this.builder,\n            this.client,\n            this.bindingsHolder\n          )\n        : '';\n    }\n    return this._tableName;\n  }\n}\n\nmodule.exports = QueryCompiler;\n"]},"metadata":{},"sourceType":"script"}